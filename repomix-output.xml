This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.dockerignore
.env.example
.github/workflows/build-and-publish.yml
.github/workflows/docker-publish.yml
.gitignore
.gitmodules
.python-version
app/__init__.py
app/api/__init__.py
app/api/main.py
app/api/routes/accounts.py
app/api/routes/claude.py
app/api/routes/settings.py
app/api/routes/statistics.py
app/core/__init__.py
app/core/account.py
app/core/claude_session.py
app/core/config.py
app/core/error_handler.py
app/core/exceptions.py
app/core/external/claude_client.py
app/core/http_client.py
app/core/static.py
app/dependencies/__init__.py
app/dependencies/auth.py
app/locales/en.json
app/locales/zh.json
app/main.py
app/models/__init__.py
app/models/claude.py
app/models/internal.py
app/models/streaming.py
app/processors/__init__.py
app/processors/base.py
app/processors/claude_ai/__init__.py
app/processors/claude_ai/claude_api_processor.py
app/processors/claude_ai/claude_web_processor.py
app/processors/claude_ai/context.py
app/processors/claude_ai/event_parser_processor.py
app/processors/claude_ai/message_collector_processor.py
app/processors/claude_ai/model_injector_processor.py
app/processors/claude_ai/non_streaming_response_processor.py
app/processors/claude_ai/pipeline.py
app/processors/claude_ai/stop_sequences_processor.py
app/processors/claude_ai/streaming_response_processor.py
app/processors/claude_ai/tavern_test_message_processor.py
app/processors/claude_ai/token_counter_processor.py
app/processors/claude_ai/tool_call_event_processor.py
app/processors/claude_ai/tool_result_processor.py
app/processors/pipeline.py
app/services/__init__.py
app/services/account.py
app/services/cache.py
app/services/event_processing/__init__.py
app/services/event_processing/event_parser.py
app/services/event_processing/event_serializer.py
app/services/i18n.py
app/services/oauth.py
app/services/session.py
app/services/tool_call.py
app/utils/__init__.py
app/utils/logger.py
app/utils/messages.py
app/utils/retry.py
docker-compose.yml
Dockerfile
Dockerfile.huggingface
Dockerfile.pypi
front/.gitignore
front/components.json
front/eslint.config.js
front/index.html
front/package.json
front/prettier.config.cjs
front/public/vite.svg
front/README.md
front/src/api/client.ts
front/src/api/types.ts
front/src/App.tsx
front/src/assets/react.svg
front/src/components/AccountModal.tsx
front/src/components/BatchCookieModal.tsx
front/src/components/Layout.tsx
front/src/components/OAuthModal.tsx
front/src/components/ui/alert-dialog.tsx
front/src/components/ui/alert.tsx
front/src/components/ui/badge.tsx
front/src/components/ui/button.tsx
front/src/components/ui/card.tsx
front/src/components/ui/collapsible.tsx
front/src/components/ui/dialog.tsx
front/src/components/ui/drawer.tsx
front/src/components/ui/dropdown-menu.tsx
front/src/components/ui/input.tsx
front/src/components/ui/label.tsx
front/src/components/ui/progress.tsx
front/src/components/ui/select.tsx
front/src/components/ui/separator.tsx
front/src/components/ui/sheet.tsx
front/src/components/ui/sidebar.tsx
front/src/components/ui/skeleton.tsx
front/src/components/ui/sonner.tsx
front/src/components/ui/switch.tsx
front/src/components/ui/table.tsx
front/src/components/ui/textarea.tsx
front/src/components/ui/tooltip.tsx
front/src/hooks/use-mobile.ts
front/src/i18n/i18n-config.ts
front/src/i18n/locales/en.json
front/src/i18n/locales/zh.json
front/src/index.css
front/src/main.tsx
front/src/pages/Accounts.tsx
front/src/pages/Dashboard.tsx
front/src/pages/Login.tsx
front/src/pages/Settings.tsx
front/src/utils/validators.ts
front/src/vite-env.d.ts
front/tsconfig.app.json
front/tsconfig.json
front/tsconfig.node.json
front/vite.config.ts
LICENSE
Makefile
MANIFEST.in
plans/260224-frontend-i18n-english-localization/plan.md
plans/260224-frontend-i18n-english-localization/reports/code-review-report.md
plans/reports/code-review-i18n-implementation.md
pyproject.toml
README_en.md
README.md
scripts/build_wheel.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[codz]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py.cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# UV
#   Similar to Pipfile.lock, it is generally recommended to include uv.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#uv.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock
#poetry.toml

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#   pdm recommends including project-wide configuration in pdm.toml, but excluding .pdm-python.
#   https://pdm-project.org/en/latest/usage/project/#working-with-version-control
#pdm.lock
#pdm.toml
.pdm-python
.pdm-build/

# pixi
#   Similar to Pipfile.lock, it is generally recommended to include pixi.lock in version control.
#pixi.lock
#   Pixi creates a virtual environment in the .pixi directory, just like venv module creates one
#   in the .venv directory. It is recommended not to include this directory in version control.
.pixi

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.envrc
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

# Abstra
# Abstra is an AI-powered process automation framework.
# Ignore directories containing user credentials, local state, and settings.
# Learn more at https://abstra.io/docs
.abstra/

# Visual Studio Code
#  Visual Studio Code specific template is maintained in a separate VisualStudioCode.gitignore 
#  that can be found at https://github.com/github/gitignore/blob/main/Global/VisualStudioCode.gitignore
#  and can be added to the global gitignore or merged into this file. However, if you prefer, 
#  you could uncomment the following to ignore the entire vscode folder
# .vscode/

# Ruff stuff:
.ruff_cache/

# PyPI configuration file
.pypirc

# Cursor
#  Cursor is an AI-powered code editor. `.cursorignore` specifies files/directories to
#  exclude from AI features like autocomplete and code analysis. Recommended for sensitive data
#  refer to https://docs.cursor.com/context/ignore-files
.cursorignore
.cursorindexingignore

# Marimo
marimo/_static/
marimo/_lsp/
__marimo__/

# Data
/data/

# Built frontend static files
app/static/
</file>

<file path=".python-version">
3.13
</file>

<file path="app/__init__.py">
__version__ = "0.1.0"
</file>

<file path="app/api/__init__.py">

</file>

<file path="app/api/main.py">
from fastapi import APIRouter
from app.api.routes import claude, accounts, settings, statistics

api_router = APIRouter()

api_router.include_router(claude.router, prefix="/v1", tags=["Claude API"])
api_router.include_router(
    accounts.router, prefix="/api/admin/accounts", tags=["Account Management"]
)
api_router.include_router(
    settings.router, prefix="/api/admin/settings", tags=["Settings Management"]
)
api_router.include_router(
    statistics.router, prefix="/api/admin/statistics", tags=["Statistics"]
)
</file>

<file path="app/api/routes/statistics.py">
from typing import Literal
from fastapi import APIRouter
from pydantic import BaseModel

from app.dependencies.auth import AdminAuthDep
from app.services.account import account_manager


class AccountStats(BaseModel):
    total_accounts: int
    valid_accounts: int
    rate_limited_accounts: int
    invalid_accounts: int
    active_sessions: int


class StatisticsResponse(BaseModel):
    status: Literal["healthy", "degraded"]
    accounts: AccountStats


router = APIRouter()


@router.get("", response_model=StatisticsResponse)
async def get_statistics(_: AdminAuthDep):
    """Get system statistics. Requires admin authentication."""
    stats = await account_manager.get_status()
    return {
        "status": "healthy" if stats["valid_accounts"] > 0 else "degraded",
        "accounts": stats,
    }
</file>

<file path="app/core/__init__.py">

</file>

<file path="app/core/error_handler.py">
from typing import Dict, Any
from fastapi import Request
from fastapi.responses import JSONResponse
from loguru import logger

from app.services.i18n import i18n_service
from app.core.exceptions import AppError


class ErrorHandler:
    """
    Centralized error handler for the application. Handles AppException.
    """

    @staticmethod
    def get_language_from_request(request: Request) -> str:
        """Extract language preference from request headers."""
        accept_language = request.headers.get("accept-language")
        return i18n_service.parse_accept_language(accept_language)

    @staticmethod
    def format_error_response(
        error_code: int, message: str, context: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """
        Format error response in standardized format.

        Args:
            error_code: 6-digit error code
            message: Localized error message
            context: Additional context information

        Returns:
            Formatted error response
        """
        response = {"detail": {"code": error_code, "message": message}}

        # Add context if provided and not empty
        if context:
            response["detail"]["context"] = context

        return response

    @staticmethod
    async def handle_app_exception(request: Request, exc: AppError) -> JSONResponse:
        """
        Handle AppException instances.

        Args:
            request: The FastAPI request object
            exc: The AppException instance

        Returns:
            JSONResponse with localized error message
        """
        language = ErrorHandler.get_language_from_request(request)

        # Get localized message
        message = i18n_service.get_message(
            message_key=exc.message_key, language=language, context=exc.context
        )

        # Format response
        response_data = ErrorHandler.format_error_response(
            error_code=exc.error_code,
            message=message,
            context=exc.context if exc.context else None,
        )

        # Log the error
        logger.warning(
            f"AppException: {exc.__class__.__name__} - "
            f"Code: {exc.error_code}, Message: {message}, "
            f"Context: {exc.context}"
        )

        return JSONResponse(status_code=exc.status_code, content=response_data)


# Exception handler functions for FastAPI
async def app_exception_handler(request: Request, exc: AppError) -> JSONResponse:
    """FastAPI exception handler for AppException."""
    return await ErrorHandler.handle_app_exception(request, exc)
</file>

<file path="app/dependencies/__init__.py">

</file>

<file path="app/models/__init__.py">

</file>

<file path="app/processors/__init__.py">
from app.processors.base import BaseProcessor, BaseContext
from app.processors.claude_ai import (
    ClaudeAIContext,
    TestMessageProcessor,
    ClaudeWebProcessor,
    EventParsingProcessor,
    StreamingResponseProcessor,
    MessageCollectorProcessor,
    NonStreamingResponseProcessor,
    TokenCounterProcessor,
    ToolResultProcessor,
    ToolCallEventProcessor,
    StopSequencesProcessor,
)

__all__ = [
    # Base classes
    "BaseProcessor",
    "BaseContext",
    # Claude AI Pipeline
    "ClaudeAIContext",
    "TestMessageProcessor",
    "ClaudeWebProcessor",
    "EventParsingProcessor",
    "StreamingResponseProcessor",
    "MessageCollectorProcessor",
    "NonStreamingResponseProcessor",
    "TokenCounterProcessor",
    "ToolResultProcessor",
    "ToolCallEventProcessor",
    "StopSequencesProcessor",
]
</file>

<file path="app/processors/base.py">
"""Base classes for request processing pipeline."""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Optional

from fastapi import Request
from fastapi.responses import StreamingResponse, JSONResponse


@dataclass
class BaseContext:
    """Base context passed between processors in the pipeline."""

    original_request: Request
    response: Optional[StreamingResponse | JSONResponse] = None
    metadata: dict = field(
        default_factory=dict
    )  # For storing custom data between processors


class BaseProcessor(ABC):
    """Base class for all request processors."""

    @abstractmethod
    async def process(self, context: BaseContext) -> BaseContext:
        """
        Process the request context.

        Args:
            context: The processing context

        Returns:
            Updated context.
        """
        pass

    @property
    def name(self) -> str:
        """Get the processor name."""
        return self.__class__.__name__
</file>

<file path="app/processors/claude_ai/event_parser_processor.py">
from loguru import logger

from app.processors.base import BaseProcessor
from app.processors.claude_ai import ClaudeAIContext
from app.services.event_processing.event_parser import EventParser


class EventParsingProcessor(BaseProcessor):
    """Processor that parses SSE streams into StreamingEvent objects."""

    def __init__(self):
        super().__init__()
        self.parser = EventParser()

    async def process(self, context: ClaudeAIContext) -> ClaudeAIContext:
        """
        Parse the original_stream into event_stream.

        Requires:
            - original_stream in context

        Produces:
            - event_stream in context
        """
        if context.event_stream:
            logger.debug("Skipping EventParsingProcessor due to existing event_stream")
            return context

        if not context.original_stream:
            logger.warning(
                "Skipping EventParsingProcessor due to missing original_stream"
            )
            return context

        logger.debug("Starting event parsing from SSE stream")
        context.event_stream = self.parser.parse_stream(context.original_stream)

        return context
</file>

<file path="app/processors/claude_ai/non_streaming_response_processor.py">
from loguru import logger
from fastapi.responses import JSONResponse

from app.core.exceptions import ClaudeStreamingError, NoMessageError
from app.models.streaming import ErrorEvent
from app.processors.base import BaseProcessor
from app.processors.claude_ai import ClaudeAIContext


class NonStreamingResponseProcessor(BaseProcessor):
    """Processor that builds a non-streaming JSON response from collected message."""

    async def process(self, context: ClaudeAIContext) -> ClaudeAIContext:
        """
        Build a non-streaming JSON response from the collected message.
        This processor only runs for non-streaming requests.

        Requires:
            - messages_api_request with stream=False
            - collected_message in context (must consume entire stream first)

        Produces:
            - response (JSONResponse) in context
        """
        if context.response:
            logger.debug(
                "Skipping NonStreamingResponseProcessor due to existing response"
            )
            return context

        if context.messages_api_request and context.messages_api_request.stream is True:
            logger.debug("Skipping NonStreamingResponseProcessor for streaming request")
            return context

        if not context.event_stream:
            logger.warning(
                "Skipping NonStreamingResponseProcessor due to missing event_stream"
            )
            return context

        logger.info("Building non-streaming response")

        # Consume the entire stream to ensure collected_message is complete
        async for event in context.event_stream:
            if isinstance(event.root, ErrorEvent):
                raise ClaudeStreamingError(
                    error_type=event.root.error.type,
                    error_message=event.root.error.message,
                )

        if not context.collected_message:
            logger.error("No message collected after consuming stream")
            raise NoMessageError()

        context.response = JSONResponse(
            content=context.collected_message.model_dump(exclude_none=True),
            headers={
                "Content-Type": "application/json",
                "Cache-Control": "no-cache",
            },
        )

        return context
</file>

<file path="app/processors/claude_ai/tool_call_event_processor.py">
from typing import AsyncIterator, Optional
from loguru import logger

from app.processors.base import BaseProcessor
from app.processors.claude_ai import ClaudeAIContext
from app.models.streaming import (
    StreamingEvent,
    ContentBlockStartEvent,
    ContentBlockStopEvent,
    MessageDeltaEvent,
    MessageStopEvent,
    MessageDeltaData,
)
from app.models.claude import ToolResultContent, ToolUseContent
from app.services.tool_call import tool_call_manager


class ToolCallEventProcessor(BaseProcessor):
    """Processor that handles tool use events in the streaming response."""

    async def process(self, context: ClaudeAIContext) -> ClaudeAIContext:
        """
        Intercept tool use content blocks and inject MessageDelta/MessageStop events.

        Requires:
            - event_stream in context
            - cladue_session in context

        Produces:
            - Modified event_stream with injected events for tool calls
            - Pauses session when tool call is detected
        """
        if not context.event_stream:
            logger.warning(
                "Skipping ToolCallEventProcessor due to missing event_stream"
            )
            return context

        if not context.claude_session:
            logger.warning("Skipping ToolCallEventProcessor due to missing session")
            return context

        logger.debug("Setting up tool call event processing")

        original_stream = context.event_stream
        new_stream = self._process_tool_events(original_stream, context)
        context.event_stream = new_stream

        return context

    async def _process_tool_events(
        self,
        event_stream: AsyncIterator[StreamingEvent],
        context: ClaudeAIContext,
    ) -> AsyncIterator[StreamingEvent]:
        """
        Process events and inject MessageDelta/MessageStop when tool use is detected.
        """
        current_tool_use_id: Optional[str] = None
        tool_use_detected = False
        content_block_index: Optional[int] = None
        tool_result_detected = False

        async for event in event_stream:
            # Check for ContentBlockStartEvent with tool_use type
            if isinstance(event.root, ContentBlockStartEvent):
                if isinstance(event.root.content_block, ToolUseContent):
                    current_tool_use_id = event.root.content_block.id
                    content_block_index = event.root.index
                    tool_use_detected = True
                    logger.debug(
                        f"Detected tool use start: {current_tool_use_id} "
                        f"(name: {event.root.content_block.name})"
                    )
                elif isinstance(event.root.content_block, ToolResultContent):
                    logger.debug(
                        f"Detected tool result: {event.root.content_block.tool_use_id}"
                    )
                    tool_result_detected = True

            # Yield the original event
            if tool_result_detected:
                logger.debug("Skipping tool result content block")
            else:
                yield event

            # Check for ContentBlockStopEvent for a tool use block
            if isinstance(event.root, ContentBlockStopEvent):
                if tool_result_detected:
                    logger.debug("Tool result block ended")
                    tool_result_detected = False
                if (
                    tool_use_detected
                    and content_block_index is not None
                    and event.root.index == content_block_index
                ):
                    logger.debug(f"Tool use block ended: {current_tool_use_id}")

                    message_delta = MessageDeltaEvent(
                        type="message_delta",
                        delta=MessageDeltaData(stop_reason="tool_use"),
                        usage=None,
                    )
                    yield StreamingEvent(root=message_delta)

                    message_stop = MessageStopEvent(type="message_stop")
                    yield StreamingEvent(root=message_stop)

                    # Register the tool call
                    if current_tool_use_id and context.claude_session:
                        tool_call_manager.register_tool_call(
                            tool_use_id=current_tool_use_id,
                            session_id=context.claude_session.session_id,
                            message_id=context.collected_message.id
                            if context.collected_message
                            else None,
                        )

                        logger.info(
                            f"Registered tool call {current_tool_use_id} for session {context.claude_session.session_id}"
                        )

                    current_tool_use_id = None
                    tool_use_detected = False
                    content_block_index = None

                    break
</file>

<file path="app/processors/claude_ai/tool_result_processor.py">
import uuid
from loguru import logger

from app.processors.base import BaseProcessor
from app.processors.claude_ai import ClaudeAIContext
from app.models.claude import TextContent, ToolResultContent
from app.models.streaming import MessageStartEvent, StreamingEvent
from app.services.tool_call import tool_call_manager
from app.services.session import session_manager
from app.services.event_processing import EventSerializer

event_serializer = EventSerializer()


class ToolResultProcessor(BaseProcessor):
    """Processor that handles tool result messages and resumes paused sessions."""

    async def process(self, context: ClaudeAIContext) -> ClaudeAIContext:
        """
        Check if the last message is a tool result and handle accordingly.

        Requires:
            - messages_api_request in context

        Produces:
            - Resumes paused session if tool result matches
            - Sets event_stream from resumed session
            - Skips normal request building/sending
        """
        if not context.messages_api_request:
            logger.warning(
                "Skipping ToolResultProcessor due to missing messages_api_request"
            )
            return context

        messages = context.messages_api_request.messages
        if not messages:
            return context

        last_message = messages[-1]

        if last_message.role != "user":
            return context

        if isinstance(last_message.content, str):
            return context

        # Find tool result content block
        lsat_content_block = last_message.content[-1]
        if not isinstance(lsat_content_block, ToolResultContent):
            return context

        tool_result = lsat_content_block

        logger.debug(f"Found tool result for tool_use_id: {tool_result.tool_use_id}")

        # Check if we have a pending tool call for this ID
        tool_call_state = tool_call_manager.get_tool_call(tool_result.tool_use_id)
        if not tool_call_state:
            logger.debug(
                f"No pending tool call found for tool_use_id: {tool_result.tool_use_id}"
            )
            return context

        # Get the session
        session = await session_manager.get_session(tool_call_state.session_id)
        if not session:
            logger.error(
                f"Session {tool_call_state.session_id} not found for tool call {tool_result.tool_use_id}"
            )
            tool_call_manager.complete_tool_call(tool_result.tool_use_id)
            return context

        if isinstance(tool_result.content, str):
            tool_result.content = [TextContent(type="text", text=tool_result.content)]
        tool_result_payload = tool_result.model_dump()

        await session.send_tool_result(tool_result_payload)
        logger.info(
            f"Sent tool result for {tool_result.tool_use_id} to session {session.session_id}"
        )

        if not session.sse_stream:
            logger.error(f"No stream available for session {session.session_id}")
            tool_call_manager.complete_tool_call(tool_result.tool_use_id)
            return context

        # Continue with the existing stream
        resumed_stream = session.sse_stream

        message_start_event = MessageStartEvent(
            type="message_start",
            message=context.collected_message
            if context.collected_message
            else {
                "id": tool_call_state.message_id or str(uuid.uuid4()),
                "type": "message",
                "role": "assistant",
                "content": [],
                "model": context.messages_api_request.model,
            },
        )

        # Create a generator that yields the message start event followed by the resumed stream
        async def resumed_event_stream():
            yield event_serializer.serialize_event(
                StreamingEvent(root=message_start_event)
            )
            async for event in resumed_stream:
                yield event

        context.original_stream = resumed_event_stream()
        context.claude_session = session

        tool_call_manager.complete_tool_call(tool_result.tool_use_id)

        # Skip the normal Claude AI processor
        context.metadata["skip_processors"] = [
            "ClaudeAPIProcessor",
            "ClaudeWebProcessor",
        ]

        return context
</file>

<file path="app/processors/pipeline.py">
from typing import List, Optional
from loguru import logger

from app.processors.base import BaseContext, BaseProcessor


class ProcessingPipeline(BaseProcessor):
    """
    Main pipeline for processing Claude requests.
    """

    def __init__(self, processors: Optional[List[BaseProcessor]] = None):
        """
        Initialize the pipeline with processors.

        Args:
            processors: List of processors to use. If None, default processors are used.
        """
        self.processors = processors

        logger.debug(f"Initialized pipeline with {len(self.processors)} processors")
        for processor in self.processors:
            logger.debug(f"  - {processor.name}")

    async def process(self, context: BaseContext) -> BaseContext:
        """
        Process a request through the pipeline.

        Args:
            context: The processing context

        Returns:
            Updated context.
        """

        logger.debug("Starting pipeline processing")

        # Process through each processor
        for i, processor in enumerate(self.processors):
            if processor.name in context.metadata.get("skip_processors", []):
                logger.debug(
                    f"Skipping processor {processor.name} due to being in skip_processors list"
                )
                continue

            logger.debug(
                f"Running processor {i + 1}/{len(self.processors)}: {processor.name}"
            )

            context = await processor.process(context)

            if context.metadata.get("stop_pipeline", False):
                logger.debug(f"Pipeline stopped by {processor.name}")
                break

        logger.debug("Pipeline processing completed successfully")
        return context
</file>

<file path="app/services/__init__.py">

</file>

<file path="app/services/event_processing/__init__.py">
from .event_parser import EventParser
from .event_serializer import EventSerializer

__all__ = [
    "EventParser",
    "EventSerializer",
]
</file>

<file path="app/services/event_processing/event_serializer.py">
import json
from typing import AsyncIterator, Optional

from app.models.streaming import StreamingEvent, UnknownEvent


class EventSerializer:
    """Serializes StreamingEvent objects into SSE (Server-Sent Events) format."""

    def __init__(self, skip_unknown_events: bool = True):
        self.skip_unknown_events = skip_unknown_events

    async def serialize_stream(
        self, events: AsyncIterator[StreamingEvent]
    ) -> AsyncIterator[str]:
        """
        Serialize a stream of StreamingEvent objects into SSE format.

        Args:
            events: AsyncIterator that yields StreamingEvent objects

        Yields:
            String chunks in SSE format
        """
        async for event in events:
            sse_message = self.serialize_event(event)
            if sse_message:
                yield sse_message

    def serialize_event(self, event: StreamingEvent) -> Optional[str]:
        """
        Serialize a single StreamingEvent into SSE format.

        Args:
            event: StreamingEvent object to serialize

        Returns:
            SSE formatted string or None if serialization fails
        """
        if isinstance(event.root, UnknownEvent):
            if self.skip_unknown_events:
                return None
            json_data = json.dumps(
                event.root.data, ensure_ascii=False, separators=(",", ":")
            )
        else:
            json_data = event.model_dump_json(exclude_none=True)

        sse_parts = []

        if event.root.type:
            sse_parts.append(f"event: {event.root.type}")

        data_lines = json_data.split("\n")
        for line in data_lines:
            sse_parts.append(f"data: {line}")

        sse_message = "\n".join(sse_parts) + "\n\n"

        return sse_message

    async def serialize_batch(self, events: list[StreamingEvent]) -> str:
        """
        Serialize a batch of StreamingEvent objects into a single SSE string.

        Args:
            events: List of StreamingEvent objects to serialize

        Returns:
            Concatenated SSE formatted string
        """
        result_parts = []

        for event in events:
            sse_message = self.serialize_event(event)
            if sse_message:
                result_parts.append(sse_message)

        return "".join(result_parts)
</file>

<file path="app/services/tool_call.py">
import asyncio
from typing import Dict, Optional
from datetime import datetime, timedelta
import threading
from loguru import logger

from app.core.config import settings


class ToolCallState:
    """State for a pending tool call."""

    def __init__(self, tool_use_id: str, session_id: str):
        self.tool_use_id = tool_use_id
        self.session_id = session_id
        self.created_at = datetime.now()
        self.message_id: Optional[str] = None


class ToolCallManager:
    """
    Singleton manager for tool call states.
    """

    _instance: Optional["ToolCallManager"] = None
    _lock = threading.Lock()

    def __new__(cls):
        """Implement singleton pattern."""
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self):
        """Initialize the ToolCallManager."""
        self._tool_calls: Dict[str, ToolCallState] = {}
        self._cleanup_task: Optional[asyncio.Task] = None
        self._tool_call_timeout = settings.tool_call_timeout
        self._cleanup_interval = settings.tool_call_cleanup_interval

        logger.info(
            f"ToolCallManager initialized with timeout={self._tool_call_timeout}s, "
            f"cleanup_interval={self._cleanup_interval}s"
        )

    def register_tool_call(
        self, tool_use_id: str, session_id: str, message_id: Optional[str] = None
    ) -> None:
        """
        Register a new tool call.

        Args:
            tool_use_id: Unique identifier for the tool use
            session_id: Session ID associated with this tool call
            message_id: Optional message ID for tracking
        """
        tool_call_state = ToolCallState(tool_use_id, session_id)
        tool_call_state.message_id = message_id

        self._tool_calls[tool_use_id] = tool_call_state

        logger.info(f"Registered tool call: {tool_use_id} for session: {session_id}")

    def get_tool_call(self, tool_use_id: str) -> Optional[ToolCallState]:
        """
        Get a tool call state by ID.

        Args:
            tool_use_id: Tool use ID to lookup

        Returns:
            ToolCallState if found, None otherwise
        """
        return self._tool_calls.get(tool_use_id)

    def complete_tool_call(self, tool_use_id: str) -> None:
        """
        Mark a tool call as completed and return the associated session ID.

        Args:
            tool_use_id: Tool use ID to complete
        """
        tool_call = self._tool_calls.get(tool_use_id)
        if tool_call:
            del self._tool_calls[tool_use_id]

        logger.info(f"Completed tool call: {tool_use_id}")

    async def start_cleanup_task(self) -> None:
        """Start the background task for cleaning up expired tool calls."""
        if self._cleanup_task is None or self._cleanup_task.done():
            self._cleanup_task = asyncio.create_task(self._cleanup_loop())
            logger.info("Started tool call cleanup task")

    async def stop_cleanup_task(self) -> None:
        """Stop the background cleanup task."""
        if self._cleanup_task and not self._cleanup_task.done():
            self._cleanup_task.cancel()
            try:
                await self._cleanup_task
            except asyncio.CancelledError:
                pass
            logger.info("Stopped tool call cleanup task")

    async def _cleanup_loop(self) -> None:
        """Background loop to clean up expired tool calls."""
        while True:
            try:
                self._cleanup_expired_tool_calls()
                await asyncio.sleep(self._cleanup_interval)
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Error in tool call cleanup loop: {e}")
                await asyncio.sleep(self._cleanup_interval)

    def _cleanup_expired_tool_calls(self) -> None:
        """Clean up all expired tool calls."""
        current_time = datetime.now()
        timeout_duration = timedelta(seconds=self._tool_call_timeout)
        expired_tool_calls = []

        for tool_use_id, tool_call in self._tool_calls.items():
            if (current_time - tool_call.created_at) > timeout_duration:
                expired_tool_calls.append(tool_use_id)

        for tool_use_id in expired_tool_calls:
            tool_call = self._tool_calls[tool_use_id]
            del self._tool_calls[tool_use_id]

        if expired_tool_calls:
            logger.info(f"Cleaned up {len(expired_tool_calls)} expired tool calls")

    async def cleanup_all(self) -> None:
        """Clean up all tool calls and stop the cleanup task."""
        await self.stop_cleanup_task()
        self._tool_calls.clear()
        logger.info("Cleaned up all tool calls")

    def __repr__(self) -> str:
        """String representation of the ToolCallManager."""
        return f"<ToolCallManager tool_calls={len(self._tool_calls)}>"


tool_call_manager = ToolCallManager()
</file>

<file path="app/utils/__init__.py">

</file>

<file path="front/.gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="front/components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/index.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="front/eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { globalIgnores } from 'eslint/config'

export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])
</file>

<file path="front/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Clove</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="front/prettier.config.cjs">
module.exports = {
    arrowParens: 'avoid',
    bracketSameLine: false,
    bracketSpacing: true,
    semi: false,
    experimentalTernaries: false,
    singleQuote: true,
    jsxSingleQuote: true,
    quoteProps: 'as-needed',
    trailingComma: 'all',
    singleAttributePerLine: false,
    htmlWhitespaceSensitivity: 'css',
    vueIndentScriptAndStyle: false,
    proseWrap: 'preserve',
    insertPragma: false,
    printWidth: 128,
    requirePragma: false,
    tabWidth: 4,
    useTabs: false,
    embeddedLanguageFormatting: 'auto',
    cursorOffset: -1,
}
</file>

<file path="front/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="front/README.md">
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...

      // Remove tseslint.configs.recommended and replace with this
      ...tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      ...tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      ...tseslint.configs.stylisticTypeChecked,

      // Other configs...
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Enable lint rules for React
      reactX.configs['recommended-typescript'],
      // Enable lint rules for React DOM
      reactDom.configs.recommended,
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```
</file>

<file path="front/src/App.tsx">
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom'
import { Layout } from './components/Layout'
import { Login } from './pages/Login'
import { Dashboard } from './pages/Dashboard'
import { Accounts } from './pages/Accounts'
import { Settings } from './pages/Settings'
import { Toaster } from './components/ui/sonner'

function ProtectedRoute({ children }: { children: React.ReactNode }) {
    const adminKey = localStorage.getItem('adminKey')
    if (!adminKey) {
        return <Navigate to='/login' replace />
    }
    return <>{children}</>
}

function App() {
    return (
        <BrowserRouter>
            <Routes>
                <Route path='/login' element={<Login />} />
                <Route
                    path='/'
                    element={
                        <ProtectedRoute>
                            <Layout />
                        </ProtectedRoute>
                    }
                >
                    <Route index element={<Dashboard />} />
                    <Route path='accounts' element={<Accounts />} />
                    <Route path='settings' element={<Settings />} />
                </Route>
            </Routes>
            <Toaster />
        </BrowserRouter>
    )
}

export default App
</file>

<file path="front/src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="front/src/components/ui/alert-dialog.tsx">
import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  )
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  )
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  )
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  )
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  )
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}
</file>

<file path="front/src/components/ui/alert.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current",
  {
    variants: {
      variant: {
        default: "bg-card text-card-foreground",
        destructive:
          "text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Alert({
  className,
  variant,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof alertVariants>) {
  return (
    <div
      data-slot="alert"
      role="alert"
      className={cn(alertVariants({ variant }), className)}
      {...props}
    />
  )
}

function AlertTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-title"
      className={cn(
        "col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight",
        className
      )}
      {...props}
    />
  )
}

function AlertDescription({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-description"
      className={cn(
        "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed",
        className
      )}
      {...props}
    />
  )
}

export { Alert, AlertTitle, AlertDescription }
</file>

<file path="front/src/components/ui/badge.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span"

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }
</file>

<file path="front/src/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }
</file>

<file path="front/src/components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}
</file>

<file path="front/src/components/ui/collapsible.tsx">
import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

function Collapsible({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.Root>) {
  return <CollapsiblePrimitive.Root data-slot="collapsible" {...props} />
}

function CollapsibleTrigger({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleTrigger>) {
  return (
    <CollapsiblePrimitive.CollapsibleTrigger
      data-slot="collapsible-trigger"
      {...props}
    />
  )
}

function CollapsibleContent({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleContent>) {
  return (
    <CollapsiblePrimitive.CollapsibleContent
      data-slot="collapsible-content"
      {...props}
    />
  )
}

export { Collapsible, CollapsibleTrigger, CollapsibleContent }
</file>

<file path="front/src/components/ui/dialog.tsx">
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}
</file>

<file path="front/src/components/ui/drawer.tsx">
import * as React from "react"
import { Drawer as DrawerPrimitive } from "vaul"

import { cn } from "@/lib/utils"

function Drawer({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) {
  return <DrawerPrimitive.Root data-slot="drawer" {...props} />
}

function DrawerTrigger({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Trigger>) {
  return <DrawerPrimitive.Trigger data-slot="drawer-trigger" {...props} />
}

function DrawerPortal({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Portal>) {
  return <DrawerPrimitive.Portal data-slot="drawer-portal" {...props} />
}

function DrawerClose({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Close>) {
  return <DrawerPrimitive.Close data-slot="drawer-close" {...props} />
}

function DrawerOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Overlay>) {
  return (
    <DrawerPrimitive.Overlay
      data-slot="drawer-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DrawerContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Content>) {
  return (
    <DrawerPortal data-slot="drawer-portal">
      <DrawerOverlay />
      <DrawerPrimitive.Content
        data-slot="drawer-content"
        className={cn(
          "group/drawer-content bg-background fixed z-50 flex h-auto flex-col",
          "data-[vaul-drawer-direction=top]:inset-x-0 data-[vaul-drawer-direction=top]:top-0 data-[vaul-drawer-direction=top]:mb-24 data-[vaul-drawer-direction=top]:max-h-[80vh] data-[vaul-drawer-direction=top]:rounded-b-lg data-[vaul-drawer-direction=top]:border-b",
          "data-[vaul-drawer-direction=bottom]:inset-x-0 data-[vaul-drawer-direction=bottom]:bottom-0 data-[vaul-drawer-direction=bottom]:mt-24 data-[vaul-drawer-direction=bottom]:max-h-[80vh] data-[vaul-drawer-direction=bottom]:rounded-t-lg data-[vaul-drawer-direction=bottom]:border-t",
          "data-[vaul-drawer-direction=right]:inset-y-0 data-[vaul-drawer-direction=right]:right-0 data-[vaul-drawer-direction=right]:w-3/4 data-[vaul-drawer-direction=right]:border-l data-[vaul-drawer-direction=right]:sm:max-w-sm",
          "data-[vaul-drawer-direction=left]:inset-y-0 data-[vaul-drawer-direction=left]:left-0 data-[vaul-drawer-direction=left]:w-3/4 data-[vaul-drawer-direction=left]:border-r data-[vaul-drawer-direction=left]:sm:max-w-sm",
          className
        )}
        {...props}
      >
        <div className="bg-muted mx-auto mt-4 hidden h-2 w-[100px] shrink-0 rounded-full group-data-[vaul-drawer-direction=bottom]/drawer-content:block" />
        {children}
      </DrawerPrimitive.Content>
    </DrawerPortal>
  )
}

function DrawerHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="drawer-header"
      className={cn(
        "flex flex-col gap-0.5 p-4 group-data-[vaul-drawer-direction=bottom]/drawer-content:text-center group-data-[vaul-drawer-direction=top]/drawer-content:text-center md:gap-1.5 md:text-left",
        className
      )}
      {...props}
    />
  )
}

function DrawerFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="drawer-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function DrawerTitle({
  className,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Title>) {
  return (
    <DrawerPrimitive.Title
      data-slot="drawer-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function DrawerDescription({
  className,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Description>) {
  return (
    <DrawerPrimitive.Description
      data-slot="drawer-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}
</file>

<file path="front/src/components/ui/dropdown-menu.tsx">
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}
</file>

<file path="front/src/components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }
</file>

<file path="front/src/components/ui/label.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }
</file>

<file path="front/src/components/ui/progress.tsx">
import * as React from 'react'
import * as ProgressPrimitive from '@radix-ui/react-progress'

import { cn } from '@/lib/utils'

function Progress({ className, value, ...props }: React.ComponentProps<typeof ProgressPrimitive.Root>) {
    return (
        <ProgressPrimitive.Root
            data-slot='progress'
            className={cn('bg-primary/20 relative h-2 w-full overflow-hidden rounded-full', className)}
            {...props}
        >
            <ProgressPrimitive.Indicator
                data-slot='progress-indicator'
                className='bg-primary h-full w-full flex-1 transition-all'
                style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
            />
        </ProgressPrimitive.Root>
    )
}

export { Progress }
</file>

<file path="front/src/components/ui/select.tsx">
import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}
</file>

<file path="front/src/components/ui/separator.tsx">
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }
</file>

<file path="front/src/components/ui/sheet.tsx">
import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />
}

function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
}

function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />
}

function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
}

function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function SheetContent({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left"
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
          side === "right" &&
            "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
          side === "left" &&
            "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          side === "top" &&
            "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
          side === "bottom" &&
            "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  )
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}
</file>

<file path="front/src/components/ui/sidebar.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
import { PanelLeftIcon } from "lucide-react"

import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar_state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContextProps = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContextProps | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

function SidebarProvider({
  defaultOpen = true,
  open: openProp,
  onOpenChange: setOpenProp,
  className,
  style,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  defaultOpen?: boolean
  open?: boolean
  onOpenChange?: (open: boolean) => void
}) {
  const isMobile = useIsMobile()
  const [openMobile, setOpenMobile] = React.useState(false)

  // This is the internal state of the sidebar.
  // We use openProp and setOpenProp for control from outside the component.
  const [_open, _setOpen] = React.useState(defaultOpen)
  const open = openProp ?? _open
  const setOpen = React.useCallback(
    (value: boolean | ((value: boolean) => boolean)) => {
      const openState = typeof value === "function" ? value(open) : value
      if (setOpenProp) {
        setOpenProp(openState)
      } else {
        _setOpen(openState)
      }

      // This sets the cookie to keep the sidebar state.
      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
    },
    [setOpenProp, open]
  )

  // Helper to toggle the sidebar.
  const toggleSidebar = React.useCallback(() => {
    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open)
  }, [isMobile, setOpen, setOpenMobile])

  // Adds a keyboard shortcut to toggle the sidebar.
  React.useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (
        event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
        (event.metaKey || event.ctrlKey)
      ) {
        event.preventDefault()
        toggleSidebar()
      }
    }

    window.addEventListener("keydown", handleKeyDown)
    return () => window.removeEventListener("keydown", handleKeyDown)
  }, [toggleSidebar])

  // We add a state so that we can do data-state="expanded" or "collapsed".
  // This makes it easier to style the sidebar with Tailwind classes.
  const state = open ? "expanded" : "collapsed"

  const contextValue = React.useMemo<SidebarContextProps>(
    () => ({
      state,
      open,
      setOpen,
      isMobile: !!isMobile,
      openMobile,
      setOpenMobile,
      toggleSidebar,
    }),
    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
  )

  return (
    <SidebarContext.Provider value={contextValue}>
      <TooltipProvider delayDuration={0}>
        <div
          data-slot="sidebar-wrapper"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH,
              "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
              ...style,
            } as React.CSSProperties
          }
          className={cn(
            "group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full",
            className
          )}
          {...props}
        >
          {children}
        </div>
      </TooltipProvider>
    </SidebarContext.Provider>
  )
}

function Sidebar({
  side = "left",
  variant = "sidebar",
  collapsible = "offcanvas",
  className,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  side?: "left" | "right"
  variant?: "sidebar" | "floating" | "inset"
  collapsible?: "offcanvas" | "icon" | "none"
}) {
  const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

  if (collapsible === "none") {
    return (
      <div
        data-slot="sidebar"
        className={cn(
          "bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col",
          className
        )}
        {...props}
      >
        {children}
      </div>
    )
  }

  if (isMobile) {
    return (
      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
        <SheetContent
          data-sidebar="sidebar"
          data-slot="sidebar"
          data-mobile="true"
          className="bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
            } as React.CSSProperties
          }
          side={side}
        >
          <SheetHeader className="sr-only">
            <SheetTitle>Sidebar</SheetTitle>
            <SheetDescription>Displays the mobile sidebar.</SheetDescription>
          </SheetHeader>
          <div className="flex h-full w-full flex-col">{children}</div>
        </SheetContent>
      </Sheet>
    )
  }

  return (
    <div
      className="group peer text-sidebar-foreground hidden md:block"
      data-state={state}
      data-collapsible={state === "collapsed" ? collapsible : ""}
      data-variant={variant}
      data-side={side}
      data-slot="sidebar"
    >
      {/* This is what handles the sidebar gap on desktop */}
      <div
        data-slot="sidebar-gap"
        className={cn(
          "relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear",
          "group-data-[collapsible=offcanvas]:w-0",
          "group-data-[side=right]:rotate-180",
          variant === "floating" || variant === "inset"
            ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon)"
        )}
      />
      <div
        data-slot="sidebar-container"
        className={cn(
          "fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex",
          side === "left"
            ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
            : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
          // Adjust the padding for floating and inset variants.
          variant === "floating" || variant === "inset"
            ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l",
          className
        )}
        {...props}
      >
        <div
          data-sidebar="sidebar"
          data-slot="sidebar-inner"
          className="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"
        >
          {children}
        </div>
      </div>
    </div>
  )
}

function SidebarTrigger({
  className,
  onClick,
  ...props
}: React.ComponentProps<typeof Button>) {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      data-sidebar="trigger"
      data-slot="sidebar-trigger"
      variant="ghost"
      size="icon"
      className={cn("size-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeftIcon />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
}

function SidebarRail({ className, ...props }: React.ComponentProps<"button">) {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      data-sidebar="rail"
      data-slot="sidebar-rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex",
        "in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
}

function SidebarInset({ className, ...props }: React.ComponentProps<"main">) {
  return (
    <main
      data-slot="sidebar-inset"
      className={cn(
        "bg-background relative flex w-full flex-1 flex-col",
        "md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2",
        className
      )}
      {...props}
    />
  )
}

function SidebarInput({
  className,
  ...props
}: React.ComponentProps<typeof Input>) {
  return (
    <Input
      data-slot="sidebar-input"
      data-sidebar="input"
      className={cn("bg-background h-8 w-full shadow-none", className)}
      {...props}
    />
  )
}

function SidebarHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-header"
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
}

function SidebarFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-footer"
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
}

function SidebarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof Separator>) {
  return (
    <Separator
      data-slot="sidebar-separator"
      data-sidebar="separator"
      className={cn("bg-sidebar-border mx-2 w-auto", className)}
      {...props}
    />
  )
}

function SidebarContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-content"
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroup({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group"
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
}

function SidebarGroupLabel({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"div"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      data-slot="sidebar-group-label"
      data-sidebar="group-label"
      className={cn(
        "text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroupAction({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="sidebar-group-action"
      data-sidebar="group-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroupContent({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group-content"
      data-sidebar="group-content"
      className={cn("w-full text-sm", className)}
      {...props}
    />
  )
}

function SidebarMenu({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu"
      data-sidebar="menu"
      className={cn("flex w-full min-w-0 flex-col gap-1", className)}
      {...props}
    />
  )
}

function SidebarMenuItem({ className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-item"
      data-sidebar="menu-item"
      className={cn("group/menu-item relative", className)}
      {...props}
    />
  )
}

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:p-0!",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function SidebarMenuButton({
  asChild = false,
  isActive = false,
  variant = "default",
  size = "default",
  tooltip,
  className,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean
  isActive?: boolean
  tooltip?: string | React.ComponentProps<typeof TooltipContent>
} & VariantProps<typeof sidebarMenuButtonVariants>) {
  const Comp = asChild ? Slot : "button"
  const { isMobile, state } = useSidebar()

  const button = (
    <Comp
      data-slot="sidebar-menu-button"
      data-sidebar="menu-button"
      data-size={size}
      data-active={isActive}
      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
      {...props}
    />
  )

  if (!tooltip) {
    return button
  }

  if (typeof tooltip === "string") {
    tooltip = {
      children: tooltip,
    }
  }

  return (
    <Tooltip>
      <TooltipTrigger asChild>{button}</TooltipTrigger>
      <TooltipContent
        side="right"
        align="center"
        hidden={state !== "collapsed" || isMobile}
        {...tooltip}
      />
    </Tooltip>
  )
}

function SidebarMenuAction({
  className,
  asChild = false,
  showOnHover = false,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean
  showOnHover?: boolean
}) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="sidebar-menu-action"
      data-sidebar="menu-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuBadge({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-menu-badge"
      data-sidebar="menu-badge"
      className={cn(
        "text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none",
        "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuSkeleton({
  className,
  showIcon = false,
  ...props
}: React.ComponentProps<"div"> & {
  showIcon?: boolean
}) {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      data-slot="sidebar-menu-skeleton"
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-(--skeleton-width) flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
}

function SidebarMenuSub({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu-sub"
      data-sidebar="menu-sub"
      className={cn(
        "border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuSubItem({
  className,
  ...props
}: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-sub-item"
      data-sidebar="menu-sub-item"
      className={cn("group/menu-sub-item relative", className)}
      {...props}
    />
  )
}

function SidebarMenuSubButton({
  asChild = false,
  size = "md",
  isActive = false,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean
  size?: "sm" | "md"
  isActive?: boolean
}) {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      data-slot="sidebar-menu-sub-button"
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline-hidden focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}
</file>

<file path="front/src/components/ui/skeleton.tsx">
import { cn } from "@/lib/utils"

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-accent animate-pulse rounded-md", className)}
      {...props}
    />
  )
}

export { Skeleton }
</file>

<file path="front/src/components/ui/sonner.tsx">
import { useTheme } from "next-themes"
import { Toaster as Sonner, type ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }
</file>

<file path="front/src/components/ui/switch.tsx">
import * as React from "react"
import * as SwitchPrimitive from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

function Switch({
  className,
  ...props
}: React.ComponentProps<typeof SwitchPrimitive.Root>) {
  return (
    <SwitchPrimitive.Root
      data-slot="switch"
      className={cn(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <SwitchPrimitive.Thumb
        data-slot="switch-thumb"
        className={cn(
          "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
        )}
      />
    </SwitchPrimitive.Root>
  )
}

export { Switch }
</file>

<file path="front/src/components/ui/table.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Table({ className, ...props }: React.ComponentProps<"table">) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn("w-full caption-bottom text-sm", className)}
        {...props}
      />
    </div>
  )
}

function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
  return (
    <thead
      data-slot="table-header"
      className={cn("[&_tr]:border-b", className)}
      {...props}
    />
  )
}

function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
  return (
    <tbody
      data-slot="table-body"
      className={cn("[&_tr:last-child]:border-0", className)}
      {...props}
    />
  )
}

function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0",
        className
      )}
      {...props}
    />
  )
}

function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        className
      )}
      {...props}
    />
  )
}

function TableHead({ className, ...props }: React.ComponentProps<"th">) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        "text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCell({ className, ...props }: React.ComponentProps<"td">) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCaption({
  className,
  ...props
}: React.ComponentProps<"caption">) {
  return (
    <caption
      data-slot="table-caption"
      className={cn("text-muted-foreground mt-4 text-sm", className)}
      {...props}
    />
  )
}

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
</file>

<file path="front/src/components/ui/textarea.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }
</file>

<file path="front/src/components/ui/tooltip.tsx">
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  )
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  )
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
</file>

<file path="front/src/hooks/use-mobile.ts">
import * as React from 'react'

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
    const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

    React.useEffect(() => {
        const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
        const onChange = () => {
            setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
        }
        mql.addEventListener('change', onChange)
        setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
        return () => mql.removeEventListener('change', onChange)
    }, [])

    return isMobile
}
</file>

<file path="front/src/i18n/i18n-config.ts">
import i18n from 'i18next'
import { initReactI18next } from 'react-i18next'
import LanguageDetector from 'i18next-browser-languagedetector'
import en from './locales/en.json'
import zh from './locales/zh.json'

i18n
  .use(LanguageDetector)
  .use(initReactI18next)
  .init({
    resources: {
      en: { translation: en },
      zh: { translation: zh },
    },
    fallbackLng: 'en',
    interpolation: { escapeValue: false },
    detection: {
      order: ['localStorage', 'navigator'],
      lookupLocalStorage: 'i18nLanguage',
      caches: ['localStorage'],
    },
  })

i18n.on('languageChanged', (lng) => {
  document.documentElement.setAttribute('lang', lng)
})

export default i18n
</file>

<file path="front/src/i18n/locales/en.json">
{
  "common": {
    "cancel": "Cancel",
    "delete": "Delete",
    "save": "Save",
    "saving": "Saving...",
    "edit": "Edit",
    "add": "Add",
    "done": "Done",
    "processing": "Processing...",
    "copyFailed": "Copy failed",
    "unknownError": "An unknown error occurred"
  },
  "login": {
    "welcomeBack": "Welcome Back",
    "subtitle": "Enter your Admin Key to access the admin panel",
    "placeholder": "Enter your admin key",
    "verifying": "Verifying...",
    "signIn": "Sign In",
    "invalidKey": "Invalid Admin Key or server connection failed",
    "footer": "Clove - A full-powered Claude reverse proxy!"
  },
  "dashboard": {
    "title": "Dashboard",
    "welcome": "Welcome to Clove!",
    "totalAccounts": "Total Accounts",
    "serverStatus": "Server Status",
    "online": "Online",
    "offline": "Offline",
    "activeSessions": "Active Sessions",
    "systemStatus": "System Status",
    "normal": "Normal",
    "degraded": "Degraded",
    "quickActions": "Quick Actions",
    "manageAccounts": "Manage Accounts",
    "manageAccountsDesc": "Add, edit, or delete Claude accounts",
    "goToAccounts": "Go to Accounts",
    "systemSettings": "System Settings",
    "systemSettingsDesc": "Configure application parameters",
    "goToSettings": "Go to Settings"
  },
  "accounts": {
    "title": "Account Management",
    "subtitle": "Manage your Claude accounts",
    "oauthLogin": "OAuth Login",
    "batchAdd": "Batch Add",
    "addCookie": "Add Cookie",
    "noAccounts": "No Accounts",
    "noAccountsDesc": "Click \"Add Cookie\" or \"OAuth Login\" to create your first account",
    "deleteFailed": "Failed to delete account",
    "deleteConfirmTitle": "Are you sure you want to delete this account?",
    "deleteConfirmDesc": "This action cannot be undone. The account will be removed from Clove, but your data on Claude.ai will not be affected.",
    "authMethod": "Auth Method",
    "status": "Status",
    "accountType": "Account Type",
    "lastUsed": "Last Used",
    "resetTime": "Reset Time",
    "actions": "Actions",
    "openMenu": "Open menu",
    "statusValid": "Valid",
    "statusInvalid": "Invalid",
    "statusRateLimited": "Rate Limited"
  },
  "settings": {
    "title": "Settings",
    "subtitle": "Manage your application configuration and keys",
    "saved": "Saved",
    "saveFailed": "Save failed",
    "apiKeys": "API Keys",
    "apiKeysDesc": "Manage your API access keys",
    "noApiKeys": "No API keys yet. Please add your first key.",
    "hideKey": "Hide key",
    "showKey": "Show key",
    "copyKey": "Copy key",
    "keyCopied": "Key copied to clipboard",
    "copyKeyFailed": "Copy failed, please copy manually",
    "deleteKeyTitle": "Delete this key?",
    "deleteApiKeyDesc": "This action cannot be undone. Applications using this key will lose API access.",
    "addNewApiKey": "Add New API Key",
    "enterOrGenerateKey": "Enter or generate a new key",
    "generateKey": "Generate new key",
    "adminKeys": "Admin Keys",
    "adminKeysDesc": "Manage your admin access keys",
    "noAdminKeys": "No admin keys yet. Please add your first key.",
    "deleteAdminKeyDesc": "This action cannot be undone. You will no longer be able to access the admin panel with this key.",
    "addNewAdminKey": "Add New Admin Key",
    "claudeConfig": "Claude Configuration",
    "claudeConfigDesc": "Configure Claude AI settings",
    "proxyUrl": "Proxy URL (optional)",
    "proxyUrlPlaceholder": "Leave empty to disable proxy",
    "formatSettings": "Format Settings",
    "formatSettingsDesc": "Customize context format",
    "customPrompt": "Custom Prompt (optional)",
    "customPromptPlaceholder": "Enter a custom system prompt...",
    "humanName": "User Name",
    "assistantName": "Assistant Name",
    "paddingLength": "Padding Length",
    "useRealRoles": "Use Real Roles",
    "useRealRolesDesc": "Enable to use real role prefixes",
    "allowExternalImages": "Allow External Images",
    "allowExternalImagesDesc": "Allow the reverse proxy to load external images",
    "preserveChats": "Preserve Chats",
    "preserveChatsDesc": "Keep chat history for later viewing"
  },
  "layout": {
    "dashboard": "Dashboard",
    "accounts": "Account Management",
    "settings": "Settings",
    "logout": "Logout"
  },
  "accountModal": {
    "titleAdd": "Add Cookie",
    "titleEdit": "Edit Account",
    "descAdd": "Add a new Claude account cookie",
    "descEdit": "Update account authentication info",
    "cookiePlaceholder": "Paste your Claude Cookie...",
    "advancedOptions": "Advanced Options",
    "orgUuidPlaceholder": "Leave empty for auto-detection",
    "invalidUuid": "Please enter a valid UUID format",
    "accountType": "Account Type",
    "selectAccountType": "Select account type",
    "notSelected": "Not Selected",
    "preferredAuth": "Preferred Auth Method",
    "selectPreferredAuth": "Select preferred auth method",
    "authAuto": "Auto (prioritize OAuth)",
    "authOAuthOnly": "OAuth Only",
    "authWebOnly": "Web Only (Cookie)",
    "preferredAuthDesc": "When the account has both Cookie and OAuth, choose the preferred authentication method",
    "cookieWarningTitle": "Cookie Format Warning",
    "cookieWarningDesc": "The cookie format you entered may be incorrect. The standard format should start with \"sessionKey=sk-ant-sid01-\".",
    "cookieWarningNote": "If you are using a reverse proxy or custom configuration, you can ignore this warning and proceed.",
    "submitAnyway": "Submit Anyway"
  },
  "oauthModal": {
    "title": "OAuth Login",
    "desc": "Add a Claude account using OAuth",
    "enterOrgUuid": "Please enter Organization UUID",
    "orgUuidPlaceholder": "Enter your Organization UUID",
    "invalidUuid": "Please enter a valid UUID format",
    "orgUuidHint": "Can be found in the lastActiveOrg field of your Claude.ai cookie",
    "accountType": "Account Type",
    "selectAccountType": "Select account type",
    "generateFailed": "Failed to generate authorization URL",
    "authFailed": "Authorization failed, please try again",
    "authPageOpened": "Authorization page has been opened in a new window. After completing authorization, copy the authorization code and paste it below.",
    "authCode": "Authorization Code",
    "authCodePlaceholder": "Paste the authorization code",
    "generating": "Generating...",
    "startAuth": "Start Authorization",
    "verifying": "Verifying...",
    "completeAuth": "Complete Authorization",
    "recommendCookie": "It is recommended to add accounts using Cookie, as Clove can automatically complete authentication. OAuth login is only an alternative."
  },
  "batchModal": {
    "title": "Batch Add Cookies",
    "desc": "Add multiple Claude account cookies at once",
    "cookieList": "Cookie List",
    "placeholder": "Paste your cookies, one per line...\n\nExample:\nsk-ant-sid01-xxxxx\nsk-ant-sid01-yyyyy\nsessionKey=sk-ant-sid01-zzzzz",
    "supportedFormats": "Supports pasting sessionKey directly or the complete cookie format",
    "progress": "Processing Progress",
    "successCount": "{{success}} succeeded / {{error}} failed / {{total}} total",
    "invalidFormat": "Invalid cookie format",
    "addFailed": "Failed to add",
    "completeMessage": "Processing complete! Successfully added {{count}} accounts",
    "completeMessageWithErrors": "Processing complete! Successfully added {{success}} accounts, {{error}} failed.",
    "copiedFailed": "Copied failed cookies",
    "copyFailedCookies": "Copy Failed Cookies",
    "startAdding": "Start Adding"
  }
}
</file>

<file path="front/src/i18n/locales/zh.json">
{
  "common": {
    "cancel": "",
    "delete": "",
    "save": "",
    "saving": "...",
    "edit": "",
    "add": "",
    "done": "",
    "processing": "...",
    "copyFailed": "",
    "unknownError": ""
  },
  "login": {
    "welcomeBack": "",
    "subtitle": " Admin Key ",
    "placeholder": "",
    "verifying": "...",
    "signIn": "",
    "invalidKey": "Admin Key ",
    "footer": "Clove -  Claude "
  },
  "dashboard": {
    "title": "",
    "welcome": " Clove!",
    "totalAccounts": "",
    "serverStatus": "",
    "online": "",
    "offline": "",
    "activeSessions": "",
    "systemStatus": "",
    "normal": "",
    "degraded": "",
    "quickActions": "",
    "manageAccounts": "",
    "manageAccountsDesc": " Claude ",
    "goToAccounts": "",
    "systemSettings": "",
    "systemSettingsDesc": "",
    "goToSettings": ""
  },
  "accounts": {
    "title": "",
    "subtitle": " Claude ",
    "oauthLogin": "OAuth ",
    "batchAdd": "",
    "addCookie": " Cookie",
    "noAccounts": "",
    "noAccountsDesc": "\" Cookie\"\"OAuth \"",
    "deleteFailed": "",
    "deleteConfirmTitle": "",
    "deleteConfirmDesc": " Clove  Claude.ai ",
    "authMethod": "",
    "status": "",
    "accountType": "",
    "lastUsed": "",
    "resetTime": "",
    "actions": "",
    "openMenu": "",
    "statusValid": "",
    "statusInvalid": "",
    "statusRateLimited": ""
  },
  "settings": {
    "title": "",
    "subtitle": "",
    "saved": "",
    "saveFailed": "",
    "apiKeys": "API ",
    "apiKeysDesc": " API ",
    "noApiKeys": " API ",
    "hideKey": "",
    "showKey": "",
    "copyKey": "",
    "keyCopied": "",
    "copyKeyFailed": "",
    "deleteKeyTitle": "",
    "deleteApiKeyDesc": " API",
    "addNewApiKey": " API ",
    "enterOrGenerateKey": "",
    "generateKey": "",
    "adminKeys": "",
    "adminKeysDesc": "",
    "noAdminKeys": "",
    "deleteAdminKeyDesc": "",
    "addNewAdminKey": "",
    "claudeConfig": "Claude ",
    "claudeConfigDesc": " Claude AI ",
    "proxyUrl": " URL ()",
    "proxyUrlPlaceholder": "",
    "formatSettings": "",
    "formatSettingsDesc": "",
    "customPrompt": " ()",
    "customPromptPlaceholder": "...",
    "humanName": "",
    "assistantName": "",
    "paddingLength": "Padding ",
    "useRealRoles": "",
    "useRealRolesDesc": "",
    "allowExternalImages": "",
    "allowExternalImagesDesc": "",
    "preserveChats": "",
    "preserveChatsDesc": ""
  },
  "layout": {
    "dashboard": "",
    "accounts": "",
    "settings": "",
    "logout": ""
  },
  "accountModal": {
    "titleAdd": " Cookie",
    "titleEdit": "",
    "descAdd": " Claude  Cookie",
    "descEdit": "",
    "cookiePlaceholder": " Claude Cookie...",
    "advancedOptions": "",
    "orgUuidPlaceholder": "",
    "invalidUuid": " UUID ",
    "accountType": "",
    "selectAccountType": "",
    "notSelected": "",
    "preferredAuth": "",
    "selectPreferredAuth": "",
    "authAuto": " OAuth",
    "authOAuthOnly": " OAuth",
    "authWebOnly": " WebCookie",
    "preferredAuthDesc": " Cookie  OAuth ",
    "cookieWarningTitle": "Cookie ",
    "cookieWarningDesc": " Cookie  \"sessionKey=sk-ant-sid01-\" ",
    "cookieWarningNote": "",
    "submitAnyway": ""
  },
  "oauthModal": {
    "title": "OAuth ",
    "desc": " OAuth  Claude ",
    "enterOrgUuid": " Organization UUID",
    "orgUuidPlaceholder": " Organization UUID",
    "invalidUuid": " UUID ",
    "orgUuidHint": " Claude.ai Cookie  lastActiveOrg ",
    "accountType": "",
    "selectAccountType": "",
    "generateFailed": " URL ",
    "authFailed": "",
    "authPageOpened": "",
    "authCode": "",
    "authCodePlaceholder": "",
    "generating": "...",
    "startAuth": "",
    "verifying": "...",
    "completeAuth": "",
    "recommendCookie": " Cookie Clove OAuth "
  },
  "batchModal": {
    "title": " Cookie",
    "desc": " Claude  Cookie",
    "cookieList": "Cookie ",
    "placeholder": " Cookie...\n\n\nsk-ant-sid01-xxxxx\nsk-ant-sid01-yyyyy\nsessionKey=sk-ant-sid01-zzzzz",
    "supportedFormats": " sessionKey  Cookie ",
    "progress": "",
    "successCount": "{{success}}  / {{error}}  / {{total}} ",
    "invalidFormat": "Cookie ",
    "addFailed": "",
    "completeMessage": " {{count}} ",
    "completeMessageWithErrors": " {{success}} {{error}} ",
    "copiedFailed": " Cookie",
    "copyFailedCookies": " Cookie",
    "startAdding": ""
  }
}
</file>

<file path="front/src/index.css">
@import 'tailwindcss';
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}

:root {
  --radius: 0.75rem;
  --background: oklch(0.995 0.001 0);
  --foreground: oklch(0.2 0.02 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.2 0.02 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.2 0.02 0);
  --primary: oklch(0.72 0.22 348);
  --primary-foreground: oklch(1 0 0);
  --secondary: oklch(0.92 0.08 325);
  --secondary-foreground: oklch(0.25 0.02 325);
  --muted: oklch(0.97 0.02 340);
  --muted-foreground: oklch(0.5 0.02 340);
  --accent: oklch(0.88 0.12 328);
  --accent-foreground: oklch(0.25 0.02 328);
  --destructive: oklch(0.6 0.2 20);
  --border: oklch(0.94 0.02 340);
  --input: oklch(0.94 0.02 340);
  --ring: oklch(0.72 0.22 348);
  --chart-1: oklch(0.72 0.22 348);
  --chart-2: oklch(0.68 0.18 325);
  --chart-3: oklch(0.75 0.15 328);
  --chart-4: oklch(0.8 0.12 350);
  --chart-5: oklch(0.85 0.14 340);
  --sidebar: oklch(0.995 0.005 340);
  --sidebar-foreground: oklch(0.2 0.02 0);
  --sidebar-primary: oklch(0.72 0.22 348);
  --sidebar-primary-foreground: oklch(1 0 0);
  --sidebar-accent: oklch(0.92 0.08 325);
  --sidebar-accent-foreground: oklch(0.25 0.02 325);
  --sidebar-border: oklch(0.94 0.02 340);
  --sidebar-ring: oklch(0.72 0.22 348);
}

.dark {
  --background: oklch(0.15 0.01 340);
  --foreground: oklch(0.95 0.01 340);
  --card: oklch(0.18 0.01 340);
  --card-foreground: oklch(0.95 0.01 340);
  --popover: oklch(0.18 0.01 340);
  --popover-foreground: oklch(0.95 0.01 340);
  --primary: oklch(0.78 0.18 348);
  --primary-foreground: oklch(0.15 0.01 348);
  --secondary: oklch(0.28 0.04 325);
  --secondary-foreground: oklch(0.9 0.01 325);
  --muted: oklch(0.25 0.02 340);
  --muted-foreground: oklch(0.65 0.02 340);
  --accent: oklch(0.35 0.06 328);
  --accent-foreground: oklch(0.9 0.01 328);
  --destructive: oklch(0.65 0.18 20);
  --border: oklch(0.25 0.02 340);
  --input: oklch(0.25 0.02 340);
  --ring: oklch(0.78 0.18 348);
  --chart-1: oklch(0.78 0.18 348);
  --chart-2: oklch(0.72 0.14 325);
  --chart-3: oklch(0.75 0.12 328);
  --chart-4: oklch(0.82 0.1 350);
  --chart-5: oklch(0.88 0.12 340);
  --sidebar: oklch(0.18 0.01 340);
  --sidebar-foreground: oklch(0.95 0.01 340);
  --sidebar-primary: oklch(0.78 0.18 348);
  --sidebar-primary-foreground: oklch(0.15 0.01 348);
  --sidebar-accent: oklch(0.28 0.04 325);
  --sidebar-accent-foreground: oklch(0.9 0.01 325);
  --sidebar-border: oklch(0.25 0.02 340);
  --sidebar-ring: oklch(0.78 0.18 348);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

@layer utilities {
  .animation-delay-2000 {
    animation-delay: 2s;
  }
  .animation-delay-4000 {
    animation-delay: 4s;
  }
}
</file>

<file path="front/src/utils/validators.ts">
/**
 * Validates if a string is a valid UUID
 * @param uuid - The string to validate
 * @returns boolean indicating if the string is a valid UUID
 */
export function isValidUUID(uuid: string): boolean {
    const generalUuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i

    return generalUuidRegex.test(uuid)
}

/**
 * Formats a UUID string to lowercase with dashes
 * @param uuid - The UUID string to format
 * @returns The formatted UUID string or the original if invalid
 */
export function formatUUID(uuid: string): string {
    const cleaned = uuid.trim().toLowerCase()

    if (isValidUUID(cleaned)) {
        return cleaned
    }

    // Try to format if it's 32 hex characters without dashes
    const hexOnly = cleaned.replace(/[^0-9a-f]/gi, '')
    if (hexOnly.length === 32) {
        return `${hexOnly.slice(0, 8)}-${hexOnly.slice(8, 12)}-${hexOnly.slice(12, 16)}-${hexOnly.slice(
            16,
            20,
        )}-${hexOnly.slice(20, 32)}`
    }

    return uuid
}
</file>

<file path="front/src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="front/tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,

    "baseUrl": ".",
    "paths": {
      "@/*": [
        "./src/*"
      ]
    }
  },
  "include": ["src"]
}
</file>

<file path="front/tsconfig.json">
{
    "files": [],
    "references": [{ "path": "./tsconfig.app.json" }, { "path": "./tsconfig.node.json" }],
    "compilerOptions": {
        "baseUrl": ".",
        "paths": {
            "@/*": ["./src/*"]
        }
    }
}
</file>

<file path="front/tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="front/vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import tailwindcss from '@tailwindcss/vite'
import path from 'path'

// https://vite.dev/config/
export default defineConfig({
    plugins: [react(), tailwindcss()],
    resolve: {
        alias: {
            '@': path.resolve(__dirname, './src'),
        },
    },
    server: {
        proxy: {
            '/api': {
                target: 'http://localhost:5201',
                changeOrigin: true,
            },
            '/health': {
                target: 'http://localhost:5201',
                changeOrigin: true,
            },
        },
    },
})
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 orange

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="plans/260224-frontend-i18n-english-localization/plan.md">
---
title: "Frontend i18n with react-i18next (English default)"
description: "Add internationalization to Clove frontend, replacing ~122 hardcoded Chinese strings with t() calls, defaulting to English"
status: complete
priority: P1
effort: 3h
branch: feat/frontend-english-localization
tags: [i18n, frontend, react-i18next, localization]
created: 2026-02-24
---

# Frontend i18n - English Localization Plan

## Objective
Replace all hardcoded Chinese strings across 8 frontend files with `react-i18next` translation calls. Default language: English. Minimize upstream merge conflicts by creating NEW files for i18n infrastructure and only replacing string literals in existing files.

## Conflict Mitigation Strategy
- All i18n infrastructure = NEW files (zero conflicts)
- Existing files: only change Chinese string literals to `t('key')` calls + add `useTranslation()` import/hook
- Preserve identical JSX structure, component logic, formatting
- `toLocaleString('zh-CN')` changes to locale-aware formatting via i18n

---

## Phase 1: i18n Infrastructure (NEW files only - zero conflicts)

### 1.1 Install dependencies
```bash
cd front && pnpm add react-i18next i18next i18next-browser-languagedetector
```

### 1.2 Create i18n config
**New file:** `src/i18n/i18n-config.ts`
```typescript
import i18n from 'i18next'
import { initReactI18next } from 'react-i18next'
import LanguageDetector from 'i18next-browser-languagedetector'
import en from './locales/en.json'
import zh from './locales/zh.json'

i18n
  .use(LanguageDetector)
  .use(initReactI18next)
  .init({
    resources: { en: { translation: en }, zh: { translation: zh } },
    fallbackLng: 'en',
    interpolation: { escapeValue: false },
    detection: {
      order: ['localStorage', 'navigator'],
      lookupLocalStorage: 'i18nLanguage',
      caches: ['localStorage'],
    },
  })

export default i18n
```

### 1.3 Create translation files
**Key naming convention:** flat dot-notation grouped by component/page.
- `login.title`, `login.subtitle`, `login.placeholder`, etc.
- `dashboard.title`, `dashboard.welcome`, etc.
- `accounts.title`, `accounts.delete`, etc.
- `settings.title`, `settings.apiKeys`, etc.
- `layout.nav.dashboard`, `layout.nav.accounts`, etc.
- `accountModal.title.add`, `accountModal.title.edit`, etc.
- `oauthModal.title`, `oauthModal.orgUuidLabel`, etc.
- `batchModal.title`, `batchModal.placeholder`, etc.
- `common.cancel`, `common.delete`, `common.save`, `common.edit`, etc.

**New file:** `src/i18n/locales/en.json` - English translations (primary)
**New file:** `src/i18n/locales/zh.json` - Chinese translations (match current hardcoded strings exactly)

### 1.4 Complete string inventory (~122 strings across 8 files)

| File | Count | Key prefix |
|------|-------|-----------|
| Login.tsx | 5 | `login.*` |
| Dashboard.tsx | 13 | `dashboard.*` |
| Accounts.tsx | 27 | `accounts.*` |
| Settings.tsx | 29 | `settings.*` |
| Layout.tsx | 4 | `layout.*` |
| AccountModal.tsx | 17 | `accountModal.*` |
| OAuthModal.tsx | 13 | `oauthModal.*` |
| BatchCookieModal.tsx | 14 | `batchModal.*` |
| **Shared** | ~8 | `common.*` |

---

## Phase 2: Integration (minimal changes to existing files)

### 2.1 Wire i18n into app entry
**Modify:** `src/main.tsx` - add single import line:
```typescript
import './i18n/i18n-config'  // add before App import
```

### 2.2 Replace strings in each file

For each of the 8 files, the changes are:
1. Add import: `import { useTranslation } from 'react-i18next'`
2. Add hook: `const { t } = useTranslation()`
3. Replace each Chinese string literal with `t('key')`
4. Replace `toLocaleString('zh-CN')` with `new Date(x).toLocaleString(i18n.language === 'zh' ? 'zh-CN' : 'en-US')`

**Detailed per-file changes:**

#### Login.tsx (5 strings)
- `''` -> `t('login.welcomeBack')`
- `' Admin Key '` -> `t('login.subtitle')`
- `''` (placeholder) -> `t('login.placeholder')`
- `'...' / ''` -> `t('login.verifying') / t('login.signIn')`
- `'Admin Key '` -> `t('login.invalidKey')`
- `'Clove -  Claude '` -> `t('login.footer')`

#### Dashboard.tsx (13 strings)
- `''` -> `t('dashboard.title')`
- `' Clove!'` -> `t('dashboard.welcome')`
- `'' / '' / '' / ''` -> `t('dashboard.totalAccounts')` etc.
- `'' / '' / '' / ''` -> `t('dashboard.online')` etc.
- `'' / '' / ''` -> `t('dashboard.quickActions')` etc.
- `' Claude '` -> `t('dashboard.manageAccountsDesc')`
- `''` -> `t('dashboard.systemSettingsDesc')`
- `'' / ''` -> `t('dashboard.goToAccounts') / t('dashboard.goToSettings')`

#### Accounts.tsx (27 strings)
- Page header, button labels, table headers, status names, empty states, delete dialog, etc.
- Status mapping: `''/''/''` -> `t('accounts.status.valid')` etc.
- All `toLocaleString('zh-CN')` -> locale-aware

#### Settings.tsx (29 strings)
- Section titles, labels, descriptions, placeholders, status badges, delete dialogs, toast messages
- Toast messages: `''` -> `t('settings.keyCopied')` etc.

#### Layout.tsx (4 strings)
- Nav items: `'' / '' / ''` -> `t('layout.nav.*')`
- `''` -> `t('layout.logout')`

#### AccountModal.tsx (17 strings)
- Dialog titles, labels, placeholders, button text, alert messages, select options

#### OAuthModal.tsx (13 strings)
- Dialog titles, labels, placeholders, error messages, button states, info alerts

#### BatchCookieModal.tsx (14 strings)
- Dialog titles, placeholders, progress labels, result messages, button states

### 2.3 API client comments
**Modify:** `src/api/client.ts`
- Translate Chinese comments to English
- Change error fallback: `''` -> `t('common.unknownError')` (or keep simple English string since this is in a non-component context; use `i18n.t()` import directly)

---

## Phase 3: Language Switcher

### 3.1 Add toggle to Layout.tsx header
Add a minimal EN/ZH toggle button in the header bar (next to SidebarTrigger):

```tsx
import { useTranslation } from 'react-i18next'
import { Languages } from 'lucide-react'

// In header:
<Button variant="ghost" size="sm" onClick={() => {
  const newLang = i18n.language === 'zh' ? 'en' : 'zh'
  i18n.changeLanguage(newLang)
}}>
  <Languages className="h-4 w-4 mr-1" />
  {i18n.language === 'zh' ? 'EN' : 'ZH'}
</Button>
```

Language persisted automatically via `i18next-browser-languagedetector` + localStorage key `i18nLanguage`.

---

## Files Created (NEW - zero conflict risk)
| File | Purpose |
|------|---------|
| `src/i18n/i18n-config.ts` | i18n initialization |
| `src/i18n/locales/en.json` | English translations |
| `src/i18n/locales/zh.json` | Chinese translations |

## Files Modified (minimal changes)
| File | Changes |
|------|---------|
| `src/main.tsx` | +1 import line |
| `src/pages/Login.tsx` | +import, +hook, 5 string replacements |
| `src/pages/Dashboard.tsx` | +import, +hook, 13 string replacements |
| `src/pages/Accounts.tsx` | +import, +hook, 27 string replacements |
| `src/pages/Settings.tsx` | +import, +hook, 29 string replacements |
| `src/components/Layout.tsx` | +import, +hook, 4 string replacements, +language toggle |
| `src/components/AccountModal.tsx` | +import, +hook, 17 string replacements |
| `src/components/OAuthModal.tsx` | +import, +hook, 13 string replacements |
| `src/components/BatchCookieModal.tsx` | +import, +hook, 14 string replacements |
| `src/api/client.ts` | Translate comments, 1 error string |

## Implementation Order
1. Phase 1 (infrastructure) - can be done without touching existing files
2. Phase 2 (string replacement) - do one file at a time, build-test after each
3. Phase 3 (language switcher) - final touch

## Success Criteria
- [x] `pnpm build` passes with zero errors
- [x] App defaults to English on fresh visit
- [x] All UI text displays in English
- [x] Toggle switches to Chinese, all text matches original
- [x] Language preference persists across page reloads
- [x] Date/time formatting adapts to selected language
- [x] No Chinese strings remain hardcoded in any TSX file

## Risk Assessment
- **Low risk:** All i18n infra is new files; string replacements are mechanical
- **Merge conflict mitigation:** Upstream changes to Chinese strings will conflict with our `t()` calls, but these are simple line-level conflicts resolvable by updating translation JSONs
- **Date formatting:** `toLocaleString` locale param change is safe; both `en-US` and `zh-CN` are universally supported
</file>

<file path="plans/260224-frontend-i18n-english-localization/reports/code-review-report.md">
# Code Review Report: Frontend i18n (English Localization)

**Date:** 2026-02-24
**Branch:** `feat/frontend-english-localization`
**Reviewer:** code-reviewer agent

---

## Code Review Summary

### Scope
- **Files reviewed:** 13
- **LOC changed:** ~450 (front-end only, excludes backend)
- **Focus:** i18n infrastructure, translation key correctness, missed strings, runtime safety
- **New dependencies:** `i18next@^25.8.13`, `i18next-browser-languagedetector@^8.2.1`, `react-i18next@^16.5.4`

### Overall Assessment

The i18n implementation is **solid and well-structured**. Translation key naming is consistent (dot-separated namespace prefixes), both locale files have identical key structures (150 keys each, verified programmatically), and `useTranslation()` hook usage is correct across all 8 modified component files. TypeScript compiles cleanly with zero errors. The implementation is production-ready with a few medium/low-priority items worth addressing.

---

### Critical Issues

**None found.**

---

### High Priority

#### H1. Hardcoded fallback string in `client.ts` error interceptor (not i18n-aware)

**File:** `D:\CODE\fullstack\package run only\mirrorange_clove\front\src\api\client.ts` (line 42)

```typescript
const errorMessage = error.response?.data?.detail?.message || 'An unknown error occurred'
```

The fallback string is hardcoded in English. A `common.unknownError` key exists in both locale files but is never used. Since `client.ts` is an axios interceptor (outside React component tree), `useTranslation()` cannot be used directly.

**Impact:** Chinese-language users see an English error message when API errors lack a `detail.message` field.

**Recommended fix:** Import the i18n instance directly:

```typescript
import i18n from '../i18n/i18n-config'
// ...
const errorMessage = error.response?.data?.detail?.message || i18n.t('common.unknownError')
```

This pattern is the standard approach for non-component code in i18next. The `i18n` instance is initialized synchronously before any API calls occur, so there is no timing concern.

**Priority:** HIGH -- this is the only user-facing string that bypasses i18n entirely.

---

### Medium Priority

#### M1. Hardcoded English label strings not wrapped in `t()`

Several labels remain as static English text. These are technical identifiers that arguably do not need translation, but the approach is inconsistent with the rest of the i18n implementation.

| File | Line | String |
|------|------|--------|
| `Login.tsx` | 66 | `Admin Key` (label text) |
| `Settings.tsx` | 480 | `Claude AI URL` (label text) |
| `Settings.tsx` | 490 | `Claude API Base URL` (label text) |
| `Accounts.tsx` | 424 | `Organization UUID` (table header) |
| `AccountModal.tsx` | 192 | `Cookie` (label text) |
| `AccountModal.tsx` | 214 | `Organization UUID` (label text) |
| `OAuthModal.tsx` | 140 | `Organization UUID` (label text) |

**Verdict:** These are deliberately left as-is since they are technical terms (brand names, protocol identifiers). This is an acceptable design decision. However, wrapping them in `t()` would allow Chinese localization to add context. For consistency, consider at minimum adding them to locale files even if the English and Chinese values are identical.

#### M2. `dateLocale` variable only in `Accounts.tsx`, not in other date-rendering pages

**File:** `D:\CODE\fullstack\package run only\mirrorange_clove\front\src\pages\Accounts.tsx` (line 54)

```typescript
const dateLocale = i18n.language === 'zh' ? 'zh-CN' : 'en-US'
```

This locale-aware date formatting pattern is correctly implemented in `Accounts.tsx` and used on lines 228, 232, 453, 456. However, if other pages ever render dates, they would need to duplicate this pattern. Consider extracting this to a shared utility or custom hook.

**Impact:** Low -- currently only one page renders dates. But as the app grows, this becomes a maintenance concern.

#### M3. Direct mutation of `formData` in `AccountModal.tsx`

**File:** `D:\CODE\fullstack\package run only\mirrorange_clove\front\src\components\AccountModal.tsx` (line 87)

```typescript
formData.cookie_value = processedValue  // Direct mutation!
setFormData({ ...formData, cookie_value: processedValue })
```

Line 87 mutates the state object directly before the setter is called on line 88. While this works because the spread on line 88 creates a new object, the mutation is technically unsafe and violates React best practices for state immutability.

**Recommended fix:**
```typescript
const updatedFormData = { ...formData, cookie_value: processedValue }
setFormData(updatedFormData)
```

**Note:** This is a pre-existing issue not introduced by the i18n changes, but worth flagging.

---

### Low Priority

#### L1. `common.unknownError` key is defined but never referenced via `t()`

Both `en.json` and `zh.json` define `common.unknownError` but no component calls `t('common.unknownError')`. If H1 is fixed, this becomes used. Otherwise it is dead code.

#### L2. Language toggle shows inverted label

**File:** `D:\CODE\fullstack\package run only\mirrorange_clove\front\src\components\Layout.tsx` (line 95)

```tsx
{i18n.language === 'zh' ? 'EN' : ''}
```

This is correctly implemented -- it shows the language the user can switch TO, not the current language. The Chinese character in the source file (used as a button label) is intentional and does not need i18n wrapping since it IS the language selector. No issue here, just noting it is the only non-locale-file Chinese character in the codebase outside `zh.json`.

#### L3. Language detection `order` does not include URL query parameter

**File:** `D:\CODE\fullstack\package run only\mirrorange_clove\front\src\i18n\i18n-config.ts` (line 18)

```typescript
order: ['localStorage', 'navigator'],
```

This is fine for the current use case. Adding `'querystring'` would allow URL-based language switching (e.g., `?lng=en`) which could be useful for sharing links in a specific language. Not needed now, but worth considering for future enhancement.

#### L4. `console.error` statements remain in multiple files

Several `console.error` calls exist across Dashboard, Accounts, Settings, OAuthModal, BatchCookieModal. These are debug-level logging statements. While acceptable for development, production builds should ideally strip these or use a structured logger.

Files affected: `Dashboard.tsx:25`, `Accounts.tsx:61,80`, `Settings.tsx:47,76`, `OAuthModal.tsx:92,120`, `BatchCookieModal.tsx:150`.

---

### Positive Observations

1. **Comprehensive key coverage.** 150 translation keys across 9 namespaces cover the entire UI surface.
2. **1:1 key parity between locales.** Programmatic verification confirms en.json and zh.json have identical key structures with zero drift.
3. **TypeScript compiles cleanly.** Zero errors after changes -- all imports/usages are type-safe.
4. **Interpolation used correctly.** `batchModal.successCount` with `{{success}}/{{error}}/{{total}}` and `batchModal.completeMessage` with `{{count}}` use i18next interpolation syntax properly.
5. **Consistent namespace convention.** Keys follow `namespace.camelCase` pattern throughout (e.g., `accountModal.cookieWarningTitle`).
6. **Language detection with persistence.** `i18next-browser-languagedetector` configured with localStorage fallback to navigator -- user preference persists across sessions.
7. **Clean i18n initialization.** Side-effect import in `main.tsx` (`import './i18n/i18n-config'`) ensures i18n is initialized before any component renders.
8. **`escapeValue: false` is correct** for React since React already escapes JSX output, avoiding double-escaping.
9. **Fallback language set to English** -- reasonable default for a technical tool with international users.
10. **Date locale handling** in Accounts.tsx is properly reactive to language changes via `i18n.language`.

---

### Recommended Actions (Prioritized)

1. **[HIGH] Fix `client.ts` fallback string** -- Use `i18n.t('common.unknownError')` instead of hardcoded English. Single-line fix.
2. **[MEDIUM] Consider adding technical label keys** -- Even if values are identical across languages, having them in locale files allows future localization flexibility.
3. **[MEDIUM] Fix direct state mutation** in `AccountModal.tsx` line 87 (pre-existing, not i18n-related).
4. **[LOW] Extract `dateLocale` derivation** to a shared utility if more pages start rendering dates.

---

### Metrics

- **Translation key coverage:** 150 keys, all verified present in both en.json and zh.json
- **Key parity:** 100% (zero missing keys in either direction)
- **TypeScript compilation:** PASS (zero errors)
- **Hardcoded user-facing strings remaining:** 1 (client.ts fallback) + 7 technical labels (intentional)
- **Files with `useTranslation()` hook:** 8/8 modified components

---

### Unresolved Questions

1. Should the 7 technical labels (`Admin Key`, `Cookie`, `Organization UUID`, `Claude AI URL`, `Claude API Base URL`) be wrapped in `t()` for consistency, or kept as-is since they are proper nouns / technical identifiers?
2. Should `client.ts` error messages from the backend API (returned in `detail.message`) be localized server-side, or is the current client-side i18n approach sufficient?
</file>

<file path="plans/reports/code-review-i18n-implementation.md">
# Code Review: Frontend i18n Implementation

**Branch:** `feat/frontend-english-localization`
**Date:** 2026-02-24
**Reviewer:** code-reviewer

## Scope

- **Files modified:** 11 (.tsx/.ts files) + package.json + pnpm-lock.yaml
- **Files created:** 3 (i18n-config.ts, en.json, zh.json)
- **Translation keys:** 150 (matched 1:1 between en.json and zh.json)
- **LOC changed:** ~400+ across all files
- **Focus:** i18n correctness, translation coverage, code quality

## Overall Assessment

Solid i18n implementation. The react-i18next setup follows standard patterns, all 150 translation keys are present in both locale files, interpolation variables match, and the language switcher works correctly. A few minor issues found -- mostly hardcoded label strings that were intentionally left as-is (technical terms), plus some low-priority improvements.

---

## Critical Issues

**None found.**

No security vulnerabilities, no injection risks. The i18next `escapeValue: false` setting in `i18n-config.ts` (line 16) is safe here because React already escapes output by default and there is no use of `dangerouslySetInnerHTML` or the `<Trans>` component with HTML content anywhere in the codebase.

---

## High Priority

### H1. `<html lang>` attribute not updated on language change

**File:** `D:\CODE\fullstack\package run only\mirrorange_clove\front\index.html` (line 2)
**File:** `D:\CODE\fullstack\package run only\mirrorange_clove\front\src\i18n\i18n-config.ts`

The `<html lang="en">` is hardcoded. When the user switches to Chinese, the `lang` attribute stays as `en`. This affects accessibility (screen readers) and SEO.

**Fix:** Add a language change listener in the i18n config or in `main.tsx`:

```typescript
// In i18n-config.ts, after .init():
i18n.on('languageChanged', (lng) => {
  document.documentElement.setAttribute('lang', lng)
})
```

### H2. Language switcher does not handle sub-locale codes

**File:** `D:\CODE\fullstack\package run only\mirrorange_clove\front\src\components\Layout.tsx` (line 92)

```tsx
i18n.changeLanguage(i18n.language === 'zh' ? 'en' : 'zh')
```

The `i18next-browser-languagedetector` may detect the browser language as `zh-CN`, `zh-TW`, or `en-US` rather than the bare `zh` or `en`. The strict equality `=== 'zh'` will fail to match `zh-CN`, causing the toggle to behave incorrectly (always showing the Chinese toggle label).

**Fix:** Use `startsWith` instead:

```tsx
i18n.changeLanguage(i18n.language.startsWith('zh') ? 'en' : 'zh')
```

And the display label on line 95:

```tsx
{i18n.language.startsWith('zh') ? 'EN' : '\u4E2D\u6587'}
```

---

## Medium Priority

### M1. Five hardcoded English labels remain in source

These are technical term labels left untranslated. While arguably acceptable as brand/tech names, they break consistency if the UI is in Chinese.

| File | Line | String |
|------|------|--------|
| `Login.tsx` | 66 | `Admin Key` (label) |
| `Accounts.tsx` | 424 | `Organization UUID` (table header) |
| `AccountModal.tsx` | 214 | `Organization UUID` (label) |
| `Settings.tsx` | 480 | `Claude AI URL` (label) |
| `Settings.tsx` | 490 | `Claude API Base URL` (label) |

**Recommendation:** These are borderline. If the intent is to keep technical terms in English regardless of locale, document this decision. Otherwise, add keys like `settings.claudeAiUrl` and `settings.claudeApiBaseUrl`.

### M2. `dateLocale` derivation could be centralized

**File:** `D:\CODE\fullstack\package run only\mirrorange_clove\front\src\pages\Accounts.tsx` (line 54)

```tsx
const dateLocale = i18n.language === 'zh' ? 'zh-CN' : 'en-US'
```

This locale mapping logic is inlined in the component. If more pages need date formatting, this will be duplicated. Also has the same sub-locale detection issue as H2 (should use `startsWith`).

**Recommendation:** Extract to a utility or add a locale mapping in the i18n config:

```typescript
// utils/locale.ts
export function getDateLocale(lang: string): string {
  if (lang.startsWith('zh')) return 'zh-CN'
  return 'en-US'
}
```

### M3. `console.error` calls throughout components

8 instances of `console.error` across 5 files. These are debug-level logs that should ideally not be in production. Not introduced by this PR (pre-existing), but worth noting.

---

## Low Priority

### L1. `i18n` import in `client.ts` creates a module-level dependency

**File:** `D:\CODE\fullstack\package run only\mirrorange_clove\front\src\api\client.ts` (line 3)

```typescript
import i18n from '../i18n/i18n-config'
```

This is fine for the current setup since `main.tsx` imports `i18n-config` first (line 4). However, if module load order ever changes, the i18n instance might not be initialized when the interceptor runs. The current side-effect import in `main.tsx` ensures correct order.

**No action needed** -- just be aware of the implicit initialization dependency.

### L2. Single Chinese character remains in source code

**File:** `D:\CODE\fullstack\package run only\mirrorange_clove\front\src\components\Layout.tsx` (line 95)

```tsx
{i18n.language === 'zh' ? 'EN' : '\u4E2D\u6587'}
```

The literal `\u4E2D\u6587` (displayed as the language toggle label) is appropriate here -- it is the language name shown to users to switch locale. This is standard i18n practice and NOT an issue.

### L3. No TypeScript type safety for translation keys

The `t()` function accepts arbitrary strings. Mistyped keys silently fall back to the key string. This is a known limitation of the default react-i18next setup. For a project of this size (150 keys), the risk is low.

**Future improvement:** Consider `i18next` typed resources if the project grows.

---

## Edge Cases Found by Scout

1. **Browser language `zh-TW` or `zh-Hans`**: The language detector may return a sub-locale code, breaking the toggle logic (see H2).
2. **First-load flash**: The `LanguageDetector` reads `localStorage` first, then `navigator`. If neither matches, it falls back to `en`. No flash of untranslated content since translations are bundled (not lazy-loaded). Good.
3. **`i18n.t()` in non-React context (client.ts)**: The `i18n.t('common.unknownError')` call in the axios interceptor works because it uses the i18n instance directly, not the React hook. This is correct.
4. **Interpolation variables**: All 3 interpolated keys (`batchModal.successCount`, `batchModal.completeMessage`, `batchModal.completeMessageWithErrors`) use identical variable names (`{{success}}`, `{{error}}`, `{{total}}`, `{{count}}`) in both locales. Verified correct.

---

## Positive Observations

1. **Clean separation**: Translation files are well-organized by feature domain (login, dashboard, accounts, settings, layout, accountModal, oauthModal, batchModal).
2. **100% key parity**: All 150 keys exist in both en.json and zh.json with zero mismatches.
3. **Proper hook usage**: Every component uses `useTranslation()` correctly, destructuring `{ t }` or `{ t, i18n }` as needed.
4. **Locale-aware date formatting**: The `Accounts.tsx` page correctly uses `toLocaleString(dateLocale)` for date display.
5. **Fallback language**: `fallbackLng: 'en'` ensures graceful degradation.
6. **Language persistence**: `localStorage` caching via `lookupLocalStorage: 'i18nLanguage'` persists user preference across sessions.
7. **No unnecessary re-renders**: Translation calls are inside render functions, which is the recommended pattern.
8. **API error message uses i18n**: The axios interceptor in `client.ts` correctly uses `i18n.t()` for the fallback error message.

---

## Recommended Actions

1. **[HIGH]** Fix language switcher to handle sub-locale codes (`startsWith` instead of `===`) in `Layout.tsx` and `Accounts.tsx`
2. **[HIGH]** Add `document.documentElement.lang` sync on language change in `i18n-config.ts`
3. **[MEDIUM]** Decide whether technical labels (Admin Key, Organization UUID, Claude AI URL, Claude API Base URL) should be translated or intentionally kept in English; document the decision
4. **[LOW]** Extract date locale mapping to a shared utility if more pages need it

---

## Metrics

- **Translation Coverage:** 150/150 keys (100%)
- **Key Parity (en/zh):** 150/150 (100%)
- **Interpolation Consistency:** 3/3 interpolated keys match (100%)
- **Hardcoded Strings Remaining:** 5 (technical labels, intentional)
- **Linting Issues:** 0 (build passes)
- **Security Issues:** 0

---

## Unresolved Questions

1. Are the 5 hardcoded technical labels (Admin Key, Organization UUID, Claude AI URL, Claude API Base URL) intentionally untranslated? If so, this should be documented.
2. Is there a plan to support additional locales beyond en/zh in the future? If so, the flat JSON structure should be evaluated for scalability.
</file>

<file path=".github/workflows/build-and-publish.yml">
name: Build and Publish to PyPI

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      publish_to_pypi:
        description: "Publish to PyPI"
        required: true
        default: false
        type: boolean
      publish_to_test_pypi:
        description: "Publish to Test PyPI"
        required: true
        default: false
        type: boolean

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install build wheel

      - name: Build frontend and wheel
        run: |
          python scripts/build_wheel.py

      - name: Store the distribution packages
        uses: actions/upload-artifact@v4
        with:
          name: python-package-distributions
          path: dist/

  publish-to-pypi:
    name: Publish to PyPI
    if: github.event_name == 'release' || (github.event_name == 'workflow_dispatch' && github.event.inputs.publish_to_pypi == 'true')
    needs:
      - build
    runs-on: ubuntu-latest

    environment:
      name: pypi
      url: https://pypi.org/p/clove-proxy

    permissions:
      id-token: write

    steps:
      - name: Download all the dists
        uses: actions/download-artifact@v4
        with:
          name: python-package-distributions
          path: dist/

      - name: Publish distribution to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_API_TOKEN }}

  publish-to-testpypi:
    name: Publish to TestPyPI
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.publish_to_test_pypi == 'true'
    needs:
      - build
    runs-on: ubuntu-latest

    environment:
      name: testpypi
      url: https://test.pypi.org/p/clove-proxy

    permissions:
      id-token: write

    steps:
      - name: Download all the dists
        uses: actions/download-artifact@v4
        with:
          name: python-package-distributions
          path: dist/

      - name: Publish distribution to TestPyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          repository-url: https://test.pypi.org/legacy/
          password: ${{ secrets.TEST_PYPI_API_TOKEN }}
</file>

<file path=".gitmodules">
[submodule "front"]
	path = front
	url = https://github.com/mirrorange/clove-front.git
</file>

<file path="app/core/claude_session.py">
from typing import Dict, Any, AsyncIterator, Optional
from datetime import datetime
from app.core.http_client import Response
from loguru import logger

from app.core.config import settings
from app.core.external.claude_client import ClaudeWebClient
from app.services.account import account_manager


class ClaudeWebSession:
    def __init__(self, session_id: str):
        self.session_id = session_id
        self.last_activity = datetime.now()
        self.conv_uuid: Optional[str] = None
        self.paprika_mode: Optional[str] = None
        self.sse_stream: Optional[AsyncIterator[str]] = None

    async def initialize(self):
        """Initialize the session."""
        self.account = await account_manager.get_account_for_session(self.session_id)
        self.client = ClaudeWebClient(self.account)
        await self.client.initialize()

    async def stream(self, response: Response) -> AsyncIterator[str]:
        """Get the SSE stream."""
        buffer = b""
        async for chunk in response.aiter_bytes():
            self.update_activity()
            buffer += chunk
            lines = buffer.split(b"\n")
            buffer = lines[-1]
            for line in lines[:-1]:
                yield line.decode("utf-8") + "\n"

        if buffer:
            yield buffer.decode("utf-8")

        logger.debug(f"Stream completed for session {self.session_id}")

        from app.services.session import session_manager

        await session_manager.remove_session(self.session_id)

    async def cleanup(self):
        """Cleanup session resources."""
        logger.debug(f"Cleaning up session {self.session_id}")

        # Delete conversation if exists
        if self.conv_uuid and not settings.preserve_chats:
            await self.client.delete_conversation(self.conv_uuid)

        await account_manager.release_session(self.session_id)
        await self.client.cleanup()

    async def _ensure_conversation_initialized(self) -> None:
        """Ensure conversation is initialized. Create if not exists."""
        if not self.conv_uuid:
            conv_uuid, paprika_mode = await self.client.create_conversation()
            self.conv_uuid = conv_uuid
            self.paprika_mode = paprika_mode

    def update_activity(self):
        """Update last activity timestamp."""
        self.last_activity = datetime.now()

    async def send_message(self, payload: Dict[str, Any]) -> AsyncIterator[str]:
        """Process a completion request through the pipeline."""
        self.update_activity()

        await self._ensure_conversation_initialized()

        response = await self.client.send_message(
            payload,
            conv_uuid=self.conv_uuid,
        )
        self.sse_stream = self.stream(response)

        logger.debug(f"Sent message for session {self.session_id}")
        return self.sse_stream

    async def upload_file(
        self, file_data: bytes, filename: str, content_type: str
    ) -> str:
        """Upload a file and return file UUID."""
        return await self.client.upload_file(file_data, filename, content_type)

    async def send_tool_result(self, payload: Dict[str, Any]) -> None:
        """Send tool result to Claude.ai."""
        if not self.conv_uuid:
            raise ValueError(
                "Session must have an active conversation to send tool results"
            )

        await self.client.send_tool_result(payload, self.conv_uuid)

    async def set_paprika_mode(self, mode: Optional[str]) -> None:
        """Set the conversation mode."""
        await self._ensure_conversation_initialized()

        if self.paprika_mode == mode:
            return

        await self.client.set_paprika_mode(self.conv_uuid, mode)
        self.paprika_mode = mode
</file>

<file path="app/core/static.py">
from fastapi import FastAPI, HTTPException
from fastapi.responses import FileResponse
from fastapi.staticfiles import StaticFiles
from loguru import logger

from app.core.config import settings


def register_static_routes(app: FastAPI):
    """Register static file routes for the application."""

    if settings.static_folder.exists():
        app.mount(
            "/assets",
            StaticFiles(directory=str(settings.static_folder / "assets")),
            name="assets",
        )

        # Serve index.html for SPA routes
        @app.get("/{full_path:path}")
        async def serve_spa(full_path: str):
            """Serve index.html for all non-API routes (SPA support)."""
            index_path = settings.static_folder / "index.html"
            if index_path.exists():
                return FileResponse(str(index_path))
            raise HTTPException(status_code=404, detail="Frontend not built")
    else:
        logger.warning(
            "Static files directory not found. Run 'pnpm build' in the front directory to build the frontend."
        )
</file>

<file path="app/dependencies/auth.py">
from typing import Optional, Annotated
from loguru import logger
from fastapi import Depends, Header
import secrets

from app.core.config import settings
from app.core.exceptions import InvalidAPIKeyError

_temp_admin_api_key: Optional[str] = None

if not settings.admin_api_keys:
    _temp_admin_api_key = f"sk-admin-{secrets.token_urlsafe(32)}"
    logger.warning(
        f"No admin API keys configured. Generated temporary admin API key: {_temp_admin_api_key}"
    )
    logger.warning(
        "This is a temporary key and will not be saved. Please configure admin API keys in settings."
    )


async def get_api_key(
    x_api_key: Annotated[Optional[str], Header()] = None,
    authorization: Annotated[Optional[str], Header()] = None,
) -> str:
    # Check X-API-Key header
    api_key = x_api_key

    # Check Authorization header
    if not api_key and authorization:
        if authorization.startswith("Bearer "):
            api_key = authorization[7:]

    if not api_key:
        raise InvalidAPIKeyError()

    return api_key


APIKeyDep = Annotated[str, Depends(get_api_key)]


async def verify_api_key(
    api_key: APIKeyDep,
) -> str:
    # Verify against configured keys
    valid_keys = settings.api_keys + settings.admin_api_keys + [_temp_admin_api_key]

    if not valid_keys:
        logger.error("No API keys configured, Please configure at least one API key.")
        raise InvalidAPIKeyError()

    if api_key not in valid_keys:
        raise InvalidAPIKeyError()

    return api_key


AuthDep = Annotated[str, Depends(verify_api_key)]


async def verify_admin_api_key(
    api_key: APIKeyDep,
) -> str:
    # Verify against configured admin keys
    valid_keys = settings.admin_api_keys + [_temp_admin_api_key]

    if not valid_keys:
        logger.error(
            "No admin API keys configured, Please configure at least one admin API key."
        )
        raise InvalidAPIKeyError()

    if api_key not in valid_keys:
        raise InvalidAPIKeyError()

    return api_key


AdminAuthDep = Annotated[str, Depends(verify_admin_api_key)]
</file>

<file path="app/models/internal.py">
from typing import List, Optional
from pydantic import BaseModel, Field
from .claude import Tool


class Attachment(BaseModel):
    extracted_content: str
    file_name: str
    file_type: str
    file_size: int

    @classmethod
    def from_text(cls, content: str) -> "Attachment":
        """Create text attachment."""
        return cls(
            extracted_content=content,
            file_name="paste.txt",
            file_type="txt",
            file_size=len(content),
        )


class ClaudeWebRequest(BaseModel):
    max_tokens_to_sample: int
    attachments: List[Attachment]
    files: List[str] = Field(default_factory=list)
    model: Optional[str] = None
    rendering_mode: str = "messages"
    prompt: str = ""
    timezone: str
    tools: List[Tool] = Field(default_factory=list)


class UploadResponse(BaseModel):
    file_uuid: str
</file>

<file path="app/models/streaming.py">
from typing import Optional, Union, Dict, Any, Literal
from pydantic import BaseModel, RootModel, ConfigDict

from .claude import ContentBlock, Message, Usage


# Base event types
class BaseEvent(BaseModel):
    model_config = ConfigDict(extra="allow")
    type: str


# Delta types
class TextDelta(BaseModel):
    model_config = ConfigDict(extra="allow")
    type: Literal["text_delta"]
    text: str


class InputJsonDelta(BaseModel):
    model_config = ConfigDict(extra="allow")
    type: Literal["input_json_delta"]
    partial_json: str


class ThinkingDelta(BaseModel):
    model_config = ConfigDict(extra="allow")
    type: Literal["thinking_delta"]
    thinking: str


class SignatureDelta(BaseModel):
    model_config = ConfigDict(extra="allow")
    type: Literal["signature_delta"]
    signature: str


Delta = Union[TextDelta, InputJsonDelta, ThinkingDelta, SignatureDelta]


class MessageDeltaData(BaseModel):
    model_config = ConfigDict(extra="allow")
    stop_reason: Optional[
        Literal["end_turn", "max_tokens", "stop_sequence", "tool_use", "pause_turn", "refusal"]
    ] = None
    stop_sequence: Optional[str] = None


# Error model
class ErrorInfo(BaseModel):
    model_config = ConfigDict(extra="allow")
    type: str
    message: str


# Event models
class MessageStartEvent(BaseEvent):
    type: Literal["message_start"]
    message: Message


class ContentBlockStartEvent(BaseEvent):
    type: Literal["content_block_start"]
    index: int
    content_block: ContentBlock


class ContentBlockDeltaEvent(BaseEvent):
    type: Literal["content_block_delta"]
    index: int
    delta: Delta


class ContentBlockStopEvent(BaseEvent):
    type: Literal["content_block_stop"]
    index: int


class MessageDeltaEvent(BaseEvent):
    type: Literal["message_delta"]
    delta: MessageDeltaData
    usage: Optional[Usage] = None


class MessageStopEvent(BaseEvent):
    type: Literal["message_stop"]


class PingEvent(BaseEvent):
    type: Literal["ping"]


class ErrorEvent(BaseEvent):
    type: Literal["error"]
    error: ErrorInfo


class UnknownEvent(BaseEvent):
    type: str
    data: Dict[str, Any]


# Union of all streaming event types
class StreamingEvent(RootModel):
    root: Union[
        MessageStartEvent,
        ContentBlockStartEvent,
        ContentBlockDeltaEvent,
        ContentBlockStopEvent,
        MessageDeltaEvent,
        MessageStopEvent,
        PingEvent,
        ErrorEvent,
        UnknownEvent,
    ]
</file>

<file path="app/processors/claude_ai/context.py">
from dataclasses import dataclass
from typing import Optional, AsyncIterator

from app.core.claude_session import ClaudeWebSession
from app.models.claude import Message, MessagesAPIRequest
from app.models.internal import ClaudeWebRequest
from app.models.streaming import StreamingEvent
from app.processors.base import BaseContext


@dataclass
class ClaudeAIContext(BaseContext):
    messages_api_request: Optional[MessagesAPIRequest] = None
    claude_web_request: Optional[ClaudeWebRequest] = None
    claude_session: Optional[ClaudeWebSession] = None
    original_stream: Optional[AsyncIterator[str]] = None
    event_stream: Optional[AsyncIterator[StreamingEvent]] = None
    collected_message: Optional[Message] = None
</file>

<file path="app/processors/claude_ai/message_collector_processor.py">
import json5
from typing import AsyncIterator
from loguru import logger

from app.processors.base import BaseProcessor
from app.processors.claude_ai import ClaudeAIContext
from app.models.streaming import (
    Delta,
    StreamingEvent,
    MessageStartEvent,
    ContentBlockStartEvent,
    ContentBlockDeltaEvent,
    ContentBlockStopEvent,
    MessageDeltaEvent,
    MessageStopEvent,
    ErrorEvent,
    ErrorInfo,
    TextDelta,
    InputJsonDelta,
    ThinkingDelta,
)
from app.models.claude import (
    ContentBlock,
    ServerToolUseContent,
    TextContent,
    ThinkingContent,
    ToolResultContent,
    ToolUseContent,
)


class MessageCollectorProcessor(BaseProcessor):
    """Processor that collects streaming events into a Message object without consuming the stream."""

    async def process(self, context: ClaudeAIContext) -> ClaudeAIContext:
        """
        Collect streaming events into a Message object and update it in real-time.
        This processor runs for both streaming and non-streaming requests.

        Requires:
            - event_stream in context

        Produces:
            - collected_message in context (updated in real-time)
            - event_stream in context (wrapped to collect messages without consuming)
        """
        if not context.event_stream:
            logger.warning(
                "Skipping MessageCollectorProcessor due to missing event_stream"
            )
            return context

        logger.debug("Setting up message collection from stream")

        original_stream = context.event_stream

        new_stream = self._collect_messages_generator(original_stream, context)
        context.event_stream = new_stream

        return context

    async def _collect_messages_generator(
        self, event_stream: AsyncIterator[StreamingEvent], context: ClaudeAIContext
    ) -> AsyncIterator[StreamingEvent]:
        """
        Generator that collects messages from the stream without consuming events.
        Updates context.collected_message in real-time.
        """
        context.collected_message = None

        async for event in event_stream:
            # Process the event to build/update the message
            if isinstance(event.root, MessageStartEvent):
                context.collected_message = event.root.message.model_copy(deep=True)
                logger.debug(f"Message started: {context.collected_message.id}")

            elif isinstance(event.root, ContentBlockStartEvent):
                if context.collected_message:
                    while len(context.collected_message.content) <= event.root.index:
                        context.collected_message.content.append(None)
                    context.collected_message.content[event.root.index] = (
                        event.root.content_block.model_copy(deep=True)
                    )
                    logger.debug(
                        f"Content block {event.root.index} started: {event.root.content_block.type}"
                    )

            elif isinstance(event.root, ContentBlockDeltaEvent):
                if context.collected_message and event.root.index < len(
                    context.collected_message.content
                ):
                    self._apply_delta(
                        context.collected_message.content[event.root.index],
                        event.root.delta,
                    )

            elif isinstance(event.root, ContentBlockStopEvent):
                # Boundary checking to prevent IndexError caused by refusal responses
                if (
                    context.collected_message
                    and event.root.index < len(context.collected_message.content)
                ):
                    block = context.collected_message.content[event.root.index]
                    if isinstance(block, (ToolUseContent, ServerToolUseContent)):
                        if hasattr(block, "input_json") and block.input_json:
                            block.input = json5.loads(block.input_json)
                            del block.input_json
                    if isinstance(block, ToolResultContent):
                        if hasattr(block, "content_json") and block.content_json:
                            block = ToolResultContent(
                                **block.model_dump(exclude={"content"}),
                                content=json5.loads(block.content_json),
                            )
                            del block.content_json
                            context.collected_message.content[event.root.index] = block
                    logger.debug(f"Content block {event.root.index} stopped")
                else:
                    logger.debug(
                        f"Content block {event.root.index} stop skipped (no corresponding start)"
                    )

            elif isinstance(event.root, MessageDeltaEvent):
                if context.collected_message and event.root.delta:
                    if event.root.delta.stop_reason:
                        context.collected_message.stop_reason = (
                            event.root.delta.stop_reason
                        )
                        # When refusal is detected and content is empty, yield ErrorEvent
                        if (
                            event.root.delta.stop_reason == "refusal"
                            and not context.collected_message.content
                        ):
                            logger.warning("Request refused by Claude's safety filter")
                            error_event = StreamingEvent(
                                root=ErrorEvent(
                                    type="error",
                                    error=ErrorInfo(
                                        type="refusal",
                                        message="Chat paused: Claude's safety filters flagged this message. This occasionally happens with normal, safe messages. Try rephrasing or using a different model."
                                    )
                                )
                            )
                            yield error_event
                    if event.root.delta.stop_sequence:
                        context.collected_message.stop_sequence = (
                            event.root.delta.stop_sequence
                        )
                if context.collected_message and event.root.usage:
                    context.collected_message.usage = event.root.usage

            elif isinstance(event.root, MessageStopEvent):
                if context.collected_message:
                    context.collected_message.content = [
                        block
                        for block in context.collected_message.content
                        if block is not None
                    ]
                    logger.debug(
                        f"Message stopped with {len(context.collected_message.content)} content blocks"
                    )

            elif isinstance(event.root, ErrorEvent):
                logger.warning(f"Error event received: {event.root.error.message}")

            # Yield the event without modification
            yield event

        if context.collected_message:
            logger.debug(
                f"Collected message:\n{context.collected_message.model_dump()}"
            )

    def _apply_delta(self, content_block: ContentBlock, delta: Delta) -> None:
        """Apply a delta to a content block."""
        if isinstance(delta, TextDelta):
            if isinstance(content_block, TextContent):
                content_block.text += delta.text
        elif isinstance(delta, ThinkingDelta):
            if isinstance(content_block, ThinkingContent):
                content_block.thinking += delta.thinking
        elif isinstance(delta, InputJsonDelta):
            if isinstance(content_block, (ToolUseContent, ServerToolUseContent)):
                if hasattr(content_block, "input_json"):
                    content_block.input_json += delta.partial_json
                else:
                    content_block.input_json = delta.partial_json
            if isinstance(content_block, ToolResultContent):
                if hasattr(content_block, "content_json"):
                    content_block.content_json += delta.partial_json
                else:
                    content_block.content_json = delta.partial_json
</file>

<file path="app/processors/claude_ai/model_injector_processor.py">
from typing import AsyncIterator
from loguru import logger

from app.processors.base import BaseProcessor
from app.processors.claude_ai import ClaudeAIContext
from app.models.streaming import (
    MessageStartEvent,
    StreamingEvent,
)


class ModelInjectorProcessor(BaseProcessor):
    """Processor that injects model information when it's missing from MessageStartEvent."""

    async def process(self, context: ClaudeAIContext) -> ClaudeAIContext:
        """
        Intercept MessageStartEvent and add model information if missing.

        Requires:
            - event_stream in context
            - messages_api_request in context (for model information)

        Produces:
            - event_stream with updated MessageStartEvent containing model
        """
        if not context.event_stream:
            logger.warning(
                "Skipping ModelInjectorProcessor due to missing event_stream"
            )
            return context

        if not context.messages_api_request:
            logger.warning(
                "Skipping ModelInjectorProcessor due to missing messages_api_request"
            )
            return context

        logger.debug("Setting up model injection for stream")

        original_stream = context.event_stream
        new_stream = self._inject_model_generator(original_stream, context)
        context.event_stream = new_stream

        return context

    async def _inject_model_generator(
        self,
        event_stream: AsyncIterator[StreamingEvent],
        context: ClaudeAIContext,
    ) -> AsyncIterator[StreamingEvent]:
        """
        Generator that adds model to MessageStartEvent if missing.
        """
        # Get model from request
        model = context.messages_api_request.model

        async for event in event_stream:
            if isinstance(event.root, MessageStartEvent):
                # Check if model is missing or empty
                if not event.root.message.model:
                    event.root.message.model = model
                    logger.debug(f"Injected model '{model}' into MessageStartEvent")
                else:
                    logger.debug(
                        f"MessageStartEvent already has model: '{event.root.message.model}'"
                    )

            yield event
</file>

<file path="app/processors/claude_ai/stop_sequences_processor.py">
from typing import AsyncIterator, List
from loguru import logger

from app.processors.base import BaseProcessor
from app.processors.claude_ai import ClaudeAIContext
from app.models.streaming import (
    StreamingEvent,
    ContentBlockDeltaEvent,
    ContentBlockStopEvent,
    MessageDeltaEvent,
    MessageStopEvent,
    MessageDeltaData,
    TextDelta,
)
from app.services.session import session_manager


class StopSequencesProcessor(BaseProcessor):
    """Processor that handles stop sequences in streaming responses."""

    async def process(self, context: ClaudeAIContext) -> ClaudeAIContext:
        """
        Process streaming events to detect and handle stop sequences.

        Requires:
            - event_stream in context
            - messages_api_request in context (for stop_sequences)

        Produces:
            - Modified event_stream that stops when a stop sequence is detected
            - Injects MessageDelta and MessageStop events when stop sequence found
        """
        if not context.event_stream:
            logger.warning(
                "Skipping StopSequencesProcessor due to missing event_stream"
            )
            return context

        if not context.messages_api_request:
            logger.warning(
                "Skipping StopSequencesProcessor due to missing messages_api_request"
            )
            return context

        stop_sequences = context.messages_api_request.stop_sequences
        if not stop_sequences:
            logger.debug("No stop sequences configured, skipping processor")
            return context

        logger.debug(f"Setting up stop sequences processing for: {stop_sequences}")

        original_stream = context.event_stream
        new_stream = self._process_stop_sequences(
            original_stream, stop_sequences, context
        )
        context.event_stream = new_stream

        return context

    async def _process_stop_sequences(
        self,
        event_stream: AsyncIterator[StreamingEvent],
        stop_sequences: List[str],
        context: ClaudeAIContext,
    ) -> AsyncIterator[StreamingEvent]:
        """
        Process events and stop when a stop sequence is detected.
        Uses incremental matching with buffering.
        """
        stop_sequences_set = set(stop_sequences)

        buffer = ""
        current_index = 0

        # Track potential matches: (start_position, current_matched_text)
        potential_matches = []

        async for event in event_stream:
            if isinstance(event.root, ContentBlockDeltaEvent) and isinstance(
                event.root.delta, TextDelta
            ):
                text = event.root.delta.text
                current_index = event.root.index

                for char in text:
                    buffer += char
                    current_pos = len(buffer) - 1

                    potential_matches.append((current_pos, ""))

                    new_matches = []
                    for start_pos, matched_text in potential_matches:
                        extended_match = matched_text + char

                        could_match = False
                        for stop_seq in stop_sequences:
                            if stop_seq.startswith(extended_match):
                                could_match = True
                                break

                        if could_match:
                            new_matches.append((start_pos, extended_match))

                            if extended_match in stop_sequences_set:
                                logger.debug(
                                    f"Stop sequence detected: '{extended_match}'"
                                )

                                safe_text = buffer[:start_pos]

                                if safe_text:
                                    yield StreamingEvent(
                                        root=ContentBlockDeltaEvent(
                                            type="content_block_delta",
                                            index=current_index,
                                            delta=TextDelta(
                                                type="text_delta", text=safe_text
                                            ),
                                        )
                                    )

                                yield StreamingEvent(
                                    root=ContentBlockStopEvent(
                                        type="content_block_stop", index=current_index
                                    )
                                )

                                yield StreamingEvent(
                                    root=MessageDeltaEvent(
                                        type="message_delta",
                                        delta=MessageDeltaData(
                                            stop_reason="stop_sequence",
                                            stop_sequence=extended_match,
                                        ),
                                        usage=None,
                                    )
                                )

                                yield StreamingEvent(
                                    root=MessageStopEvent(type="message_stop")
                                )

                                if context.claude_session:
                                    await session_manager.remove_session(
                                        context.claude_session.session_id
                                    )

                                return

                    potential_matches = new_matches

                    if potential_matches:
                        earliest_start = min(
                            start_pos for start_pos, _ in potential_matches
                        )
                        safe_length = earliest_start
                    else:
                        safe_length = len(buffer)

                    if safe_length > 0:
                        safe_text = buffer[:safe_length]
                        yield StreamingEvent(
                            root=ContentBlockDeltaEvent(
                                type="content_block_delta",
                                index=current_index,
                                delta=TextDelta(type="text_delta", text=safe_text),
                            )
                        )

                        buffer = buffer[safe_length:]
                        new_matches = []
                        for start_pos, matched_text in potential_matches:
                            new_start = start_pos - safe_length
                            if new_start >= 0:
                                new_matches.append((new_start, matched_text))
                        potential_matches = new_matches

            else:
                # Non-text event - flush buffer and reset
                if buffer:
                    yield StreamingEvent(
                        root=ContentBlockDeltaEvent(
                            type="content_block_delta",
                            index=current_index,
                            delta=TextDelta(type="text_delta", text=buffer),
                        )
                    )
                    buffer = ""
                    potential_matches = []

                yield event
</file>

<file path="app/processors/claude_ai/streaming_response_processor.py">
from loguru import logger

from fastapi.responses import StreamingResponse

from app.processors.base import BaseProcessor
from app.processors.claude_ai import ClaudeAIContext
from app.services.event_processing.event_serializer import EventSerializer


class StreamingResponseProcessor(BaseProcessor):
    """Processor that serializes event streams and creates a StreamingResponse."""

    def __init__(self):
        super().__init__()
        self.serializer = EventSerializer()

    async def process(self, context: ClaudeAIContext) -> ClaudeAIContext:
        """
        Serialize the event_stream and create a StreamingResponse.

        Requires:
            - event_stream in context

        Produces:
            - response in context

        This processor typically marks the end of the pipeline by returning STOP action.
        """
        if context.response:
            logger.debug("Skipping StreamingResponseProcessor due to existing response")
            return context

        if not context.event_stream:
            logger.warning(
                "Skipping StreamingResponseProcessor due to missing event_stream"
            )
            return context

        if (
            not context.messages_api_request
            or context.messages_api_request.stream is not True
        ):
            logger.debug(
                "Skipping StreamingResponseProcessor due to non-streaming request"
            )
            return context

        logger.info("Creating streaming response from event stream")

        sse_stream = self.serializer.serialize_stream(context.event_stream)

        context.response = StreamingResponse(
            sse_stream,
            media_type="text/event-stream",
            headers={
                "Cache-Control": "no-cache",
                "Connection": "keep-alive",
                "X-Accel-Buffering": "no",  # Disable nginx buffering
            },
        )

        return context
</file>

<file path="app/processors/claude_ai/tavern_test_message_processor.py">
from loguru import logger
import uuid

from fastapi.responses import JSONResponse

from app.processors.base import BaseProcessor
from app.processors.claude_ai import ClaudeAIContext
from app.models.claude import (
    Message,
    Role,
    TextContent,
    Usage,
)


class TestMessageProcessor(BaseProcessor):
    """Processor that handles test messages."""

    async def process(self, context: ClaudeAIContext) -> ClaudeAIContext:
        """
        Check if this is a test message and respond immediately if so.

        Test message criteria:
        - Only one message in messages array
        - Message role is "user"
        - Message content is "Hi"
        - stream is False

        If it's a test message, creates a MessagesAPIResponse and stops the pipeline.
        """
        if not context.messages_api_request:
            return context

        request = context.messages_api_request

        if (
            len(request.messages) == 1
            and request.messages[0].role == Role.USER
            and request.stream is False
            and (
                (
                    isinstance(request.messages[0].content, str)
                    and request.messages[0].content == "Hi"
                )
                or (
                    isinstance(request.messages[0].content, list)
                    and len(request.messages[0].content) == 1
                    and isinstance(request.messages[0].content[0], TextContent)
                    and request.messages[0].content[0].text == "Hi"
                )
            )
        ):
            logger.debug("Test message detected, returning canned response")

            response = Message(
                id=f"msg_{uuid.uuid4().hex[:10]}",
                type="message",
                role="assistant",
                content=[
                    TextContent(type="text", text="Hello! How can I assist you today?")
                ],
                model=request.model,
                stop_reason="end_turn",
                stop_sequence=None,
                usage=Usage(input_tokens=1, output_tokens=9),
            )

            context.response = JSONResponse(
                content=response.model_dump(), status_code=200
            )

            context.metadata["stop_pipeline"] = True
            return context

        return context
</file>

<file path="app/processors/claude_ai/token_counter_processor.py">
from typing import AsyncIterator
from loguru import logger
import tiktoken

from app.processors.base import BaseProcessor
from app.processors.claude_ai import ClaudeAIContext
from app.models.streaming import (
    MessageStartEvent,
    StreamingEvent,
    MessageDeltaEvent,
)
from app.models.claude import Usage
from app.utils.messages import process_messages

encoder = tiktoken.get_encoding("cl100k_base")


class TokenCounterProcessor(BaseProcessor):
    """Processor that estimates token usage when it's not provided by the API."""

    async def process(self, context: ClaudeAIContext) -> ClaudeAIContext:
        """
        Intercept MessageDeltaEvent and add token usage estimation if missing.

        Requires:
            - event_stream in context
            - messages_api_request in context (for input token counting)
            - collected_message in context (for output token counting)

        Produces:
            - event_stream with updated MessageDeltaEvent containing usage
        """
        if not context.event_stream:
            logger.warning("Skipping TokenCounterProcessor due to missing event_stream")
            return context

        if not context.messages_api_request:
            logger.warning(
                "Skipping TokenCounterProcessor due to missing messages_api_request"
            )
            return context

        logger.debug("Setting up token counting for stream")

        original_stream = context.event_stream
        new_stream = self._count_tokens_generator(original_stream, context)
        context.event_stream = new_stream

        return context

    async def _count_tokens_generator(
        self,
        event_stream: AsyncIterator[StreamingEvent],
        context: ClaudeAIContext,
    ) -> AsyncIterator[StreamingEvent]:
        """
        Generator that adds token usage to MessageDeltaEvent if missing.
        """
        # Pre-calculate input tokens once
        input_tokens = await self._calculate_input_tokens(context)

        async for event in event_stream:
            if (
                isinstance(event.root, MessageStartEvent)
                and not event.root.message.usage
            ):
                usage = Usage(
                    input_tokens=input_tokens,
                    output_tokens=1,
                    cache_creation_input_tokens=0,
                    cache_read_input_tokens=0,
                )

                event.root.message.usage = usage
                context.collected_message.usage = usage

                logger.debug(f"Added token usage estimation: input={input_tokens}")

            if isinstance(event.root, MessageDeltaEvent) and not event.root.usage:
                output_tokens = await self._calculate_output_tokens(context)

                usage = Usage(
                    input_tokens=input_tokens,
                    output_tokens=output_tokens,
                    cache_creation_input_tokens=0,
                    cache_read_input_tokens=0,
                )

                event.root.usage = usage
                context.collected_message.usage = usage

                logger.debug(
                    f"Added token usage estimation: input={input_tokens}, output={output_tokens}"
                )

            yield event

    async def _calculate_input_tokens(self, context: ClaudeAIContext) -> int:
        """Calculate input tokens from the request messages."""
        if not context.messages_api_request:
            return 0

        merged_text, _ = await process_messages(
            context.messages_api_request.messages, context.messages_api_request.system
        )

        try:
            tokens = len(encoder.encode(merged_text, disallowed_special=()))
        except Exception:
            logger.warning("Tiktoken encoding failed for input, falling back to estimation")
            tokens = len(merged_text) // 4

        logger.debug(f"Calculated {tokens} input tokens")
        return tokens

    async def _calculate_output_tokens(self, context: ClaudeAIContext) -> int:
        """Calculate output tokens from the collected message."""
        if not context.collected_message:
            return 0

        merged_text, _ = await process_messages([context.collected_message])

        try:
            tokens = len(encoder.encode(merged_text, disallowed_special=()))
        except Exception:
            logger.warning("Tiktoken encoding failed for output, falling back to estimation")
            tokens = len(merged_text) // 4

        logger.debug(f"Calculated {tokens} output tokens")
        return tokens
</file>

<file path="app/services/event_processing/event_parser.py">
import json
from typing import AsyncIterator, Optional
from dataclasses import dataclass
from loguru import logger

from pydantic import ValidationError

from app.models.streaming import (
    StreamingEvent,
    UnknownEvent,
)


@dataclass
class SSEMessage:
    event: Optional[str] = None
    data: Optional[str] = None


class EventParser:
    """Parses SSE (Server-Sent Events) streams into StreamingEvent objects."""

    def __init__(self, skip_unknown_events: bool = True):
        self.skip_unknown_events = skip_unknown_events
        self.buffer = ""

    async def parse_stream(
        self, stream: AsyncIterator[str]
    ) -> AsyncIterator[StreamingEvent]:
        """
        Parse an SSE stream and yield StreamingEvent objects.

        Args:
            stream: AsyncIterator that yields string chunks from the SSE stream

        Yields:
            StreamingEvent objects parsed from the stream
        """
        async for chunk in stream:
            chunk = chunk.replace('\r\n', '\n') # Normalize line endings
            self.buffer += chunk

            async for event in self._process_buffer():
                logger.debug(f"Parsed event:\n{event.model_dump()}")
                yield event

        async for event in self.flush():
            yield event

    async def _process_buffer(self) -> AsyncIterator[StreamingEvent]:
        """Process the buffer and yield complete SSE messages as StreamingEvent objects."""
        while "\n\n" in self.buffer:
            message_end = self.buffer.index("\n\n")
            message_text = self.buffer[:message_end]
            self.buffer = self.buffer[message_end + 2 :]

            sse_msg = self._parse_sse_message(message_text)

            if sse_msg.data:
                event = self._create_streaming_event(sse_msg)
                if event:
                    yield event

    def _parse_sse_message(self, message_text: str) -> SSEMessage:
        """Parse a single SSE message from text."""
        sse_msg = SSEMessage()

        for line in message_text.split("\n"):
            if not line:
                continue

            if ":" not in line:
                field = line
                value = ""
            else:
                field, value = line.split(":", 1)
                if value.startswith(" "):
                    value = value[1:]

            if field == "event":
                sse_msg.event = value
            elif field == "data":
                if sse_msg.data is None:
                    sse_msg.data = value
                else:
                    sse_msg.data += "\n" + value

        return sse_msg

    def _create_streaming_event(self, sse_msg: SSEMessage) -> Optional[StreamingEvent]:
        """
        Create a StreamingEvent from an SSE message.

        Args:
            sse_msg: The parsed SSE message

        Returns:
            StreamingEvent object or None if parsing fails
        """
        try:
            data = json.loads(sse_msg.data)

        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse JSON data: {e}")
            logger.debug(f"Raw data: {sse_msg.data}")
            return None

        try:
            streaming_event = StreamingEvent(root=data)
        except ValidationError:
            if self.skip_unknown_events:
                logger.debug(f"Skipping unknown event: {sse_msg.event}")
                return None
            logger.warning(
                "Failed to validate streaming event. Falling back to UnknownEvent."
            )
            logger.debug(f"Event data: {data}")
            streaming_event = StreamingEvent(
                root=UnknownEvent(type=sse_msg.event, data=data)
            )

        return streaming_event

    async def flush(self) -> AsyncIterator[StreamingEvent]:
        """
        Flush any remaining data in the buffer.

        This should be called when the stream ends to process any incomplete messages.

        Yields:
            Any remaining StreamingEvent objects
        """
        if self.buffer.strip():
            logger.warning(f"Flushing incomplete buffer: {self.buffer[:100]}...")

            self.buffer += "\n\n"

            async for event in self._process_buffer():
                yield event
</file>

<file path="app/services/i18n.py">
import json
import re
from typing import Dict, Any, Optional
from loguru import logger

from app.core.config import settings


class I18nService:
    """
    Internationalization service for loading and managing translations.
    Supports message interpolation with context variables.
    """

    def __init__(self):
        self._translations: Dict[str, Dict[str, Any]] = {}
        self._default_language = settings.default_language
        self._locales_dir = settings.locales_folder
        self._load_translations()

    def _load_translations(self) -> None:
        """Load all translation files from the locales directory."""
        if not self._locales_dir.exists():
            logger.warning(f"Locales directory not found: {self._locales_dir}")
            return

        for file_path in self._locales_dir.glob("*.json"):
            language_code = file_path.stem
            try:
                with open(file_path, "r", encoding="utf-8") as f:
                    self._translations[language_code] = json.load(f)
                logger.info(f"Loaded translations for language: {language_code}")
            except Exception as e:
                logger.error(f"Failed to load translations for {language_code}: {e}")

    def _get_nested_value(self, data: Dict[str, Any], key: str) -> Optional[str]:
        """
        Get a nested value from a dictionary using dot notation.
        Example: 'global.internalServerError' -> data['global']['internalServerError']
        """
        keys = key.split(".")
        current = data

        for k in keys:
            if isinstance(current, dict) and k in current:
                current = current[k]
            else:
                return None

        return current if isinstance(current, str) else None

    def _interpolate_message(self, message: str, context: Dict[str, Any]) -> str:
        """
        Interpolate context variables into the message.
        Supports {variable_name} syntax.
        """
        if not context:
            return message

        # Use regex to find all {variable_name} patterns and replace them
        def replace_var(match):
            var_name = match.group(1)
            return str(context.get(var_name, match.group(0)))

        return re.sub(r"\{([^}]+)\}", replace_var, message)

    def get_message(
        self,
        message_key: str,
        language: str = None,
        context: Optional[Dict[str, Any]] = None,
    ) -> str:
        """
        Get a translated message by key and language.

        Args:
            message_key: The message key in dot notation (e.g., 'global.internalServerError')
            language: The language code (defaults to default language)
            context: Context variables for message interpolation

        Returns:
            The translated and interpolated message
        """
        if language is None:
            language = self._default_language

        if language in self._translations:
            message = self._get_nested_value(self._translations[language], message_key)
            if message:
                return self._interpolate_message(message, context or {})

        if (
            language != self._default_language
            and self._default_language in self._translations
        ):
            message = self._get_nested_value(
                self._translations[self._default_language], message_key
            )
            if message:
                return self._interpolate_message(message, context or {})

        logger.warning(
            f"Translation not found for key '{message_key}' in language '{language}'"
        )
        return message_key

    def parse_accept_language(self, accept_language: Optional[str]) -> str:
        """
        Parse Accept-Language header and return the best matching language.

        Args:
            accept_language: The Accept-Language header value

        Returns:
            The best matching language code
        """
        if not accept_language:
            return self._default_language
        languages = []
        for lang_part in accept_language.split(","):
            lang_part = lang_part.strip()
            if ";" in lang_part:
                lang, quality = lang_part.split(";", 1)
                try:
                    q = float(quality.split("=")[1])
                except (IndexError, ValueError):
                    q = 1.0
            else:
                lang = lang_part
                q = 1.0

            primary_lang = lang.split("-")[0].lower()
            languages.append((primary_lang, q))

        languages.sort(key=lambda x: x[1], reverse=True)

        for lang, _ in languages:
            if lang in self._translations:
                return lang

        return self._default_language

    def get_supported_languages(self) -> list[str]:
        """Get list of supported language codes."""
        return list(self._translations.keys())

    def reload_translations(self) -> None:
        """Reload all translation files."""
        self._translations.clear()
        self._load_translations()


i18n_service = I18nService()
</file>

<file path="app/utils/logger.py">
import sys
from pathlib import Path
from loguru import logger

from app.core.config import settings


def configure_logger():
    """Initialize the logger with console and optional file output."""
    logger.remove()

    logger.add(
        sys.stdout,
        level=settings.log_level.upper(),
        colorize=True,
    )

    if settings.log_to_file:
        log_file = Path(settings.log_file_path)
        log_file.parent.mkdir(parents=True, exist_ok=True)

        logger.add(
            settings.log_file_path,
            level=settings.log_level.upper(),
            rotation=settings.log_file_rotation,
            retention=settings.log_file_retention,
            compression=settings.log_file_compression,
            enqueue=True,
            encoding="utf-8",
        )
</file>

<file path="app/utils/messages.py">
import base64
from typing import List, Optional, Tuple
from loguru import logger

from app.core.http_client import download_image
from app.core.config import settings
from app.core.exceptions import ExternalImageDownloadError, ExternalImageNotAllowedError
from app.models.claude import (
    ImageType,
    InputMessage,
    Role,
    ServerToolUseContent,
    TextContent,
    ImageContent,
    ThinkingContent,
    ToolResultContent,
    ToolUseContent,
    URLImageSource,
    Base64ImageSource,
)


async def process_messages(
    messages: List[InputMessage], system: Optional[str | List[TextContent]] = None
) -> Tuple[str, List[Base64ImageSource]]:
    if isinstance(system, str):
        merged_text = system
    elif system:
        merged_text = "\n".join(item.text for item in system)
    else:
        merged_text = ""

    if settings.use_real_roles:
        human_prefix = f"\x08{settings.human_name}: "
        assistant_prefix = f"\x08{settings.assistant_name}: "
    else:
        human_prefix = f"{settings.human_name}: "
        assistant_prefix = f"{settings.assistant_name}: "

    images: List[Base64ImageSource] = []
    current_role = Role.USER

    for message in messages:
        if message.role != current_role:
            if merged_text.endswith("\n"):
                merged_text = merged_text[:-1]

            if message.role == Role.USER:
                merged_text += f"\n\n{human_prefix}"
            elif message.role == Role.ASSISTANT:
                merged_text += f"\n\n{assistant_prefix}"

        current_role = message.role

        if isinstance(message.content, str):
            merged_text += f"{message.content}\n"
        else:
            for block in message.content:
                if isinstance(block, TextContent):
                    merged_text += f"{block.text}\n"
                elif isinstance(block, ThinkingContent):
                    merged_text += f"<\x08antml:thinking>\n{block.thinking}\n</\x08antml:thinking>\n"
                elif isinstance(block, ToolUseContent) or isinstance(
                    block, ServerToolUseContent
                ):
                    merged_text += f'<\x08antml:function_calls>\n<\x08antml:invoke name="{block.name}">\n'
                    for key, value in block.input.items():
                        merged_text += f'<\x08antml:parameter name="{key}">{value}</\x08antml:parameter>\n'
                    merged_text += "</\x08antml:invoke>\n</\x08antml:function_calls>\n"
                elif isinstance(block, ToolResultContent):
                    text_content = ""
                    if isinstance(block.content, str):
                        text_content = f"{block.content}"
                    else:
                        for content_block in block.content:
                            if isinstance(content_block, TextContent):
                                text_content += f"{content_block.text}\n"
                            elif isinstance(content_block, ImageContent):
                                if isinstance(content_block.source, Base64ImageSource):
                                    images.append(content_block.source)
                                elif isinstance(content_block.source, URLImageSource):
                                    image_source = await extract_image_from_url(
                                        content_block.source.url
                                    )
                                    if image_source:
                                        images.append(image_source)
                                        text_content += "(image attached)\n"
                            if text_content.endswith("\n"):
                                text_content = text_content[:-1]
                    merged_text += (
                        f"<function_results>{text_content}</function_results>"
                    )
                elif isinstance(block, ImageContent):
                    if isinstance(block.source, Base64ImageSource):
                        images.append(block.source)
                    elif isinstance(block.source, URLImageSource):
                        image_source = await extract_image_from_url(block.source.url)
                        if image_source:
                            images.append(image_source)

        if merged_text.endswith("\n"):
            merged_text = merged_text[:-1]

    return (merged_text, images)


async def extract_image_from_url(url: str) -> Optional[Base64ImageSource]:
    """Extract base64 image from data URL or download from external URL."""

    if url.startswith("data:"):
        try:
            metadata, base64_data = url.split(",", 1)
            media_info = metadata[5:]
            media_type, encoding = media_info.split(";", 1)

            return Base64ImageSource(
                type=encoding, media_type=media_type, data=base64_data
            )
        except Exception:
            logger.warning("Failed to extract image from data URL. Skipping image.")
            return None

    elif settings.allow_external_images and (
        url.startswith("http://") or url.startswith("https://")
    ):
        try:
            logger.debug(f"Downloading external image: {url}")

            content, content_type = await download_image(
                url, timeout=settings.request_timeout
            )
            base64_data = base64.b64encode(content).decode("utf-8")

            return Base64ImageSource(
                type="base64", media_type=ImageType(content_type), data=base64_data
            )
        except Exception:
            raise ExternalImageDownloadError(url)

    elif not settings.allow_external_images and (
        url.startswith("http://") or url.startswith("https://")
    ):
        raise ExternalImageNotAllowedError(url)
    else:
        logger.warning(f"Unsupported URL format: {url}, Skipping image.")
        return None
</file>

<file path="app/utils/retry.py">
from loguru import logger
from tenacity import RetryCallState

from app.core.exceptions import AppError


def is_retryable_error(exception):
    """Check if the exception is an AppError with retryable=True"""
    return isinstance(exception, AppError) and exception.retryable


def log_before_sleep(retry_state: RetryCallState) -> None:
    """Custom before_sleep callback that safely logs retry attempts."""
    attempt_number = retry_state.attempt_number
    exception = retry_state.outcome.exception() if retry_state.outcome else None

    if exception:
        exception_type = type(exception).__name__
        logger.warning(
            f"Retrying {retry_state.fn.__name__} after attempt {attempt_number} "
            f"due to {exception_type}: {str(exception)}"
        )

    else:
        logger.warning(
            f"Retrying {retry_state.fn.__name__} after attempt {attempt_number}"
        )
</file>

<file path="front/package.json">
{
    "name": "clove-front",
    "private": true,
    "version": "0.0.0",
    "type": "module",
    "scripts": {
        "dev": "vite",
        "build": "tsc -b && vite build",
        "lint": "eslint .",
        "preview": "vite preview"
    },
    "dependencies": {
        "@radix-ui/react-alert-dialog": "^1.1.14",
        "@radix-ui/react-collapsible": "^1.1.11",
        "@radix-ui/react-dialog": "^1.1.14",
        "@radix-ui/react-dropdown-menu": "^2.1.15",
        "@radix-ui/react-label": "^2.1.7",
        "@radix-ui/react-progress": "^1.1.7",
        "@radix-ui/react-select": "^2.2.5",
        "@radix-ui/react-separator": "^1.1.7",
        "@radix-ui/react-slot": "^1.2.3",
        "@radix-ui/react-switch": "^1.2.5",
        "@radix-ui/react-tooltip": "^1.2.7",
        "@tailwindcss/vite": "^4.1.11",
        "axios": "^1.10.0",
        "class-variance-authority": "^0.7.1",
        "clsx": "^2.1.1",
        "i18next": "^25.8.13",
        "i18next-browser-languagedetector": "^8.2.1",
        "lucide-react": "^0.525.0",
        "next-themes": "^0.4.6",
        "react": "^19.1.0",
        "react-dom": "^19.1.0",
        "react-i18next": "^16.5.4",
        "react-router-dom": "^7.6.3",
        "sonner": "^2.0.6",
        "tailwind-merge": "^3.3.1",
        "tailwindcss": "^4.1.11",
        "vaul": "^1.1.2"
    },
    "devDependencies": {
        "@eslint/js": "^9.29.0",
        "@types/node": "^24.0.10",
        "@types/react": "^19.1.8",
        "@types/react-dom": "^19.1.6",
        "@vitejs/plugin-react": "^4.5.2",
        "eslint": "^9.29.0",
        "eslint-plugin-react-hooks": "^5.2.0",
        "eslint-plugin-react-refresh": "^0.4.20",
        "globals": "^16.2.0",
        "tw-animate-css": "^1.3.5",
        "typescript": "~5.8.3",
        "typescript-eslint": "^8.34.1",
        "vite": "^7.0.0"
    },
    "packageManager": "pnpm@10.12.1+sha512.f0dda8580f0ee9481c5c79a1d927b9164f2c478e90992ad268bbb2465a736984391d6333d2c327913578b2804af33474ca554ba29c04a8b13060a717675ae3ac"
}
</file>

<file path="front/src/api/client.ts">
import axios from 'axios'
import { toast } from 'sonner'
import i18n from '../i18n/i18n-config'
import type {
    AccountResponse,
    AccountCreate,
    AccountUpdate,
    OAuthCodeExchange,
    SettingsRead,
    SettingsUpdate,
    StatisticsResponse,
} from './types'

const api = axios.create({
    headers: {
        'Content-Type': 'application/json',
    },
})

// Request interceptor to attach admin key from local storage
api.interceptors.request.use(config => {
    const adminKey = localStorage.getItem('adminKey')
    if (adminKey) {
        config.headers['X-API-Key'] = adminKey
    }
    return config
})

// Response interceptor to handle global errors
api.interceptors.response.use(
    response => response,
    error => {
        // Handle session expiry - redirect to login
        if (error.response?.data?.detail?.code === 401011) {
            localStorage.removeItem('adminKey')
            if (window.location.pathname !== '/login') {
                window.location.href = '/login'
            }
            return Promise.reject(error)
        }

        // Attempt to extract error message from detail.message field
        const errorMessage = error.response?.data?.detail?.message || i18n.t('common.unknownError')

        toast.error(errorMessage)

        // Re-throw error so component layer can handle it further
        return Promise.reject(error)
    },
)

// Account-related API
export const accountsApi = {
    list: () => api.get<AccountResponse[]>('/api/admin/accounts'),
    get: (organizationUuid: string) => api.get<AccountResponse>(`/api/admin/accounts/${organizationUuid}`),
    create: (account: AccountCreate) => api.post<AccountResponse>('/api/admin/accounts', account),
    update: (organizationUuid: string, account: AccountUpdate) =>
        api.put<AccountResponse>(`/api/admin/accounts/${organizationUuid}`, account),
    delete: (organizationUuid: string) => api.delete(`/api/admin/accounts/${organizationUuid}`),
    exchangeOAuthCode: (exchangeData: OAuthCodeExchange) =>
        api.post<AccountResponse>('/api/admin/accounts/oauth/exchange', exchangeData),
}

// Settings-related API
export const settingsApi = {
    get: () => api.get<SettingsRead>('/api/admin/settings'),
    update: (settings: SettingsUpdate) => api.put<SettingsUpdate>('/api/admin/settings', settings),
}

// Health check
export const healthApi = {
    check: () => api.get('/health'),
}

// Statistics API
export const statisticsApi = {
    get: () => api.get<StatisticsResponse>('/api/admin/statistics'),
}
</file>

<file path="front/src/components/BatchCookieModal.tsx">
import { useState } from 'react'
import { useTranslation } from 'react-i18next'
import { Loader2, AlertCircle, CheckCircle, Cookie, FileText, Copy, Check } from 'lucide-react'
import { accountsApi } from '../api/client'
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from '@/components/ui/dialog'
import { Drawer, DrawerContent, DrawerDescription, DrawerFooter, DrawerHeader, DrawerTitle } from '@/components/ui/drawer'
import { Button } from '@/components/ui/button'
import { Label } from '@/components/ui/label'
import { Textarea } from '@/components/ui/textarea'
import { Alert, AlertDescription } from '@/components/ui/alert'
import { Progress } from '@/components/ui/progress'
import { useIsMobile } from '@/hooks/use-mobile'
import { toast } from 'sonner'
import type { AccountCreate } from '../api/types'

interface BatchCookieModalProps {
    onClose: () => void
}

interface CookieResult {
    cookie: string
    status: 'pending' | 'processing' | 'success' | 'error'
    error?: string
    organizationUuid?: string
}

export function BatchCookieModal({ onClose }: BatchCookieModalProps) {
    const { t } = useTranslation()
    const [cookies, setCookies] = useState('')
    const [isProcessing, setIsProcessing] = useState(false)
    const [results, setResults] = useState<CookieResult[]>([])
    const [showResults, setShowResults] = useState(false)
    const isMobile = useIsMobile()

    const validateAndProcessCookie = (cookieValue: string): { isValid: boolean; processedValue: string } => {
        let processedValue = cookieValue.trim()

        if (processedValue.startsWith('sk-ant-sid01-')) {
            processedValue = `sessionKey=${processedValue}`
        }

        const isValid = processedValue.startsWith('sessionKey=sk-ant-sid01-')

        return { isValid, processedValue }
    }

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault()

        const cookieLines = cookies
            .split('\n')
            .map(line => line.trim())
            .filter(line => line.length > 0)

        if (cookieLines.length === 0) {
            return
        }

        setIsProcessing(true)
        setShowResults(true)

        const initialResults: CookieResult[] = cookieLines.map(cookie => ({
            cookie,
            status: 'pending',
        }))
        setResults(initialResults)

        for (let i = 0; i < cookieLines.length; i++) {
            const cookie = cookieLines[i]

            setResults(prev => {
                const updated = [...prev]
                updated[i] = { ...updated[i], status: 'processing' }
                return updated
            })

            try {
                const { isValid, processedValue } = validateAndProcessCookie(cookie)

                if (!isValid) {
                    setResults(prev => {
                        const updated = [...prev]
                        updated[i] = {
                            ...updated[i],
                            status: 'error',
                            error: t('batchModal.invalidFormat'),
                        }
                        return updated
                    })
                    continue
                }

                const createData: AccountCreate = {
                    cookie_value: processedValue,
                }

                const response = await accountsApi.create(createData)

                setResults(prev => {
                    const updated = [...prev]
                    updated[i] = {
                        ...updated[i],
                        status: 'success',
                        organizationUuid: response.data.organization_uuid,
                    }
                    return updated
                })
            } catch (error: any) {
                const errorMessage = error.response?.data?.detail?.message || t('batchModal.addFailed')

                setResults(prev => {
                    const updated = [...prev]
                    updated[i] = {
                        ...updated[i],
                        status: 'error',
                        error: errorMessage,
                    }
                    return updated
                })
            }

            // Small delay to avoid rate limiting
            await new Promise(resolve => setTimeout(resolve, 300))
        }

        setIsProcessing(false)
    }

    const getProgress = () => {
        if (results.length === 0) return 0
        const processed = results.filter(r => r.status === 'success' || r.status === 'error').length
        return (processed / results.length) * 100
    }

    const getSuccessCount = () => results.filter(r => r.status === 'success').length
    const getErrorCount = () => results.filter(r => r.status === 'error').length

    const copyFailedCookies = async () => {
        const failedCookies = results
            .filter(r => r.status === 'error')
            .map(r => r.cookie)
            .join('\n')

        try {
            await navigator.clipboard.writeText(failedCookies)
            toast.success(t('batchModal.copiedFailed'), {
                icon: <Check className='h-4 w-4' />,
            })
        } catch (error) {
            console.error('Failed to copy:', error)
            toast.error(t('common.copyFailed'))
        }
    }

    const truncateCookie = (cookie: string, maxLength: number = 40) => {
        if (cookie.length <= maxLength) return cookie
        const start = cookie.substring(0, 20)
        const end = cookie.substring(cookie.length - 17)
        return `${start}...${end}`
    }

    const getStatusIcon = (status: CookieResult['status']) => {
        switch (status) {
            case 'success':
                return <CheckCircle className='h-4 w-4 text-green-500' />
            case 'error':
                return <AlertCircle className='h-4 w-4 text-red-500' />
            case 'processing':
                return <Loader2 className='h-4 w-4 animate-spin' />
            default:
                return <Cookie className='h-4 w-4 text-muted-foreground' />
        }
    }

    const handleClose = () => {
        if (isProcessing) return
        onClose()
    }

    const formContent = (
        <>
            {!showResults ? (
                <>
                    <div className='space-y-2'>
                        <Label htmlFor='cookies'>
                            {t('batchModal.cookieList')} <span className='text-destructive'>*</span>
                        </Label>
                        <Textarea
                            id='cookies'
                            placeholder={t('batchModal.placeholder')}
                            value={cookies}
                            onChange={e => setCookies(e.target.value)}
                            className='min-h-[200px] font-mono text-sm break-all'
                            required
                        />
                        <p className='text-sm text-muted-foreground'>{t('batchModal.supportedFormats')}</p>
                    </div>
                </>
            ) : (
                <div className='space-y-4'>
                    <div className='space-y-2'>
                        <div className='flex items-center justify-between'>
                            <Label>{t('batchModal.progress')}</Label>
                            <span className='text-sm text-muted-foreground'>
                                {t('batchModal.successCount', { success: getSuccessCount(), error: getErrorCount(), total: results.length })}
                            </span>
                        </div>
                        <Progress value={getProgress()} className='h-2' />
                    </div>

                    <div className='border rounded-lg max-h-[300px] overflow-y-auto'>
                        <div className='divide-y'>
                            {results.map((result, index) => (
                                <div key={index} className='p-3 flex items-start gap-3'>
                                    <div className='mt-0.5'>{getStatusIcon(result.status)}</div>
                                    <div className='flex-1 min-w-0'>
                                        <p className='font-mono text-xs' title={result.cookie}>
                                            {truncateCookie(result.cookie)}
                                        </p>
                                        {result.status === 'success' && result.organizationUuid && (
                                            <p className='text-xs text-muted-foreground mt-1'>
                                                UUID: {result.organizationUuid}
                                            </p>
                                        )}
                                        {result.status === 'error' && result.error && (
                                            <p className='text-xs text-destructive mt-1 break-words'>{result.error}</p>
                                        )}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>

                    {!isProcessing && (
                        <>
                            <Alert>
                                <FileText className='h-4 w-4' />
                                <AlertDescription>
                                    {getErrorCount() > 0
                                        ? t('batchModal.completeMessageWithErrors', { success: getSuccessCount(), error: getErrorCount() })
                                        : t('batchModal.completeMessage', { count: getSuccessCount() })}
                                </AlertDescription>
                            </Alert>
                            {getErrorCount() > 0 && (
                                <Button
                                    type='button'
                                    variant='outline'
                                    size='sm'
                                    className='w-full'
                                    onClick={copyFailedCookies}
                                >
                                    <Copy className='mr-2 h-4 w-4' />
                                    {t('batchModal.copyFailedCookies')}
                                </Button>
                            )}
                        </>
                    )}
                </div>
            )}
        </>
    )

    const footerContent = (
        <>
            {!showResults ? (
                <>
                    <Button type='button' variant='outline' onClick={handleClose}>
                        {t('common.cancel')}
                    </Button>
                    <Button type='submit' disabled={isProcessing || !cookies.trim()}>
                        {isProcessing && <Loader2 className='mr-2 h-4 w-4 animate-spin' />}
                        {t('batchModal.startAdding')}
                    </Button>
                </>
            ) : (
                <Button onClick={handleClose} disabled={isProcessing}>
                    {isProcessing ? t('common.processing') : t('common.done')}
                </Button>
            )}
        </>
    )

    if (isMobile === undefined) {
        return null
    }

    if (!isMobile) {
        return (
            <Dialog open={true} onOpenChange={handleClose}>
                <DialogContent className='sm:max-w-[600px]'>
                    <form onSubmit={handleSubmit}>
                        <DialogHeader>
                            <DialogTitle>{t('batchModal.title')}</DialogTitle>
                            <DialogDescription>{t('batchModal.desc')}</DialogDescription>
                        </DialogHeader>
                        <div className='py-4'>{formContent}</div>
                        <DialogFooter>{footerContent}</DialogFooter>
                    </form>
                </DialogContent>
            </Dialog>
        )
    }

    return (
        <Drawer open={true} onOpenChange={handleClose}>
            <DrawerContent>
                <form onSubmit={handleSubmit} className='max-h-[90vh] overflow-auto'>
                    <DrawerHeader>
                        <DrawerTitle>{t('batchModal.title')}</DrawerTitle>
                        <DrawerDescription>{t('batchModal.desc')}</DrawerDescription>
                    </DrawerHeader>
                    <div className='px-4 pb-4'>{formContent}</div>
                    <DrawerFooter className='flex-row justify-end space-x-2'>{footerContent}</DrawerFooter>
                </form>
            </DrawerContent>
        </Drawer>
    )
}
</file>

<file path="front/src/components/Layout.tsx">
import { Link, Outlet, useLocation } from 'react-router-dom'
import { Settings, Users, Home, LogOut, Languages } from 'lucide-react'
import { useTranslation } from 'react-i18next'
import { Button } from '@/components/ui/button'
import {
    Sidebar,
    SidebarContent,
    SidebarFooter,
    SidebarGroup,
    SidebarGroupContent,
    SidebarHeader,
    SidebarMenu,
    SidebarMenuButton,
    SidebarMenuItem,
    SidebarProvider,
    SidebarTrigger,
} from '@/components/ui/sidebar'

export function Layout() {
    const { t, i18n } = useTranslation()
    const location = useLocation()

    const navigation = [
        { name: t('layout.dashboard'), href: '/', icon: Home },
        { name: t('layout.accounts'), href: '/accounts', icon: Users },
        { name: t('layout.settings'), href: '/settings', icon: Settings },
    ]

    const handleLogout = () => {
        localStorage.removeItem('adminKey')
        window.location.href = '/login'
    }

    return (
        <SidebarProvider defaultOpen>
            <div className="flex h-screen w-full">
                <Sidebar variant="sidebar" collapsible="icon">
                    <SidebarHeader>
                        <SidebarMenu>
                            <SidebarMenuItem>
                                <SidebarMenuButton size="lg" className="w-full justify-center md:justify-start">
                                    <div className="flex items-center gap-2">
                                        <div className="flex h-8 w-8 items-center justify-center rounded-lg bg-primary">
                                            <span className="text-lg font-bold text-primary-foreground">C</span>
                                        </div>
                                        <span className="text-xl font-semibold">Clove</span>
                                    </div>
                                </SidebarMenuButton>
                            </SidebarMenuItem>
                        </SidebarMenu>
                    </SidebarHeader>
                    
                    <SidebarContent>
                        <SidebarGroup>
                            <SidebarGroupContent>
                                <SidebarMenu>
                                    {navigation.map((item) => {
                                        const isActive = location.pathname === item.href
                                        return (
                                            <SidebarMenuItem key={item.name}>
                                                <SidebarMenuButton asChild isActive={isActive}>
                                                    <Link to={item.href}>
                                                        <item.icon className="h-4 w-4" />
                                                        <span>{item.name}</span>
                                                    </Link>
                                                </SidebarMenuButton>
                                            </SidebarMenuItem>
                                        )
                                    })}
                                </SidebarMenu>
                            </SidebarGroupContent>
                        </SidebarGroup>
                    </SidebarContent>

                    <SidebarFooter>
                        <SidebarMenu>
                            <SidebarMenuItem>
                                <SidebarMenuButton onClick={handleLogout} className="w-full text-destructive hover:bg-destructive/10 hover:text-destructive">
                                    <LogOut className="h-4 w-4" />
                                    <span>{t('layout.logout')}</span>
                                </SidebarMenuButton>
                            </SidebarMenuItem>
                        </SidebarMenu>
                    </SidebarFooter>
                </Sidebar>

                <div className="flex flex-1 flex-col">
                    <header className="flex h-14 items-center gap-4 border-b px-6 lg:h-16">
                        <SidebarTrigger className="-ml-1" />
                        <div className="ml-auto flex items-center">
                            <Button variant="ghost" size="sm" onClick={() => {
                                i18n.changeLanguage(i18n.language.startsWith('zh') ? 'en' : 'zh')
                            }}>
                                <Languages className="h-4 w-4 mr-1" />
                                {i18n.language.startsWith('zh') ? 'EN' : ''}
                            </Button>
                        </div>
                    </header>
                    
                    <main className="flex-1 overflow-y-auto">
                        <div className="container mx-auto max-w-7xl p-6">
                            <Outlet />
                        </div>
                    </main>
                </div>
            </div>
        </SidebarProvider>
    )
}
</file>

<file path="front/src/components/OAuthModal.tsx">
import { useState } from 'react'
import { useTranslation } from 'react-i18next'
import { ExternalLink, Info, Loader2, AlertCircle } from 'lucide-react'
import { accountsApi } from '../api/client'
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from '@/components/ui/dialog'
import { Drawer, DrawerContent, DrawerDescription, DrawerFooter, DrawerHeader, DrawerTitle } from '@/components/ui/drawer'
import { Button } from '@/components/ui/button'
import { Label } from '@/components/ui/label'
import { Input } from '@/components/ui/input'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { Alert, AlertDescription } from '@/components/ui/alert'
import { useIsMobile } from '@/hooks/use-mobile'
import { isValidUUID, formatUUID } from '@/utils/validators'
import { cn } from '@/lib/utils'

interface OAuthModalProps {
    onClose: () => void
}

// Claude OAuth constants
const CLIENT_ID = '9d1c250a-e61b-44d9-88ed-5944d1962f5e'
const AUTHORIZE_URL = 'https://claude.ai/oauth/authorize'
const REDIRECT_URI = 'https://console.anthropic.com/oauth/code/callback'

export function OAuthModal({ onClose }: OAuthModalProps) {
    const { t } = useTranslation()
    const [organizationUuid, setOrganizationUuid] = useState('')
    const [accountType, setAccountType] = useState<'Pro' | 'Max'>('Pro')
    const [authCode, setAuthCode] = useState('')
    const [loading, setLoading] = useState(false)
    const [error, setError] = useState('')
    const [uuidError, setUuidError] = useState('')
    const [step, setStep] = useState<'input' | 'code'>('input')
    const [pkceVerifier, setPkceVerifier] = useState('')
    const isMobile = useIsMobile()

    // PKCE generation functions
    const generatePKCE = () => {
        // Generate random verifier
        const array = new Uint8Array(32)
        crypto.getRandomValues(array)
        const verifier = btoa(String.fromCharCode.apply(null, Array.from(array)))
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=/g, '')

        // Generate challenge
        const encoder = new TextEncoder()
        const data = encoder.encode(verifier)
        return crypto.subtle.digest('SHA-256', data).then(buffer => {
            const challenge = btoa(String.fromCharCode.apply(null, Array.from(new Uint8Array(buffer))))
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=/g, '')
            return { verifier, challenge }
        })
    }

    const handleGenerateUrl = async () => {
        if (!organizationUuid.trim()) {
            setError(t('oauthModal.enterOrgUuid'))
            return
        }

        setLoading(true)
        setError('')

        try {
            const { verifier, challenge } = await generatePKCE()
            setPkceVerifier(verifier)

            // Build authorization URL
            const params = new URLSearchParams({
                response_type: 'code',
                client_id: CLIENT_ID,
                organization_uuid: formatUUID(organizationUuid),
                redirect_uri: REDIRECT_URI,
                scope: 'user:profile user:inference',
                state: verifier,
                code_challenge: challenge,
                code_challenge_method: 'S256',
            })

            const authUrl = `${AUTHORIZE_URL}?${params.toString()}`

            // Open in new window
            window.open(authUrl, '_blank', 'width=600,height=700')

            setStep('code')
        } catch (err) {
            setError(t('oauthModal.generateFailed'))
            console.error(err)
        } finally {
            setLoading(false)
        }
    }

    const handleExchangeToken = async () => {
        if (!authCode.trim()) {
            setError(t('oauthModal.authCodePlaceholder'))
            return
        }

        setLoading(true)
        setError('')

        try {
            // Send code to backend for token exchange
            const exchangeData = {
                organization_uuid: formatUUID(organizationUuid),
                code: authCode,
                pkce_verifier: pkceVerifier,
                capabilities:
                    accountType === 'Max' ? ['chat', 'claude_max'] : accountType === 'Pro' ? ['chat', 'claude_pro'] : ['chat'],
            }

            await accountsApi.exchangeOAuthCode(exchangeData)
            onClose()
        } catch (err) {
            console.error('OAuth exchange error:', err)
            setError(t('oauthModal.authFailed'))
        } finally {
            setLoading(false)
        }
    }

    const formContent = (
        <>
            <Alert className={cn(isMobile && 'mb-4')}>
                <Info className='h-4 w-4' />
                <AlertDescription>
                    {t('oauthModal.recommendCookie')}
                </AlertDescription>
            </Alert>

            {step === 'input' ? (
                <div className='grid gap-4'>
                    <div className='space-y-2'>
                        <Label htmlFor='organization_uuid'>
                            Organization UUID <span className='text-destructive'>*</span>
                        </Label>
                        <Input
                            id='organization_uuid'
                            placeholder={t('oauthModal.orgUuidPlaceholder')}
                            value={organizationUuid}
                            onChange={e => {
                                const value = e.target.value
                                setOrganizationUuid(value)
                                // Validate UUID format
                                const formatted = formatUUID(value)
                                if (formatted && !isValidUUID(formatted)) {
                                    setUuidError(t('oauthModal.invalidUuid'))
                                } else {
                                    setUuidError('')
                                }
                            }}
                            className={`font-mono ${uuidError && organizationUuid ? 'border-destructive' : ''}`}
                        />
                        {uuidError && organizationUuid ? (
                            <div className='flex items-center gap-1 text-sm text-destructive'>
                                <AlertCircle className='h-3 w-3' />
                                <span>{uuidError}</span>
                            </div>
                        ) : (
                            <p className='text-sm text-muted-foreground'>{t('oauthModal.orgUuidHint')}</p>
                        )}
                    </div>

                    <div className='space-y-2'>
                        <Label htmlFor='accountType'>{t('oauthModal.accountType')}</Label>
                        <Select value={accountType} onValueChange={value => setAccountType(value as any)}>
                            <SelectTrigger className='w-full' id='accountType'>
                                <SelectValue placeholder={t('oauthModal.selectAccountType')} />
                            </SelectTrigger>
                            <SelectContent>
                                <SelectItem value='Pro'>Pro</SelectItem>
                                <SelectItem value='Max'>Max</SelectItem>
                            </SelectContent>
                        </Select>
                    </div>

                    {error && (
                        <Alert variant='destructive'>
                            <AlertCircle className='h-4 w-4' />
                            <AlertDescription>{error}</AlertDescription>
                        </Alert>
                    )}
                </div>
            ) : (
                <div className='grid gap-4'>
                    <Alert>
                        <Info className='h-4 w-4' />
                        <AlertDescription>
                            {t('oauthModal.authPageOpened')}
                        </AlertDescription>
                    </Alert>

                    <div className='space-y-2'>
                        <Label htmlFor='auth_code'>
                            {t('oauthModal.authCode')} <span className='text-destructive'>*</span>
                        </Label>
                        <Input
                            id='auth_code'
                            placeholder={t('oauthModal.authCodePlaceholder')}
                            value={authCode}
                            onChange={e => setAuthCode(e.target.value)}
                            className='font-mono'
                        />
                    </div>

                    {error && (
                        <Alert variant='destructive'>
                            <AlertCircle className='h-4 w-4' />
                            <AlertDescription>{error}</AlertDescription>
                        </Alert>
                    )}
                </div>
            )}
        </>
    )

    const footerContent = (
        <>
            <Button type='button' variant='outline' onClick={onClose}>
                {t('common.cancel')}
            </Button>
            {step === 'input' ? (
                <Button
                    onClick={handleGenerateUrl}
                    disabled={loading || !organizationUuid.trim() || !isValidUUID(formatUUID(organizationUuid))}
                >
                    {loading && <Loader2 className='mr-2 h-4 w-4 animate-spin' />}
                    {loading ? (
                        t('oauthModal.generating')
                    ) : (
                        <>
                            <ExternalLink className='mr-2 h-4 w-4' />
                            {t('oauthModal.startAuth')}
                        </>
                    )}
                </Button>
            ) : (
                <Button onClick={handleExchangeToken} disabled={loading || !authCode.trim()}>
                    {loading && <Loader2 className='mr-2 h-4 w-4 animate-spin' />}
                    {loading ? t('oauthModal.verifying') : t('oauthModal.completeAuth')}
                </Button>
            )}
        </>
    )

    if (isMobile === undefined) {
        return null
    }

    if (!isMobile) {
        return (
            <Dialog open={true} onOpenChange={onClose}>
                <DialogContent className='sm:max-w-[600px]'>
                    <DialogHeader>
                        <DialogTitle>{t('oauthModal.title')}</DialogTitle>
                        <DialogDescription>{t('oauthModal.desc')}</DialogDescription>
                    </DialogHeader>
                    {formContent}
                    <DialogFooter>{footerContent}</DialogFooter>
                </DialogContent>
            </Dialog>
        )
    }

    return (
        <Drawer open={true} onOpenChange={onClose}>
            <DrawerContent>
                <div className='max-h-[90vh] overflow-auto'>
                    <DrawerHeader>
                        <DrawerTitle>{t('oauthModal.title')}</DrawerTitle>
                        <DrawerDescription>{t('oauthModal.desc')}</DrawerDescription>
                    </DrawerHeader>
                    <div className='px-4'>{formContent}</div>
                    <DrawerFooter className='flex-row justify-end space-x-2'>{footerContent}</DrawerFooter>
                </div>
            </DrawerContent>
        </Drawer>
    )
}
</file>

<file path="front/src/main.tsx">
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import './i18n/i18n-config'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
</file>

<file path="front/src/pages/Accounts.tsx">
import { useEffect, useState } from 'react'
import { useTranslation } from 'react-i18next'
import {
    Plus,
    Pencil,
    Trash2,
    Cookie,
    Shield,
    CheckCircle,
    XCircle,
    AlertCircle,
    MoreHorizontal,
    Users,
    ChevronRight,
    KeyRound,
    FileText,
} from 'lucide-react'
import type { AccountResponse } from '../api/types'
import { accountsApi } from '../api/client'
import { AccountModal } from '../components/AccountModal'
import { OAuthModal } from '../components/OAuthModal'
import { BatchCookieModal } from '../components/BatchCookieModal'
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table'
import { Button } from '@/components/ui/button'
import { Badge } from '@/components/ui/badge'
import { Card, CardContent, CardHeader } from '@/components/ui/card'
import { Skeleton } from '@/components/ui/skeleton'
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from '@/components/ui/dropdown-menu'
import {
    AlertDialog,
    AlertDialogAction,
    AlertDialogCancel,
    AlertDialogContent,
    AlertDialogDescription,
    AlertDialogFooter,
    AlertDialogHeader,
    AlertDialogTitle,
} from '@/components/ui/alert-dialog'
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from '@/components/ui/collapsible'
import { useIsMobile } from '@/hooks/use-mobile'

export function Accounts() {
    const [accounts, setAccounts] = useState<AccountResponse[]>([])
    const [loading, setLoading] = useState(true)
    const [modalOpen, setModalOpen] = useState(false)
    const [oauthModalOpen, setOauthModalOpen] = useState(false)
    const [batchModalOpen, setBatchModalOpen] = useState(false)
    const [editingAccount, setEditingAccount] = useState<AccountResponse | null>(null)
    const [deleteDialogOpen, setDeleteDialogOpen] = useState(false)
    const [accountToDelete, setAccountToDelete] = useState<string | null>(null)
    const [expandedCards, setExpandedCards] = useState<Set<string>>(new Set())
    const isMobile = useIsMobile()
    const { t, i18n } = useTranslation()
    const dateLocale = i18n.language.startsWith('zh') ? 'zh-CN' : 'en-US'

    const loadAccounts = async () => {
        try {
            const response = await accountsApi.list()
            setAccounts(response.data)
        } catch (error) {
            console.error('Failed to load accounts:', error)
        } finally {
            setLoading(false)
        }
    }

    useEffect(() => {
        loadAccounts()
    }, [])

    const handleDelete = async () => {
        if (!accountToDelete) return

        try {
            await accountsApi.delete(accountToDelete)
            await loadAccounts()
            setDeleteDialogOpen(false)
            setAccountToDelete(null)
        } catch (error) {
            console.error('Failed to delete account:', error)
            alert(t('accounts.deleteFailed'))
        }
    }

    const handleEdit = (account: AccountResponse) => {
        setEditingAccount(account)
        setModalOpen(true)
    }

    const handleAdd = () => {
        setEditingAccount(null)
        setModalOpen(true)
    }

    const handleModalClose = () => {
        setModalOpen(false)
        setEditingAccount(null)
        loadAccounts()
    }

    const handleOAuthModalClose = () => {
        setOauthModalOpen(false)
        loadAccounts()
    }

    const handleBatchModalClose = () => {
        setBatchModalOpen(false)
        loadAccounts()
    }

    const toggleCardExpansion = (uuid: string) => {
        setExpandedCards(prev => {
            const next = new Set(prev)
            if (next.has(uuid)) {
                next.delete(uuid)
            } else {
                next.add(uuid)
            }
            return next
        })
    }

    const getAuthTypeIcon = (authType: string) => {
        if (authType === 'both') {
            return <Shield className='h-4 w-4' />
        } else if (authType === 'oauth_only') {
            return <KeyRound className='h-4 w-4' />
        } else {
            return <Cookie className='h-4 w-4' />
        }
    }

    const getAuthTypeName = (authType: string) => {
        switch (authType) {
            case 'cookie_only':
                return 'Cookie'
            case 'oauth_only':
                return 'OAuth'
            case 'both':
                return 'Cookie + OAuth'
            default:
                return authType
        }
    }

    const getStatusIcon = (status: string) => {
        switch (status) {
            case 'valid':
                return <CheckCircle className='h-4 w-4 text-green-500' />
            case 'invalid':
                return <XCircle className='h-4 w-4 text-red-500' />
            case 'rate_limited':
                return <AlertCircle className='h-4 w-4 text-yellow-500' />
            default:
                return null
        }
    }

    const getStatusName = (status: string) => {
        switch (status) {
            case 'valid':
                return t('accounts.statusValid')
            case 'invalid':
                return t('accounts.statusInvalid')
            case 'rate_limited':
                return t('accounts.statusRateLimited')
            default:
                return status
        }
    }

    const AccountTypeBadge = ({ account }: { account: AccountResponse }) => {
        if (account.is_max) {
            return (
                <Badge variant='default' className='bg-gradient-to-r from-purple-500 to-pink-500'>
                    Max
                </Badge>
            )
        } else if (account.is_pro) {
            return (
                <Badge variant='secondary' className='bg-gradient-to-r from-blue-500 to-purple-500 text-white'>
                    Pro
                </Badge>
            )
        } else {
            return <Badge variant='outline'>Free</Badge>
        }
    }

    const MobileAccountCard = ({ account }: { account: AccountResponse }) => {
        const isExpanded = expandedCards.has(account.organization_uuid)

        return (
            <Card className='mb-4'>
                <Collapsible open={isExpanded} onOpenChange={() => toggleCardExpansion(account.organization_uuid)}>
                    <CollapsibleTrigger asChild>
                        <CardHeader className='cursor-pointer'>
                            <div className='flex items-start justify-between'>
                                <div className='flex-1 space-y-2'>
                                    <div className='flex items-center gap-2'>
                                        <AccountTypeBadge account={account} />
                                        <div className='flex items-center gap-1'>
                                            {getStatusIcon(account.status)}
                                            <span className='text-sm'>{getStatusName(account.status)}</span>
                                        </div>
                                    </div>
                                    <div className='flex items-center gap-2 text-sm text-muted-foreground'>
                                        {getAuthTypeIcon(account.auth_type)}
                                        <span>{getAuthTypeName(account.auth_type)}</span>
                                    </div>
                                    <p className='font-mono text-xs text-muted-foreground truncate'>
                                        {account.organization_uuid}
                                    </p>
                                </div>
                                <ChevronRight
                                    className={`h-5 w-5 text-muted-foreground transition-transform ${
                                        isExpanded ? 'rotate-90' : ''
                                    }`}
                                />
                            </div>
                        </CardHeader>
                    </CollapsibleTrigger>
                    <CollapsibleContent>
                        <CardContent className='pt-0 space-y-3'>
                            <div className='space-y-2 text-sm'>
                                <div className='flex justify-between'>
                                    <span className='text-muted-foreground'>{t('accounts.lastUsed')}</span>
                                    <span>{new Date(account.last_used).toLocaleString(dateLocale)}</span>
                                </div>
                                <div className='flex justify-between'>
                                    <span className='text-muted-foreground'>{t('accounts.resetTime')}</span>
                                    <span>{account.resets_at ? new Date(account.resets_at).toLocaleString(dateLocale) : '-'}</span>
                                </div>
                            </div>
                            <div className='flex gap-2 pt-2'>
                                <Button size='sm' variant='outline' className='flex-1' onClick={() => handleEdit(account)}>
                                    <Pencil className='mr-2 h-4 w-4' />
                                    {t('common.edit')}
                                </Button>
                                <Button
                                    size='sm'
                                    variant='outline'
                                    className='flex-1 text-destructive hover:bg-destructive hover:text-destructive-foreground'
                                    onClick={() => {
                                        setAccountToDelete(account.organization_uuid)
                                        setDeleteDialogOpen(true)
                                    }}
                                >
                                    <Trash2 className='mr-2 h-4 w-4' />
                                    {t('common.delete')}
                                </Button>
                            </div>
                        </CardContent>
                    </CollapsibleContent>
                </Collapsible>
            </Card>
        )
    }

    if (isMobile === undefined) {
        return null
    }

    if (loading) {
        return (
            <div className='space-y-6'>
                <div className='flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4'>
                    <div className='space-y-2'>
                        <Skeleton className='h-8 w-32 sm:w-48' />
                        <Skeleton className='h-4 w-64 sm:w-96 max-w-full' />
                    </div>
                    <Skeleton className='h-10 w-full sm:w-32' />
                </div>

                {!isMobile ? (
                    <Card>
                        <CardContent className='p-0'>
                            <Table>
                                <TableHeader>
                                    <TableRow>
                                        <TableHead>
                                            <Skeleton className='h-4 w-32' />
                                        </TableHead>
                                        <TableHead>
                                            <Skeleton className='h-4 w-24' />
                                        </TableHead>
                                        <TableHead>
                                            <Skeleton className='h-4 w-16' />
                                        </TableHead>
                                        <TableHead>
                                            <Skeleton className='h-4 w-24' />
                                        </TableHead>
                                        <TableHead>
                                            <Skeleton className='h-4 w-32' />
                                        </TableHead>
                                        <TableHead>
                                            <Skeleton className='h-4 w-32' />
                                        </TableHead>
                                        <TableHead className='text-right'>
                                            <Skeleton className='h-4 w-16 ml-auto' />
                                        </TableHead>
                                    </TableRow>
                                </TableHeader>
                                <TableBody>
                                    {[...Array(5)].map((_, i) => (
                                        <TableRow key={i}>
                                            <TableCell>
                                                <Skeleton className='h-4 w-64' />
                                            </TableCell>
                                            <TableCell>
                                                <div className='flex items-center gap-2'>
                                                    <Skeleton className='h-4 w-4 rounded' />
                                                    <Skeleton className='h-4 w-16' />
                                                </div>
                                            </TableCell>
                                            <TableCell>
                                                <div className='flex items-center gap-2'>
                                                    <Skeleton className='h-4 w-4 rounded-full' />
                                                    <Skeleton className='h-4 w-12' />
                                                </div>
                                            </TableCell>
                                            <TableCell>
                                                <Skeleton className='h-6 w-16 rounded-full' />
                                            </TableCell>
                                            <TableCell>
                                                <Skeleton className='h-4 w-32' />
                                            </TableCell>
                                            <TableCell>
                                                <Skeleton className='h-4 w-32' />
                                            </TableCell>
                                            <TableCell className='text-right'>
                                                <Skeleton className='h-8 w-8 rounded ml-auto' />
                                            </TableCell>
                                        </TableRow>
                                    ))}
                                </TableBody>
                            </Table>
                        </CardContent>
                    </Card>
                ) : (
                    <div className='space-y-4'>
                        {[...Array(3)].map((_, i) => (
                            <Card key={i} className='overflow-hidden'>
                                <CardHeader className='pb-3'>
                                    <div className='flex items-start justify-between'>
                                        <div className='flex-1 space-y-3'>
                                            <div className='flex items-center gap-2'>
                                                <Skeleton className='h-5 w-12 rounded-full' />
                                                <div className='flex items-center gap-1'>
                                                    <Skeleton className='h-4 w-4 rounded-full' />
                                                    <Skeleton className='h-4 w-12' />
                                                </div>
                                            </div>
                                            <div className='flex items-center gap-2'>
                                                <Skeleton className='h-4 w-4 rounded' />
                                                <Skeleton className='h-4 w-24' />
                                            </div>
                                            <Skeleton className='h-3 w-full max-w-[280px]' />
                                        </div>
                                        <Skeleton className='h-5 w-5 rounded' />
                                    </div>
                                </CardHeader>
                            </Card>
                        ))}
                    </div>
                )}
            </div>
        )
    }

    return (
        <div className='space-y-6'>
            <div className='flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4'>
                <div>
                    <h1 className='text-3xl font-bold tracking-tight pb-1'>{t('accounts.title')}</h1>
                    <p className='text-muted-foreground'>{t('accounts.subtitle')}</p>
                </div>
                <div className='flex flex-col sm:flex-row gap-2 w-full sm:w-auto'>
                    <Button onClick={() => setOauthModalOpen(true)} variant='outline' className='w-full sm:w-auto'>
                        <KeyRound className='mr-2 h-4 w-4' />
                        {t('accounts.oauthLogin')}
                    </Button>
                    <Button onClick={() => setBatchModalOpen(true)} variant='outline' className='w-full sm:w-auto'>
                        <FileText className='mr-2 h-4 w-4' />
                        {t('accounts.batchAdd')}
                    </Button>
                    <Button onClick={handleAdd} className='w-full sm:w-auto'>
                        <Plus className='mr-2 h-4 w-4' />
                        {t('accounts.addCookie')}
                    </Button>
                </div>
            </div>

            {accounts.length === 0 ? (
                <Card>
                    <CardContent className='flex flex-col items-center justify-center py-12'>
                        <div className='rounded-full bg-muted p-6 mb-4'>
                            <Users className='h-12 w-12 text-muted-foreground' />
                        </div>
                        <h3 className='text-lg font-semibold mb-2'>{t('accounts.noAccounts')}</h3>
                        <p className='text-muted-foreground mb-4 text-center'>{t('accounts.noAccountsDesc')}</p>
                        <div className='flex flex-col sm:flex-row gap-2'>
                            <Button onClick={() => setOauthModalOpen(true)} variant='outline'>
                                <KeyRound className='mr-2 h-4 w-4' />
                                {t('accounts.oauthLogin')}
                            </Button>
                            <Button onClick={() => setBatchModalOpen(true)} variant='outline'>
                                <FileText className='mr-2 h-4 w-4' />
                                {t('accounts.batchAdd')}
                            </Button>
                            <Button onClick={handleAdd}>
                                <Plus className='mr-2 h-4 w-4' />
                                {t('accounts.addCookie')}
                            </Button>
                        </div>
                    </CardContent>
                </Card>
            ) : !isMobile ? (
                <Card>
                    <CardContent className='p-0 overflow-x-auto'>
                        <Table>
                            <TableHeader>
                                <TableRow>
                                    <TableHead>Organization UUID</TableHead>
                                    <TableHead>{t('accounts.authMethod')}</TableHead>
                                    <TableHead>{t('accounts.status')}</TableHead>
                                    <TableHead>{t('accounts.accountType')}</TableHead>
                                    <TableHead>{t('accounts.lastUsed')}</TableHead>
                                    <TableHead>{t('accounts.resetTime')}</TableHead>
                                    <TableHead className='text-right'>{t('accounts.actions')}</TableHead>
                                </TableRow>
                            </TableHeader>
                            <TableBody>
                                {accounts.map(account => (
                                    <TableRow key={account.organization_uuid}>
                                        <TableCell className='font-mono text-sm'>{account.organization_uuid}</TableCell>
                                        <TableCell>
                                            <div className='flex items-center gap-2'>
                                                {getAuthTypeIcon(account.auth_type)}
                                                <span>{getAuthTypeName(account.auth_type)}</span>
                                            </div>
                                        </TableCell>
                                        <TableCell>
                                            <div className='flex items-center gap-2'>
                                                {getStatusIcon(account.status)}
                                                <span>{getStatusName(account.status)}</span>
                                            </div>
                                        </TableCell>
                                        <TableCell>
                                            <AccountTypeBadge account={account} />
                                        </TableCell>
                                        <TableCell className='text-sm'>
                                            {new Date(account.last_used).toLocaleString(dateLocale)}
                                        </TableCell>
                                        <TableCell className='text-sm'>
                                            {account.resets_at ? new Date(account.resets_at).toLocaleString(dateLocale) : '-'}
                                        </TableCell>
                                        <TableCell className='text-right'>
                                            <DropdownMenu>
                                                <DropdownMenuTrigger asChild>
                                                    <Button variant='ghost' size='sm' className='h-8 w-8 p-0'>
                                                        <span className='sr-only'>{t('accounts.openMenu')}</span>
                                                        <MoreHorizontal className='h-4 w-4' />
                                                    </Button>
                                                </DropdownMenuTrigger>
                                                <DropdownMenuContent align='end'>
                                                    <DropdownMenuItem onClick={() => handleEdit(account)}>
                                                        <Pencil className='mr-2 h-4 w-4' />
                                                        {t('common.edit')}
                                                    </DropdownMenuItem>
                                                    <DropdownMenuItem
                                                        onClick={() => {
                                                            setAccountToDelete(account.organization_uuid)
                                                            setDeleteDialogOpen(true)
                                                        }}
                                                        className='text-destructive'
                                                    >
                                                        <Trash2 className='mr-2 h-4 w-4' />
                                                        {t('common.delete')}
                                                    </DropdownMenuItem>
                                                </DropdownMenuContent>
                                            </DropdownMenu>
                                        </TableCell>
                                    </TableRow>
                                ))}
                            </TableBody>
                        </Table>
                    </CardContent>
                </Card>
            ) : (
                <div>
                    {accounts.map(account => (
                        <MobileAccountCard key={account.organization_uuid} account={account} />
                    ))}
                </div>
            )}

            <AlertDialog open={deleteDialogOpen} onOpenChange={setDeleteDialogOpen}>
                <AlertDialogContent>
                    <AlertDialogHeader>
                        <AlertDialogTitle>{t('accounts.deleteConfirmTitle')}</AlertDialogTitle>
                        <AlertDialogDescription>
                            {t('accounts.deleteConfirmDesc')}
                        </AlertDialogDescription>
                    </AlertDialogHeader>
                    <AlertDialogFooter>
                        <AlertDialogCancel>{t('common.cancel')}</AlertDialogCancel>
                        <AlertDialogAction
                            onClick={handleDelete}
                            className='bg-destructive text-destructive-foreground hover:bg-destructive/90'
                        >
                            {t('common.delete')}
                        </AlertDialogAction>
                    </AlertDialogFooter>
                </AlertDialogContent>
            </AlertDialog>

            {modalOpen && <AccountModal account={editingAccount} onClose={handleModalClose} />}
            {oauthModalOpen && <OAuthModal onClose={handleOAuthModalClose} />}
            {batchModalOpen && <BatchCookieModal onClose={handleBatchModalClose} />}
        </div>
    )
}
</file>

<file path="front/src/pages/Dashboard.tsx">
import { useEffect, useState } from 'react'
import { useTranslation } from 'react-i18next'
import { Users, Settings, Activity, Server } from 'lucide-react'
import { healthApi, statisticsApi } from '../api/client'
import type { StatisticsResponse } from '../api/types'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Skeleton } from '@/components/ui/skeleton'
import { Button } from '@/components/ui/button'
import { Link } from 'react-router-dom'

export function Dashboard() {
    const { t } = useTranslation()
    const [statistics, setStatistics] = useState<StatisticsResponse | null>(null)
    const [serverStatus, setServerStatus] = useState<'online' | 'offline'>('offline')
    const [loading, setLoading] = useState(true)

    useEffect(() => {
        const loadData = async () => {
            try {
                const [statsRes, healthRes] = await Promise.all([statisticsApi.get(), healthApi.check()])

                setStatistics(statsRes.data)
                setServerStatus(healthRes.status === 200 ? 'online' : 'offline')
            } catch (error) {
                console.error('Failed to load dashboard data:', error)
                setServerStatus('offline')
            } finally {
                setLoading(false)
            }
        }

        loadData()
    }, [])

    const stats = [
        {
            name: t('dashboard.totalAccounts'),
            value: serverStatus === 'offline' ? 'N/A' : (statistics?.accounts.total_accounts ?? 0).toString(),
            icon: Users,
            color: 'text-pink-500',
            bgColor: 'bg-pink-50',
        },
        {
            name: t('dashboard.serverStatus'),
            value: serverStatus === 'online' ? t('dashboard.online') : t('dashboard.offline'),
            icon: Server,
            color: serverStatus === 'online' ? 'text-green-500' : 'text-red-500',
            bgColor: serverStatus === 'online' ? 'bg-green-50' : 'bg-red-50',
        },
        {
            name: t('dashboard.activeSessions'),
            value: serverStatus === 'offline' ? 'N/A' : (statistics?.accounts.active_sessions ?? 0).toString(),
            icon: Activity,
            color: 'text-blue-500',
            bgColor: 'bg-blue-50',
        },
        {
            name: t('dashboard.systemStatus'),
            value: serverStatus === 'offline' ? 'N/A' : statistics?.status === 'healthy' ? t('dashboard.normal') : t('dashboard.degraded'),
            icon: Settings,
            color: statistics?.status === 'healthy' ? 'text-green-500' : 'text-yellow-500',
            bgColor: statistics?.status === 'healthy' ? 'bg-green-50' : 'bg-yellow-50',
        },
    ]

    if (loading) {
        return (
            <div className='space-y-6'>
                <div className='space-y-2'>
                    <Skeleton className='h-8 w-32' />
                    <Skeleton className='h-4 w-64' />
                </div>

                <div className='grid gap-4 md:grid-cols-2 lg:grid-cols-4'>
                    {[...Array(4)].map((_, i) => (
                        <Card key={i}>
                            <CardHeader className='flex flex-row items-center justify-between space-y-0 pb-1'>
                                <Skeleton className='h-4 w-24' />
                                <Skeleton className='h-12 w-12 rounded-full' />
                            </CardHeader>
                            <CardContent>
                                <Skeleton className='h-7 w-16' />
                            </CardContent>
                        </Card>
                    ))}
                </div>
            </div>
        )
    }

    return (
        <div className='space-y-6'>
            <div>
                <h1 className='text-3xl font-bold tracking-tight pb-1'>{t('dashboard.title')}</h1>
                <p className='text-muted-foreground'>{t('dashboard.welcome')}</p>
            </div>

            <div className='grid gap-4 md:grid-cols-2 lg:grid-cols-4'>
                {stats.map(item => (
                    <Card key={item.name} className='hover:shadow-lg transition-shadow gap-1 py-4'>
                        <CardHeader className='flex flex-row items-center justify-between space-y-0'>
                            <CardTitle className='text-md font-medium text-muted-foreground'>{item.name}</CardTitle>
                            <div className={`p-3 rounded-full ${item.bgColor}`}>
                                <item.icon className={`h-6 w-6 ${item.color}`} />
                            </div>
                        </CardHeader>
                        <CardContent>
                            <div className='text-2xl font-bold'>{item.value}</div>
                        </CardContent>
                    </Card>
                ))}
            </div>

            <div>
                <h2 className='text-2xl font-semibold mb-4'>{t('dashboard.quickActions')}</h2>
                <div className='grid gap-4 md:grid-cols-2'>
                    <Card className='hover:shadow-lg transition-all hover:border-primary/50'>
                        <CardHeader>
                            <div className='flex items-center space-x-4'>
                                <div className='p-3 rounded-lg bg-pink-50'>
                                    <Users className='h-6 w-6 text-pink-500' />
                                </div>
                                <div className='space-y-1'>
                                    <CardTitle>{t('dashboard.manageAccounts')}</CardTitle>
                                    <CardDescription>{t('dashboard.manageAccountsDesc')}</CardDescription>
                                </div>
                            </div>
                        </CardHeader>
                        <CardContent>
                            <Button asChild className='w-full'>
                                <Link to='/accounts'>{t('dashboard.goToAccounts')}</Link>
                            </Button>
                        </CardContent>
                    </Card>

                    <Card className='hover:shadow-lg transition-all hover:border-primary/50'>
                        <CardHeader>
                            <div className='flex items-center space-x-4'>
                                <div className='p-3 rounded-lg bg-purple-50'>
                                    <Settings className='h-6 w-6 text-purple-500' />
                                </div>
                                <div className='space-y-1'>
                                    <CardTitle>{t('dashboard.systemSettings')}</CardTitle>
                                    <CardDescription>{t('dashboard.systemSettingsDesc')}</CardDescription>
                                </div>
                            </div>
                        </CardHeader>
                        <CardContent>
                            <Button asChild variant='secondary' className='w-full'>
                                <Link to='/settings'>{t('dashboard.goToSettings')}</Link>
                            </Button>
                        </CardContent>
                    </Card>
                </div>
            </div>
        </div>
    )
}
</file>

<file path="front/src/pages/Login.tsx">
import { useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { useTranslation } from 'react-i18next'
import { KeyRound, Loader2 } from 'lucide-react'
import { statisticsApi } from '../api/client'
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card'
import { Input } from '@/components/ui/input'
import { Button } from '@/components/ui/button'
import { Label } from '@/components/ui/label'
import { Alert, AlertDescription } from '@/components/ui/alert'

export function Login() {
    const { t } = useTranslation()
    const [adminKey, setAdminKey] = useState('')
    const [error, setError] = useState('')
    const [loading, setLoading] = useState(false)
    const navigate = useNavigate()

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault()
        setError('')
        setLoading(true)

        try {
            // Save admin key
            localStorage.setItem('adminKey', adminKey)

            // Verify Admin Key via statistics API
            await statisticsApi.get()

            // Redirect on success
            navigate('/')
        } catch (err) {
            setError(t('login.invalidKey'))
            localStorage.removeItem('adminKey')
        } finally {
            setLoading(false)
        }
    }

    return (
        <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-pink-50 via-white to-purple-50 relative overflow-hidden">
            {/* Decorative background elements */}
            <div className="absolute inset-0 opacity-30">
                <div className="absolute top-10 left-10 w-72 h-72 bg-pink-200 rounded-full filter blur-3xl animate-pulse"></div>
                <div className="absolute bottom-10 right-10 w-96 h-96 bg-purple-200 rounded-full filter blur-3xl animate-pulse animation-delay-2000"></div>
                <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-80 h-80 bg-pink-100 rounded-full filter blur-3xl animate-pulse animation-delay-4000"></div>
            </div>
            
            <Card className="w-full max-w-md relative z-10 shadow-xl border-0 backdrop-blur-sm bg-white/95">
                <CardHeader className="space-y-1 text-center">
                    <div className="flex justify-center mb-4">
                        <div className="h-16 w-16 rounded-2xl bg-gradient-to-br from-pink-500 to-purple-500 flex items-center justify-center shadow-lg">
                            <span className="text-3xl font-bold text-white">C</span>
                        </div>
                    </div>
                    <CardTitle className="text-2xl font-bold">{t('login.welcomeBack')}</CardTitle>
                    <CardDescription>
                        {t('login.subtitle')}
                    </CardDescription>
                </CardHeader>
                
                <form onSubmit={handleSubmit}>
                    <CardContent className="space-y-4 pb-4">
                        <div className="space-y-2">
                            <Label htmlFor="admin-key">Admin Key</Label>
                            <div className="relative">
                                <KeyRound className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                                <Input
                                    id="admin-key"
                                    type="password"
                                    placeholder={t('login.placeholder')}
                                    value={adminKey}
                                    onChange={(e) => setAdminKey(e.target.value)}
                                    className="pl-10"
                                    required
                                />
                            </div>
                        </div>

                        {error && (
                            <Alert variant="destructive">
                                <AlertDescription>{error}</AlertDescription>
                            </Alert>
                        )}
                    </CardContent>
                    
                    <CardFooter>
                        <Button
                            type="submit"
                            className="w-full"
                            disabled={loading || !adminKey.trim()}
                        >
                            {loading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                            {loading ? t('login.verifying') : t('login.signIn')}
                        </Button>
                    </CardFooter>
                </form>
            </Card>
            
            <div className="absolute bottom-4 left-0 right-0 text-center text-sm text-muted-foreground">
                <p>{t('login.footer')}</p>
            </div>
        </div>
    )
}
</file>

<file path="front/src/pages/Settings.tsx">
import { useEffect, useState, useCallback } from 'react'
import { useTranslation } from 'react-i18next'
import { Key, RefreshCw, Sliders, Globe, Shield, Check, AlertCircle, Loader2, Trash2, Copy, Eye, EyeOff } from 'lucide-react'
import type { SettingsRead, SettingsUpdate } from '../api/types'
import { settingsApi } from '../api/client'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Textarea } from '@/components/ui/textarea'
import { Skeleton } from '@/components/ui/skeleton'
import { Badge } from '@/components/ui/badge'
import { Switch } from '@/components/ui/switch'
import { Separator } from '@/components/ui/separator'
import { Alert, AlertDescription } from '@/components/ui/alert'
import {
    AlertDialog,
    AlertDialogAction,
    AlertDialogCancel,
    AlertDialogContent,
    AlertDialogDescription,
    AlertDialogFooter,
    AlertDialogHeader,
    AlertDialogTitle,
    AlertDialogTrigger,
} from '@/components/ui/alert-dialog'
import { toast } from 'sonner'
import { useIsMobile } from '@/hooks/use-mobile'

export function Settings() {
    const [settings, setSettings] = useState<SettingsRead | null>(null)
    const [originalSettings, setOriginalSettings] = useState<SettingsRead | null>(null)
    const [loading, setLoading] = useState(true)
    const [saveStatus, setSaveStatus] = useState<'idle' | 'saving' | 'saved' | 'error'>('idle')
    const [newApiKey, setNewApiKey] = useState('')
    const [newAdminKey, setNewAdminKey] = useState('')
    const [visibleKeys, setVisibleKeys] = useState<Set<string>>(new Set())
    const [copiedKeys, setCopiedKeys] = useState<Set<string>>(new Set())
    const isMobile = useIsMobile()
    const { t } = useTranslation()

    const loadSettings = async () => {
        try {
            const response = await settingsApi.get()
            setSettings(response.data)
            setOriginalSettings(response.data)
        } catch (error) {
            console.error('Failed to load settings:', error)
        } finally {
            setLoading(false)
        }
    }

    useEffect(() => {
        loadSettings()
    }, [])

    // Immediate save function
    const saveChanges = useCallback(
        async (changes: SettingsUpdate) => {
            if (Object.keys(changes).length === 0) return

            setSaveStatus('saving')
            try {
                await settingsApi.update(changes)
                setSaveStatus('saved')

                // Update original settings to reflect saved changes
                if (originalSettings && settings) {
                    setOriginalSettings({ ...originalSettings, ...changes })
                }

                // Reset status after 3 seconds
                setTimeout(() => setSaveStatus('idle'), 3000)
            } catch (error) {
                console.error('Failed to save settings:', error)
                setSaveStatus('error')
                setTimeout(() => setSaveStatus('idle'), 5000)
            }
        },
        [originalSettings],
    )

    // Update settings without saving
    const updateSettings = useCallback((newSettings: SettingsRead) => {
        setSettings(newSettings)
    }, [])

    // Handle field change and save immediately
    const handleFieldChange = useCallback(
        async (newSettings: SettingsRead) => {
            setSettings(newSettings)

            if (!originalSettings) return

            // Compare and get changed fields
            const changes: SettingsUpdate = {}

            // Check each field for changes
            Object.keys(newSettings).forEach(key => {
                const typedKey = key as keyof SettingsRead
                if (JSON.stringify(newSettings[typedKey]) !== JSON.stringify(originalSettings[typedKey])) {
                    ;(changes as any)[key] = newSettings[typedKey]
                }
            })

            // Save immediately if there are changes
            if (Object.keys(changes).length > 0) {
                await saveChanges(changes)
            }
        },
        [originalSettings, saveChanges],
    )

    const handleAddApiKey = async () => {
        if (!settings || !newApiKey || settings.api_keys.includes(newApiKey)) return
        const newSettings = {
            ...settings,
            api_keys: [...settings.api_keys, newApiKey],
        }
        await handleFieldChange(newSettings)
        setNewApiKey('')
    }

    const handleRemoveApiKey = async (key: string) => {
        if (!settings) return
        const newSettings = {
            ...settings,
            api_keys: settings.api_keys.filter(k => k !== key),
        }
        await handleFieldChange(newSettings)
    }

    const handleAddAdminKey = async () => {
        if (!settings || !newAdminKey || settings.admin_api_keys.includes(newAdminKey)) return
        const newSettings = {
            ...settings,
            admin_api_keys: [...settings.admin_api_keys, newAdminKey],
        }
        await handleFieldChange(newSettings)
        setNewAdminKey('')
    }

    const handleRemoveAdminKey = async (key: string) => {
        if (!settings) return
        const newSettings = {
            ...settings,
            admin_api_keys: settings.admin_api_keys.filter(k => k !== key),
        }
        await handleFieldChange(newSettings)
    }

    const generateNewKey = (type: 'api' | 'admin') => {
        const key =
            'sk-' +
            Array.from({ length: 48 }, () =>
                'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.charAt(Math.floor(Math.random() * 62)),
            ).join('')

        if (type === 'api') {
            setNewApiKey(key)
        } else {
            setNewAdminKey(key)
        }
    }

    const toggleKeyVisibility = (key: string) => {
        setVisibleKeys(prev => {
            const newSet = new Set(prev)
            if (newSet.has(key)) {
                newSet.delete(key)
            } else {
                newSet.add(key)
            }
            return newSet
        })
    }

    const copyKey = async (key: string) => {
        try {
            await navigator.clipboard.writeText(key)
            toast.success(t('settings.keyCopied'))

            setCopiedKeys(prev => new Set(prev).add(key))
            setTimeout(() => {
                setCopiedKeys(prev => {
                    const newSet = new Set(prev)
                    newSet.delete(key)
                    return newSet
                })
            }, 2000)
        } catch (error) {
            toast.error(t('settings.copyKeyFailed'))
        }
    }

    if (loading || !settings) {
        return (
            <div className='space-y-6'>
                <div className='space-y-2'>
                    <Skeleton className='h-8 w-48' />
                    <Skeleton className='h-4 w-96' />
                </div>

                {[...Array(4)].map((_, i) => (
                    <Card key={i}>
                        <CardHeader>
                            <Skeleton className='h-6 w-32' />
                        </CardHeader>
                        <CardContent className='space-y-4'>
                            <Skeleton className='h-10 w-full' />
                            <Skeleton className='h-10 w-full' />
                        </CardContent>
                    </Card>
                ))}
            </div>
        )
    }

    return (
        <div className='space-y-6'>
            <div className='flex items-center justify-between'>
                <div>
                    <h1 className='text-3xl font-bold tracking-tight pb-1'>{t('settings.title')}</h1>
                    <p className='text-muted-foreground'>{t('settings.subtitle')}</p>
                </div>
                <div className='flex items-center gap-2'>
                    {saveStatus === 'saving' && (
                        <Badge variant='secondary' className='gap-1'>
                            <Loader2 className='h-3 w-3 animate-spin' />
                            {t('common.saving')}
                        </Badge>
                    )}
                    {saveStatus === 'saved' && (
                        <Badge variant='default' className='gap-1 bg-green-500'>
                            <Check className='h-3 w-3' />
                            {t('settings.saved')}
                        </Badge>
                    )}
                    {saveStatus === 'error' && (
                        <Badge variant='destructive' className='gap-1'>
                            <AlertCircle className='h-3 w-3' />
                            {t('settings.saveFailed')}
                        </Badge>
                    )}
                </div>
            </div>

            {/* API Keys */}
            <Card>
                <CardHeader>
                    <CardTitle className='flex items-center gap-2'>
                        <Key className='h-5 w-5' />
                        {t('settings.apiKeys')}
                    </CardTitle>
                    <CardDescription>{t('settings.apiKeysDesc')}</CardDescription>
                </CardHeader>
                <CardContent className='space-y-4'>
                    {settings.api_keys.length === 0 ? (
                        <Alert>
                            <AlertDescription>{t('settings.noApiKeys')}</AlertDescription>
                        </Alert>
                    ) : (
                        <div className='space-y-2'>
                            {settings.api_keys.map((key, index) => (
                                <div
                                    key={index}
                                    className='flex items-start gap-2 p-3 bg-muted/50 rounded-lg border border-border/50 hover:bg-muted/70 transition-colors'
                                >
                                    <code className='flex-1 text-sm font-mono select-none break-all'>
                                        {visibleKeys.has(key) ? key : isMobile ? '*'.repeat(20) : '*'.repeat(32)}
                                    </code>
                                    <div className='flex items-center gap-1 flex-shrink-0'>
                                        <Button
                                            variant='ghost'
                                            size='sm'
                                            onClick={() => toggleKeyVisibility(key)}
                                            className='h-8 w-8 p-0'
                                            title={visibleKeys.has(key) ? t('settings.hideKey') : t('settings.showKey')}
                                        >
                                            {visibleKeys.has(key) ? (
                                                <EyeOff className='h-4 w-4' />
                                            ) : (
                                                <Eye className='h-4 w-4' />
                                            )}
                                        </Button>
                                        <Button
                                            variant='ghost'
                                            size='sm'
                                            onClick={() => copyKey(key)}
                                            className='h-8 w-8 p-0'
                                            title={t('settings.copyKey')}
                                        >
                                            {copiedKeys.has(key) ? (
                                                <Check className='h-4 w-4 text-green-500' />
                                            ) : (
                                                <Copy className='h-4 w-4' />
                                            )}
                                        </Button>
                                        <AlertDialog>
                                            <AlertDialogTrigger asChild>
                                                <Button
                                                    variant='ghost'
                                                    size='sm'
                                                    className='h-8 w-8 p-0 text-destructive hover:text-destructive'
                                                >
                                                    <Trash2 className='h-4 w-4' />
                                                </Button>
                                            </AlertDialogTrigger>
                                            <AlertDialogContent>
                                                <AlertDialogHeader>
                                                    <AlertDialogTitle>{t('settings.deleteKeyTitle')}</AlertDialogTitle>
                                                    <AlertDialogDescription>
                                                        {t('settings.deleteApiKeyDesc')}
                                                    </AlertDialogDescription>
                                                </AlertDialogHeader>
                                                <AlertDialogFooter>
                                                    <AlertDialogCancel>{t('common.cancel')}</AlertDialogCancel>
                                                    <AlertDialogAction onClick={() => handleRemoveApiKey(key)}>
                                                        {t('common.delete')}
                                                    </AlertDialogAction>
                                                </AlertDialogFooter>
                                            </AlertDialogContent>
                                        </AlertDialog>
                                    </div>
                                </div>
                            ))}
                        </div>
                    )}

                    <Separator />

                    <div className='space-y-2'>
                        <Label htmlFor='new-api-key'>{t('settings.addNewApiKey')}</Label>
                        <div className='flex flex-wrap gap-2'>
                            <Input
                                id='new-api-key'
                                value={newApiKey}
                                onChange={e => setNewApiKey(e.target.value)}
                                placeholder={t('settings.enterOrGenerateKey')}
                                className='font-mono flex-1 min-w-0'
                            />
                            <div className='flex gap-2'>
                                <Button variant='outline' size='icon' onClick={() => generateNewKey('api')} title={t('settings.generateKey')}>
                                    <RefreshCw className='h-4 w-4' />
                                </Button>
                                <Button onClick={handleAddApiKey} disabled={!newApiKey}>
                                    {t('common.add')}
                                </Button>
                            </div>
                        </div>
                    </div>
                </CardContent>
            </Card>

            {/* Admin Keys */}
            <Card>
                <CardHeader>
                    <CardTitle className='flex items-center gap-2'>
                        <Shield className='h-5 w-5' />
                        {t('settings.adminKeys')}
                    </CardTitle>
                    <CardDescription>{t('settings.adminKeysDesc')}</CardDescription>
                </CardHeader>
                <CardContent className='space-y-4'>
                    {settings.admin_api_keys.length === 0 ? (
                        <Alert>
                            <AlertDescription>{t('settings.noAdminKeys')}</AlertDescription>
                        </Alert>
                    ) : (
                        <div className='space-y-2'>
                            {settings.admin_api_keys.map((key, index) => (
                                <div
                                    key={index}
                                    className='flex items-start gap-2 p-3 bg-muted/50 rounded-lg border border-border/50 hover:bg-muted/70 transition-colors'
                                >
                                    <code className='flex-1 text-sm font-mono select-none break-all'>
                                        {visibleKeys.has(key) ? key : isMobile ? '*'.repeat(20) : '*'.repeat(32)}
                                    </code>
                                    <div className='flex items-center gap-1 flex-shrink-0'>
                                        <Button
                                            variant='ghost'
                                            size='sm'
                                            onClick={() => toggleKeyVisibility(key)}
                                            className='h-8 w-8 p-0'
                                            title={visibleKeys.has(key) ? t('settings.hideKey') : t('settings.showKey')}
                                        >
                                            {visibleKeys.has(key) ? (
                                                <EyeOff className='h-4 w-4' />
                                            ) : (
                                                <Eye className='h-4 w-4' />
                                            )}
                                        </Button>
                                        <Button
                                            variant='ghost'
                                            size='sm'
                                            onClick={() => copyKey(key)}
                                            className='h-8 w-8 p-0'
                                            title={t('settings.copyKey')}
                                        >
                                            {copiedKeys.has(key) ? (
                                                <Check className='h-4 w-4 text-green-500' />
                                            ) : (
                                                <Copy className='h-4 w-4' />
                                            )}
                                        </Button>
                                        <AlertDialog>
                                            <AlertDialogTrigger asChild>
                                                <Button
                                                    variant='ghost'
                                                    size='sm'
                                                    className='h-8 w-8 p-0 text-destructive hover:text-destructive'
                                                >
                                                    <Trash2 className='h-4 w-4' />
                                                </Button>
                                            </AlertDialogTrigger>
                                            <AlertDialogContent>
                                                <AlertDialogHeader>
                                                    <AlertDialogTitle>{t('settings.deleteKeyTitle')}</AlertDialogTitle>
                                                    <AlertDialogDescription>
                                                        {t('settings.deleteAdminKeyDesc')}
                                                    </AlertDialogDescription>
                                                </AlertDialogHeader>
                                                <AlertDialogFooter>
                                                    <AlertDialogCancel>{t('common.cancel')}</AlertDialogCancel>
                                                    <AlertDialogAction onClick={() => handleRemoveAdminKey(key)}>
                                                        {t('common.delete')}
                                                    </AlertDialogAction>
                                                </AlertDialogFooter>
                                            </AlertDialogContent>
                                        </AlertDialog>
                                    </div>
                                </div>
                            ))}
                        </div>
                    )}

                    <Separator />

                    <div className='space-y-2'>
                        <Label htmlFor='new-admin-key'>{t('settings.addNewAdminKey')}</Label>
                        <div className='flex flex-wrap gap-2'>
                            <Input
                                id='new-admin-key'
                                value={newAdminKey}
                                onChange={e => setNewAdminKey(e.target.value)}
                                placeholder={t('settings.enterOrGenerateKey')}
                                className='font-mono flex-1 min-w-0'
                            />
                            <div className='flex gap-2'>
                                <Button
                                    variant='outline'
                                    size='icon'
                                    onClick={() => generateNewKey('admin')}
                                    title={t('settings.generateKey')}
                                >
                                    <RefreshCw className='h-4 w-4' />
                                </Button>
                                <Button onClick={handleAddAdminKey} disabled={!newAdminKey}>
                                    {t('common.add')}
                                </Button>
                            </div>
                        </div>
                    </div>
                </CardContent>
            </Card>

            {/* Claude Settings */}
            <Card>
                <CardHeader>
                    <CardTitle className='flex items-center gap-2'>
                        <Globe className='h-5 w-5' />
                        {t('settings.claudeConfig')}
                    </CardTitle>
                    <CardDescription>{t('settings.claudeConfigDesc')}</CardDescription>
                </CardHeader>
                <CardContent className='space-y-4'>
                    <div className='grid gap-4 md:grid-cols-2'>
                        <div className='space-y-2'>
                            <Label htmlFor='claude-ai-url'>Claude AI URL</Label>
                            <Input
                                id='claude-ai-url'
                                value={settings.claude_ai_url}
                                onChange={e => updateSettings({ ...settings, claude_ai_url: e.target.value })}
                                onBlur={() => handleFieldChange(settings)}
                            />
                        </div>

                        <div className='space-y-2'>
                            <Label htmlFor='claude-api-baseurl'>Claude API Base URL</Label>
                            <Input
                                id='claude-api-baseurl'
                                value={settings.claude_api_baseurl}
                                onChange={e => updateSettings({ ...settings, claude_api_baseurl: e.target.value })}
                                onBlur={() => handleFieldChange(settings)}
                            />
                        </div>

                        <div className='space-y-2 md:col-span-2'>
                            <Label htmlFor='proxy-url'>{t('settings.proxyUrl')}</Label>
                            <Input
                                id='proxy-url'
                                value={settings.proxy_url || ''}
                                onChange={e => updateSettings({ ...settings, proxy_url: e.target.value || null })}
                                onBlur={() => handleFieldChange(settings)}
                                placeholder={t('settings.proxyUrlPlaceholder')}
                            />
                        </div>
                    </div>
                </CardContent>
            </Card>

            {/* Chat Settings */}
            <Card>
                <CardHeader>
                    <CardTitle className='flex items-center gap-2'>
                        <Sliders className='h-5 w-5' />
                        {t('settings.formatSettings')}
                    </CardTitle>
                    <CardDescription>{t('settings.formatSettingsDesc')}</CardDescription>
                </CardHeader>
                <CardContent className='space-y-6'>
                    <div className='space-y-2'>
                        <Label htmlFor='custom-prompt'>{t('settings.customPrompt')}</Label>
                        <Textarea
                            id='custom-prompt'
                            value={settings.custom_prompt || ''}
                            onChange={e => updateSettings({ ...settings, custom_prompt: e.target.value || null })}
                            onBlur={() => handleFieldChange(settings)}
                            placeholder={t('settings.customPromptPlaceholder')}
                            className='min-h-[100px]'
                        />
                    </div>

                    <Separator />

                    <div className='grid gap-4 md:grid-cols-3'>
                        <div className='space-y-2'>
                            <Label htmlFor='human-name'>{t('settings.humanName')}</Label>
                            <Input
                                id='human-name'
                                value={settings.human_name}
                                onChange={e => updateSettings({ ...settings, human_name: e.target.value })}
                                onBlur={() => handleFieldChange(settings)}
                            />
                        </div>

                        <div className='space-y-2'>
                            <Label htmlFor='assistant-name'>{t('settings.assistantName')}</Label>
                            <Input
                                id='assistant-name'
                                value={settings.assistant_name}
                                onChange={e => updateSettings({ ...settings, assistant_name: e.target.value })}
                                onBlur={() => handleFieldChange(settings)}
                            />
                        </div>

                        <div className='space-y-2'>
                            <Label htmlFor='padtxt-length'>{t('settings.paddingLength')}</Label>
                            <Input
                                id='padtxt-length'
                                type='number'
                                value={settings.padtxt_length}
                                onChange={e => updateSettings({ ...settings, padtxt_length: parseInt(e.target.value) || 0 })}
                                onBlur={() => handleFieldChange(settings)}
                            />
                        </div>
                    </div>

                    <Separator />

                    <div className='space-y-4'>
                        <div className='flex items-center justify-between'>
                            <div className='space-y-0.5'>
                                <Label htmlFor='use-real-roles'>{t('settings.useRealRoles')}</Label>
                                <p className='text-sm text-muted-foreground'>{t('settings.useRealRolesDesc')}</p>
                            </div>
                            <Switch
                                id='use-real-roles'
                                checked={settings.use_real_roles}
                                onCheckedChange={checked => handleFieldChange({ ...settings, use_real_roles: checked })}
                            />
                        </div>

                        <div className='flex items-center justify-between'>
                            <div className='space-y-0.5'>
                                <Label htmlFor='allow-external-images'>{t('settings.allowExternalImages')}</Label>
                                <p className='text-sm text-muted-foreground'>{t('settings.allowExternalImagesDesc')}</p>
                            </div>
                            <Switch
                                id='allow-external-images'
                                checked={settings.allow_external_images}
                                onCheckedChange={checked => handleFieldChange({ ...settings, allow_external_images: checked })}
                            />
                        </div>

                        <div className='flex items-center justify-between'>
                            <div className='space-y-0.5'>
                                <Label htmlFor='preserve-chats'>{t('settings.preserveChats')}</Label>
                                <p className='text-sm text-muted-foreground'>{t('settings.preserveChatsDesc')}</p>
                            </div>
                            <Switch
                                id='preserve-chats'
                                checked={settings.preserve_chats}
                                onCheckedChange={checked => handleFieldChange({ ...settings, preserve_chats: checked })}
                            />
                        </div>
                    </div>
                </CardContent>
            </Card>
        </div>
    )
}
</file>

<file path="Makefile">
.PHONY: help build build-frontend build-wheel install install-dev clean run test

# Default target
help:
	@echo "Available commands:"
	@echo "  make build          - Build frontend and create Python wheel"
	@echo "  make build-frontend - Build only the frontend"
	@echo "  make build-wheel    - Build only the Python wheel"
	@echo "  make install        - Build and install the package"
	@echo "  make install-dev    - Install in development mode"
	@echo "  make clean          - Clean build artifacts"
	@echo "  make run            - Run the application (development)"
	@echo "  make test           - Run tests"

# Build everything
build:
	@python scripts/build_wheel.py

# Build only frontend
build-frontend:
	@cd front && pnpm install && pnpm run build
	@rm -rf app/static
	@cp -r front/dist app/static
	@echo " Frontend build complete"

# Build only wheel
build-wheel:
	@python scripts/build_wheel.py --skip-frontend

# Build and install
install: build
	@pip install dist/*.whl
	@echo " Clove installed successfully"
	@echo "Run 'clove' to start the application"

# Install in development mode
install-dev:
	@pip install -e .
	@echo " Clove installed in development mode"

# Clean build artifacts
clean:
	@rm -rf dist build *.egg-info
	@rm -rf app/__pycache__ app/**/__pycache__
	@rm -rf .pytest_cache .ruff_cache
	@find . -type f -name "*.pyc" -delete
	@find . -type f -name "*.pyo" -delete
	@echo " Cleaned build artifacts"

# Run the application (development mode)
run:
	@python -m app.main
</file>

<file path="MANIFEST.in">
# Include all static files
recursive-include app/static *

# Include locale files
recursive-include app/locales *.json

# Include documentation
include README.md
include LICENSE

# Exclude development files
recursive-exclude * __pycache__
recursive-exclude * *.py[co]
recursive-exclude * .DS_Store
global-exclude *.log
global-exclude *.tmp
global-exclude .git*

# Exclude test files
recursive-exclude tests *
recursive-exclude * test_*

# Exclude frontend source
recursive-exclude front *

# Exclude data directory
recursive-exclude data *
</file>

<file path="scripts/build_wheel.py">
#!/usr/bin/env python3
"""Build script for Clove - builds frontend and creates Python wheel."""

import argparse
import shutil
import subprocess
import sys
from pathlib import Path


def run_command(cmd, cwd=None, check=True):
    """Run a shell command and return the result."""
    print(f"Running: {' '.join(cmd)}")
    result = subprocess.run(cmd, cwd=cwd, capture_output=True, text=True)
    if check and result.returncode != 0:
        print(f"Error: {result.stderr}")
        sys.exit(1)
    return result


def clean_directories():
    """Clean build directories."""
    print("\n Cleaning build directories...")
    dirs_to_clean = ["dist", "build", "app.egg-info", "clove.egg-info"]
    for dir_name in dirs_to_clean:
        if Path(dir_name).exists():
            shutil.rmtree(dir_name)
            print(f"   Removed {dir_name}")


def check_node_installed():
    """Check if Node.js is installed."""
    try:
        result = run_command(["node", "--version"], check=False)
        if result.returncode == 0:
            print(f"   Node.js {result.stdout.strip()} detected")
            return True
    except FileNotFoundError:
        pass

    print("   Node.js not found. Please install Node.js to build the frontend.")
    return False


def check_pnpm_installed():
    """Check if pnpm is installed."""
    try:
        result = run_command(["pnpm", "--version"], check=False)
        if result.returncode == 0:
            print(f"   pnpm {result.stdout.strip()} detected")
            return True
    except FileNotFoundError:
        pass

    print("   pnpm not found. Installing pnpm...")
    run_command(["npm", "install", "-g", "pnpm"])
    return True


def build_frontend():
    """Build the frontend application."""
    print("\n Building frontend...")

    front_dir = Path("front")
    if not front_dir.exists():
        print("   Frontend directory not found")
        return False

    if not check_node_installed():
        return False

    if not check_pnpm_installed():
        return False

    if not (front_dir / "node_modules").exists():
        print("   Installing frontend dependencies...")
        run_command(["pnpm", "install"], cwd=front_dir)

    print("   Building frontend assets...")
    run_command(["pnpm", "run", "build"], cwd=front_dir)

    print("   Copying built files to app/static...")
    static_dir = Path("app/static")

    if static_dir.exists():
        shutil.rmtree(static_dir)

    shutil.copytree(front_dir / "dist", static_dir)
    print("   Frontend build complete")

    return True


def build_wheel():
    """Build the Python wheel."""
    print("\n Building Python wheel...")

    try:
        import build
    except ImportError:
        print("   Installing build tool...")
        run_command([sys.executable, "-m", "pip", "install", "build"])

    run_command([sys.executable, "-m", "build", "--wheel"])

    dist_dir = Path("dist")
    if dist_dir.exists():
        wheels = list(dist_dir.glob("*.whl"))
        if wheels:
            print(f"   Created wheel: {wheels[0].name}")
            return True

    print("   Failed to create wheel")
    return False


def parse_args():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="Build script for Clove - builds frontend and creates Python wheel."
    )
    parser.add_argument(
        "--skip-frontend",
        action="store_true",
        help="Skip frontend build and only build the Python wheel",
    )
    parser.add_argument(
        "--no-clean",
        action="store_true",
        help="Skip cleaning build directories before building",
    )
    return parser.parse_args()


def main():
    """Main build process."""
    args = parse_args()

    print(" Building Clove...")

    if not args.no_clean:
        clean_directories()

    if args.skip_frontend:
        print("\n  Frontend build skipped (--skip-frontend specified)")
        if not Path("app/static").exists():
            print(
                "  No static files found. The wheel will be built without frontend assets."
            )
            print(
                "   You may need to build the frontend separately or copy static files manually."
            )
    else:
        frontend_built = build_frontend()
        if not frontend_built:
            print("\n  Frontend build skipped. Using existing static files.")
            if not Path("app/static").exists():
                print(
                    " No static files found. Please build frontend manually or ensure app/static exists."
                )
                sys.exit(1)

    if build_wheel():
        print("\n Build complete!")
        print("\n Installation instructions:")
        print("  1. Install the wheel:")
        print("     pip install dist/*.whl")
        print("  2. Run Clove:")
        print("     clove")
        print("\n Note: You can also install in development mode:")
        print("     pip install -e .")
    else:
        print("\n Build failed!")
        sys.exit(1)


if __name__ == "__main__":
    main()
</file>

<file path="app/api/routes/claude.py">
from fastapi import APIRouter, Request
from fastapi.responses import StreamingResponse, JSONResponse
from tenacity import (
    retry,
    retry_if_exception,
    stop_after_attempt,
    wait_fixed,
)

from app.core.config import settings
from app.core.exceptions import NoResponseError
from app.dependencies.auth import AuthDep
from app.models.claude import MessagesAPIRequest
from app.processors.claude_ai import ClaudeAIContext
from app.processors.claude_ai.pipeline import ClaudeAIPipeline
from app.utils.retry import is_retryable_error, log_before_sleep

router = APIRouter()


@router.post("/messages", response_model=None)
@retry(
    retry=retry_if_exception(is_retryable_error),
    stop=stop_after_attempt(settings.retry_attempts),
    wait=wait_fixed(settings.retry_interval),
    before_sleep=log_before_sleep,
    reraise=True,
)
async def create_message(
    request: Request, messages_request: MessagesAPIRequest, _: AuthDep
) -> StreamingResponse | JSONResponse:
    context = ClaudeAIContext(
        original_request=request,
        messages_api_request=messages_request,
    )

    context = await ClaudeAIPipeline().process(context)

    if not context.response:
        raise NoResponseError()

    return context.response
</file>

<file path="app/api/routes/settings.py">
import os
import json
from typing import List
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel, HttpUrl

from app.dependencies.auth import AdminAuthDep
from app.core.config import Settings, settings


class SettingsRead(BaseModel):
    """Model for returning settings."""

    api_keys: List[str]
    admin_api_keys: List[str]

    proxy_url: str | None

    claude_ai_url: HttpUrl
    claude_api_baseurl: HttpUrl

    custom_prompt: str | None
    use_real_roles: bool
    human_name: str
    assistant_name: str
    padtxt_length: int
    allow_external_images: bool

    preserve_chats: bool

    oauth_client_id: str
    oauth_authorize_url: str
    oauth_token_url: str
    oauth_redirect_uri: str


class SettingsUpdate(BaseModel):
    """Model for updating settings."""

    api_keys: List[str] | None = None
    admin_api_keys: List[str] | None = None

    proxy_url: str | None = None

    claude_ai_url: HttpUrl | None = None
    claude_api_baseurl: HttpUrl | None = None

    custom_prompt: str | None = None
    use_real_roles: bool | None = None
    human_name: str | None = None
    assistant_name: str | None = None
    padtxt_length: int | None = None
    allow_external_images: bool | None = None

    preserve_chats: bool | None = None

    oauth_client_id: str | None = None
    oauth_authorize_url: str | None = None
    oauth_token_url: str | None = None
    oauth_redirect_uri: str | None = None


router = APIRouter()


@router.get("", response_model=SettingsRead)
async def get_settings(_: AdminAuthDep) -> Settings:
    """Get current settings."""
    return settings


@router.put("", response_model=SettingsUpdate)
async def update_settings(_: AdminAuthDep, updates: SettingsUpdate) -> Settings:
    """Update settings and save to config.json."""
    update_dict = updates.model_dump(exclude_unset=True)

    if not settings.no_filesystem_mode:
        config_path = settings.data_folder / "config.json"
        settings.data_folder.mkdir(parents=True, exist_ok=True)

        if os.path.exists(config_path):
            try:
                with open(config_path, "r", encoding="utf-8") as f:
                    config_data = SettingsUpdate.model_validate_json(f.read())
            except (json.JSONDecodeError, IOError):
                config_data = SettingsUpdate()
        else:
            config_data = SettingsUpdate()

        config_data = config_data.model_copy(update=update_dict)

        try:
            with open(config_path, "w", encoding="utf-8") as f:
                f.write(config_data.model_dump_json(exclude_unset=True))
        except IOError as e:
            raise HTTPException(
                status_code=500, detail=f"Failed to save config: {str(e)}"
            )

    for key, value in update_dict.items():
        if hasattr(settings, key):
            setattr(settings, key, value)

    return settings
</file>

<file path="app/processors/claude_ai/__init__.py">
from app.processors.claude_ai.context import ClaudeAIContext
from app.processors.claude_ai.pipeline import ClaudeAIPipeline
from app.processors.claude_ai.tavern_test_message_processor import TestMessageProcessor
from app.processors.claude_ai.claude_web_processor import ClaudeWebProcessor
from app.processors.claude_ai.claude_api_processor import ClaudeAPIProcessor
from app.processors.claude_ai.event_parser_processor import EventParsingProcessor
from app.processors.claude_ai.streaming_response_processor import (
    StreamingResponseProcessor,
)
from app.processors.claude_ai.message_collector_processor import (
    MessageCollectorProcessor,
)
from app.processors.claude_ai.non_streaming_response_processor import (
    NonStreamingResponseProcessor,
)
from app.processors.claude_ai.token_counter_processor import TokenCounterProcessor
from app.processors.claude_ai.tool_result_processor import ToolResultProcessor
from app.processors.claude_ai.tool_call_event_processor import ToolCallEventProcessor
from app.processors.claude_ai.stop_sequences_processor import StopSequencesProcessor
from app.processors.claude_ai.model_injector_processor import ModelInjectorProcessor

__all__ = [
    "ClaudeAIContext",
    "ClaudeAIPipeline",
    "TestMessageProcessor",
    "ClaudeWebProcessor",
    "ClaudeAPIProcessor",
    "EventParsingProcessor",
    "StreamingResponseProcessor",
    "MessageCollectorProcessor",
    "NonStreamingResponseProcessor",
    "TokenCounterProcessor",
    "ToolResultProcessor",
    "ToolCallEventProcessor",
    "StopSequencesProcessor",
    "ModelInjectorProcessor",
]
</file>

<file path="app/processors/claude_ai/claude_web_processor.py">
import time
import base64
import random
import string
from typing import List
from loguru import logger

from app.processors.base import BaseProcessor
from app.processors.claude_ai import ClaudeAIContext
from app.services.session import session_manager
from app.models.internal import ClaudeWebRequest, Attachment
from app.core.exceptions import NoValidMessagesError
from app.core.config import settings
from app.utils.messages import process_messages


class ClaudeWebProcessor(BaseProcessor):
    """Claude AI processor that handles session management, request building, and sending to Claude AI."""

    async def process(self, context: ClaudeAIContext) -> ClaudeAIContext:
        """
        Claude AI processor that:
        1. Gets or creates a Claude session
        2. Builds ClaudeWebRequest from messages_api_request
        3. Sends the request to Claude.ai

        Requires:
            - messages_api_request in context

        Produces:
            - claude_session in context
            - claude_web_request in context
            - original_stream in context
        """
        if context.original_stream:
            logger.debug("Skipping ClaudeWebProcessor due to existing original_stream")
            return context

        if not context.messages_api_request:
            logger.warning(
                "Skipping ClaudeWebProcessor due to missing messages_api_request"
            )
            return context

        # Step 1: Get or create Claude session
        if not context.claude_session:
            session_id = context.metadata.get("session_id")
            if not session_id:
                session_id = f"session_{int(time.time() * 1000)}"
                context.metadata["session_id"] = session_id

            logger.debug(f"Creating new session: {session_id}")
            context.claude_session = await session_manager.get_or_create_session(
                session_id
            )

        # Step 2: Build ClaudeWebRequest
        if not context.claude_web_request:
            request = context.messages_api_request

            if not request.messages:
                raise NoValidMessagesError()

            merged_text, images = await process_messages(
                request.messages, request.system
            )
            if not merged_text:
                raise NoValidMessagesError()

            if settings.padtxt_length > 0:
                pad_tokens = settings.pad_tokens or (
                    string.ascii_letters + string.digits
                )
                pad_text = "".join(random.choices(pad_tokens, k=settings.padtxt_length))
                merged_text = pad_text + merged_text
                logger.debug(
                    f"Added {settings.padtxt_length} padding tokens to the beginning of the message"
                )

            image_file_ids: List[str] = []
            if images:
                for i, image_source in enumerate(images):
                    try:
                        # Convert base64 to bytes
                        image_data = base64.b64decode(image_source.data)

                        # Upload to Claude
                        file_id = await context.claude_session.upload_file(
                            file_data=image_data,
                            filename=f"image_{i}.png",  # Default filename
                            content_type=image_source.media_type,
                        )
                        image_file_ids.append(file_id)
                        logger.debug(f"Uploaded image {i}: {file_id}")
                    except Exception as e:
                        logger.error(f"Failed to upload image {i}: {e}")

            await context.claude_session._ensure_conversation_initialized()

            paprika_mode = (
                "extended"
                if (
                    context.claude_session.account.is_pro
                    and request.thinking
                    and request.thinking.type in ("enabled", "adaptive")
                )
                else None
            )

            await context.claude_session.set_paprika_mode(paprika_mode)

            web_request = ClaudeWebRequest(
                max_tokens_to_sample=request.max_tokens,
                attachments=[Attachment.from_text(merged_text)],
                files=image_file_ids,
                model=request.model,
                rendering_mode="messages",
                prompt=settings.custom_prompt or "",
                timezone="UTC",
                tools=request.tools or [],
            )

            context.claude_web_request = web_request
            logger.debug(f"Built web request with {len(image_file_ids)} images")

        # Step 3: Send to Claude
        logger.debug(
            f"Sending request to Claude.ai for session {context.claude_session.session_id}"
        )

        request_dict = context.claude_web_request.model_dump(exclude_none=True)
        context.original_stream = await context.claude_session.send_message(
            request_dict
        )

        return context
</file>

<file path="app/services/cache.py">
import asyncio
import hashlib
import json
import threading
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple

from loguru import logger

from app.core.config import settings
from app.models.claude import (
    Base64ImageSource,
    FileImageSource,
    ImageContent,
    InputMessage,
    ContentBlock,
    ServerToolUseContent,
    TextContent,
    ThinkingContent,
    ToolResultContent,
    ToolUseContent,
    URLImageSource,
    WebSearchToolResultContent,
)


class CacheCheckpoint:
    """Cache checkpoint with timestamp."""

    def __init__(self, checkpoint: str, account_id: str):
        self.checkpoint = checkpoint
        self.account_id = account_id
        self.created_at = datetime.now()


class CacheService:
    """
    Service for managing prompt cache mapping to accounts.
    Ensures requests with cached prompts are sent to the same account.
    """

    _instance: Optional["CacheService"] = None
    _lock = threading.Lock()

    def __new__(cls):
        """Implement singleton pattern."""
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self):
        """Initialize the CacheService."""
        # Maps checkpoint hash -> CacheCheckpoint
        self._checkpoints: Dict[str, CacheCheckpoint] = {}
        self._cleanup_task: Optional[asyncio.Task] = None

        logger.info(
            f"CacheService initialized with timeout={settings.cache_timeout}s, "
            f"cleanup_interval={settings.cache_cleanup_interval}s"
        )

    def process_messages(
        self,
        model: str,
        messages: List[InputMessage],
        system: Optional[List[TextContent]] = None,
    ) -> Tuple[Optional[str], List[str]]:
        """
        Process messages to find cached account and extract new checkpoints.

        Args:
            messages: List of input messages
            system: Optional system messages

        Returns:
            Tuple of (account_id, checkpoints) where:
            - account_id: The account ID if a cached prompt was found, None otherwise
            - checkpoints: List of feature values for content blocks with cache_control
        """
        account_id: Optional[str] = None
        checkpoints: List[str] = []

        hasher = hashlib.sha256()

        self._update_hasher(hasher, {"model": model})

        if system:
            for text_content in system:
                content_block_data = self._content_block_to_dict(text_content)
                self._update_hasher(hasher, content_block_data)

                feature_value = hasher.hexdigest()

                if text_content.cache_control:
                    checkpoints.append(feature_value)

                if feature_value in self._checkpoints:
                    account_id = self._checkpoints[feature_value].account_id

        for message in messages:
            self._update_hasher(hasher, {"role": message.role.value})

            if isinstance(message.content, str):
                self._update_hasher(hasher, {"type": "text", "text": message.content})
            elif isinstance(message.content, list):
                for content_block in message.content:
                    content_block_data = self._content_block_to_dict(content_block)
                    self._update_hasher(hasher, content_block_data)

                    feature_value = hasher.hexdigest()

                    if (
                        hasattr(content_block, "cache_control")
                        and content_block.cache_control
                    ):
                        checkpoints.append(feature_value)

                    if feature_value in self._checkpoints:
                        account_id = self._checkpoints[feature_value].account_id

        if account_id:
            logger.debug(
                f"Cache hit: account_id={account_id}, feature={feature_value[:16]}..."
            )

        return account_id, checkpoints

    def add_checkpoints(self, checkpoints: List[str], account_id: str) -> None:
        """
        Add checkpoint mappings to the cache.

        Args:
            checkpoints: List of feature values to map
            account_id: Account ID to map to
        """
        for checkpoint in checkpoints:
            self._checkpoints[checkpoint] = CacheCheckpoint(checkpoint, account_id)
            logger.debug(
                f"Added checkpoint mapping: {checkpoint[:16]}... -> {account_id}"
            )

        logger.debug(
            f"Cache updated: {len(checkpoints)} checkpoints added. "
            f"Total cache size: {len(self._checkpoints)}"
        )

    def _update_hasher(self, hasher: "hashlib._Hash", data: Dict) -> None:
        """
        Update the hasher with new data in a consistent way.

        Args:
            hasher: The hash object to update
            data: Dictionary data to add to the hash
        """
        # Serialize data in a consistent way
        json_str = json.dumps(data, sort_keys=True, separators=(",", ":"))

        # Add a delimiter to ensure proper separation between blocks
        hasher.update(b"\x00")  # NULL byte as delimiter
        hasher.update(json_str.encode("utf-8"))

    def _content_block_to_dict(self, content_block: ContentBlock) -> Dict:
        """
        Convert a ContentBlock to a dictionary for hashing.
        Only includes relevant fields for cache matching.
        """
        result = {"type": content_block.type}

        if isinstance(content_block, TextContent):
            result["text"] = content_block.text
        elif isinstance(content_block, ThinkingContent):
            result["thinking"] = content_block.thinking
        elif isinstance(content_block, ToolUseContent) or isinstance(
            content_block, ServerToolUseContent
        ):
            result["id"] = content_block.id
        elif isinstance(content_block, ToolResultContent) or isinstance(
            content_block, WebSearchToolResultContent
        ):
            result["tool_use_id"] = content_block.tool_use_id
        elif isinstance(content_block, ImageContent):
            result["source_type"] = content_block.source.type
            if isinstance(content_block.source, Base64ImageSource):
                result["source_data"] = content_block.source.data
            elif isinstance(content_block.source, URLImageSource):
                result["source_url"] = content_block.source.url
            elif isinstance(content_block.source, FileImageSource):
                result["source_file"] = content_block.source.file_uuid

        return result

    async def start_cleanup_task(self) -> None:
        """Start the background task for cleaning up expired cache checkpoints."""
        if self._cleanup_task is None or self._cleanup_task.done():
            self._cleanup_task = asyncio.create_task(self._cleanup_loop())
            logger.info("Started cache cleanup task")

    async def stop_cleanup_task(self) -> None:
        """Stop the background cleanup task."""
        if self._cleanup_task and not self._cleanup_task.done():
            self._cleanup_task.cancel()
            try:
                await self._cleanup_task
            except asyncio.CancelledError:
                pass
            logger.info("Stopped cache cleanup task")

    async def _cleanup_loop(self) -> None:
        """Background loop to clean up expired cache checkpoints."""
        while True:
            try:
                self._cleanup_expired_checkpoints()
                await asyncio.sleep(settings.cache_cleanup_interval)
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Error in cache cleanup loop: {e}")
                await asyncio.sleep(settings.cache_cleanup_interval)

    def _cleanup_expired_checkpoints(self) -> None:
        """Clean up all expired cache checkpoints."""
        current_time = datetime.now()
        timeout_duration = timedelta(seconds=settings.cache_timeout)
        expired_checkpoints = []

        for checkpoint_hash, cache_checkpoint in self._checkpoints.items():
            if (current_time - cache_checkpoint.created_at) > timeout_duration:
                expired_checkpoints.append(checkpoint_hash)

        for checkpoint_hash in expired_checkpoints:
            del self._checkpoints[checkpoint_hash]

        if expired_checkpoints:
            logger.info(
                f"Cleaned up {len(expired_checkpoints)} expired cache checkpoints"
            )

    async def cleanup_all(self) -> None:
        """Clean up all cache checkpoints and stop the cleanup task."""
        await self.stop_cleanup_task()
        self._checkpoints.clear()
        logger.info("Cleaned up all cache checkpoints")

    def __repr__(self) -> str:
        """String representation of the CacheService."""
        return f"<CacheService checkpoints={len(self._checkpoints)}>"


cache_service = CacheService()
</file>

<file path="app/services/session.py">
import asyncio
from typing import Dict, Optional
from datetime import datetime, timedelta
import threading
from loguru import logger

from app.core.config import settings
from app.core.claude_session import ClaudeWebSession


class SessionManager:
    """
    Singleton manager for Claude sessions with automatic cleanup.
    """

    _instance: Optional["SessionManager"] = None
    _lock = threading.Lock()

    def __new__(cls):
        """Implement singleton pattern."""
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self):
        """Initialize the SessionManager."""
        self._sessions: Dict[str, ClaudeWebSession] = {}
        self._session_lock = asyncio.Lock()
        self._cleanup_task: Optional[asyncio.Task] = None
        self._session_timeout = settings.session_timeout
        self._cleanup_interval = settings.session_cleanup_interval

        logger.info(
            f"SessionManager initialized with timeout={self._session_timeout}s, "
            f"cleanup_interval={self._cleanup_interval}s"
        )

    async def get_or_create_session(self, session_id: str) -> ClaudeWebSession:
        """
        Get or create a new Claude session.

        Args:
            session_id: Unique identifier for the session

        Returns:
            Created ClaudeSession instance
        """
        async with self._session_lock:
            if session_id in self._sessions:
                return self._sessions[session_id]

            session = ClaudeWebSession(session_id)
            await session.initialize()
            self._sessions[session_id] = session

            logger.debug(f"Created new session: {session_id}")
            return session

    async def get_session(self, session_id: str) -> Optional[ClaudeWebSession]:
        """
        Get a session by ID.

        Args:
            session_id: Unique identifier for the session

        Returns:
            ClaudeSession instance if found, None otherwise
        """
        async with self._session_lock:
            session = self._sessions.get(session_id)

            if session:
                # Check if session is expired
                if await self._is_session_expired(session):
                    logger.debug(f"Session {session_id} is expired, removing")
                    await self._remove_session(session_id)
                    return None

            return session

    async def remove_session(self, session_id: str) -> None:
        """
        Remove a session by ID.

        Args:
            session_id: Unique identifier for the session
        """
        async with self._session_lock:
            if session_id in self._sessions:
                await self._remove_session(session_id)

    async def _is_session_expired(self, session: ClaudeWebSession) -> bool:
        """
        Check if a session is expired.

        A session is considered expired if its last_activity is older than session_timeout.

        Args:
            session: Session to check

        Returns:
            True if session is expired, False otherwise
        """
        current_time = datetime.now()
        timeout_duration = timedelta(seconds=self._session_timeout)

        return (current_time - session.last_activity) > timeout_duration

    async def _remove_session(self, session_id: str) -> None:
        """
        Remove a session and cleanup its resources.

        Note: This method should be called while holding the session lock.

        Args:
            session_id: ID of the session to remove
        """
        if session_id in self._sessions:
            session = self._sessions[session_id]
            asyncio.create_task(session.cleanup())  # Cleanup session asynchronously

            # Remove from sessions dict (should already have the lock)
            if session_id in self._sessions:
                del self._sessions[session_id]
            logger.debug(f"Removed session: {session_id}")

    async def start_cleanup_task(self) -> None:
        """Start the background task for cleaning up expired sessions."""
        if self._cleanup_task is None or self._cleanup_task.done():
            self._cleanup_task = asyncio.create_task(self._cleanup_loop())
            logger.info("Started session cleanup task")

    async def stop_cleanup_task(self) -> None:
        """Stop the background cleanup task."""
        if self._cleanup_task and not self._cleanup_task.done():
            self._cleanup_task.cancel()
            try:
                await self._cleanup_task
            except asyncio.CancelledError:
                pass
            logger.info("Stopped session cleanup task")

    async def _cleanup_loop(self) -> None:
        """Background loop to clean up expired sessions."""
        while True:
            try:
                await self._cleanup_expired_sessions()
                await asyncio.sleep(self._cleanup_interval)
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Error in cleanup loop: {e}")
                await asyncio.sleep(self._cleanup_interval)

    async def _cleanup_expired_sessions(self) -> None:
        """Clean up all expired sessions."""
        async with self._session_lock:
            expired_sessions = []

            for session_id, session in self._sessions.items():
                if await self._is_session_expired(session):
                    expired_sessions.append(session_id)

            for session_id in expired_sessions:
                await self._remove_session(session_id)

            if expired_sessions:
                logger.info(f"Cleaned up {len(expired_sessions)} expired sessions")

    async def cleanup_all(self) -> None:
        """Clean up all sessions and stop the cleanup task."""
        await self.stop_cleanup_task()

        async with self._session_lock:
            session_ids = list(self._sessions.keys())

            for session_id in session_ids:
                await self._remove_session(session_id)

        logger.info("Cleaned up all sessions")

    def __repr__(self) -> str:
        """String representation of the SessionManager."""
        return f"<SessionManager sessions={len(self._sessions)}>"


session_manager = SessionManager()
</file>

<file path="docker-compose.yml">
version: "3.8"

services:
  clove:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: clove
    restart: unless-stopped
    ports:
      - "5201:5201"
    volumes:
      - ./data:/data
    environment:
      # Server configuration
      - HOST=0.0.0.0
      - PORT=5201

      # Data storage
      - DATA_FOLDER=/data

      # API Keys (comma-separated)
      # - API_KEYS=your-api-key-1,your-api-key-2
      # - ADMIN_API_KEYS=your-admin-key-1,your-admin-key-2

      # Claude cookies (comma-separated)
      # - COOKIES=your-claude-cookie-1,your-claude-cookie-2

      # Proxy configuration (optional)
      # - PROXY_URL=http://proxy-server:port

      # Claude URLs (optional, defaults are usually fine)
      # - CLAUDE_AI_URL=https://claude.ai
      # - CLAUDE_API_BASEURL=https://api.anthropic.com

      # Logging
      - LOG_LEVEL=INFO
      - LOG_TO_FILE=true
      - LOG_FILE_PATH=/data/logs/app.log

volumes:
  data:
    driver: local
</file>

<file path="Dockerfile.huggingface">
# Simplified Dockerfile for Clove - For Huggingface Spaces
FROM python:3.11-slim

WORKDIR /app

# Install clove-proxy from PyPI
RUN pip install --no-cache-dir "clove-proxy[rnet]"

# Environment variables
ENV NO_FILESYSTEM_MODE=true
ENV HOST=0.0.0.0
ENV PORT=${PORT:-7860}

# Expose port
EXPOSE ${PORT:-7860}

# Run the application using the installed script
CMD ["clove"]
</file>

<file path="front/src/api/types.ts">
// Account types
export interface OAuthToken {
    access_token: string
    refresh_token: string
    expires_at: number
}

export interface AccountCreate {
    cookie_value?: string
    oauth_token?: OAuthToken
    organization_uuid?: string
    capabilities?: string[]
}

export interface AccountUpdate {
    cookie_value?: string
    oauth_token?: OAuthToken
    capabilities?: string[]
    status?: 'valid' | 'invalid' | 'rate_limited'
    preferred_auth?: 'auto' | 'oauth' | 'web'
}

export interface OAuthCodeExchange {
    organization_uuid: string
    code: string
    pkce_verifier: string
    capabilities?: string[]
}

export interface AccountResponse {
    organization_uuid: string
    capabilities?: string[]
    cookie_value?: string // Masked value
    status: 'valid' | 'invalid' | 'rate_limited'
    auth_type: 'cookie_only' | 'oauth_only' | 'both'
    preferred_auth: 'auto' | 'oauth' | 'web'
    is_pro: boolean
    is_max: boolean
    has_oauth: boolean
    last_used: string
    resets_at?: string
}

// Settings types
export interface SettingsRead {
    api_keys: string[]
    admin_api_keys: string[]
    proxy_url?: string | null
    claude_ai_url: string
    claude_api_baseurl: string
    custom_prompt?: string | null
    use_real_roles: boolean
    human_name: string
    assistant_name: string
    padtxt_length: number
    allow_external_images: boolean
    preserve_chats: boolean
    oauth_client_id: string
    oauth_authorize_url: string
    oauth_token_url: string
    oauth_redirect_uri: string
}

export interface SettingsUpdate {
    api_keys?: string[]
    admin_api_keys?: string[]
    proxy_url?: string | null
    claude_ai_url?: string
    claude_api_baseurl?: string
    custom_prompt?: string | null
    use_real_roles?: boolean
    human_name?: string
    assistant_name?: string
    padtxt_length?: number
    allow_external_images?: boolean
    preserve_chats?: boolean
    oauth_client_id?: string
    oauth_authorize_url?: string
    oauth_token_url?: string
    oauth_redirect_uri?: string
}

export interface ApiError {
    detail: string
}

// Statistics types
export interface AccountStats {
    total_accounts: number
    valid_accounts: number
    rate_limited_accounts: number
    invalid_accounts: number
    active_sessions: number
}

export interface StatisticsResponse {
    status: 'healthy' | 'degraded'
    accounts: AccountStats
}
</file>

<file path="front/src/components/AccountModal.tsx">
import { useState, useEffect } from 'react'
import { useTranslation } from 'react-i18next'
import { ChevronDown, ChevronUp, Loader2, AlertCircle } from 'lucide-react'
import type { AccountResponse, AccountCreate, AccountUpdate } from '../api/types'
import { accountsApi } from '../api/client'
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from '@/components/ui/dialog'
import { Drawer, DrawerContent, DrawerDescription, DrawerFooter, DrawerHeader, DrawerTitle } from '@/components/ui/drawer'
import { Button } from '@/components/ui/button'
import { Label } from '@/components/ui/label'
import { Textarea } from '@/components/ui/textarea'
import { Input } from '@/components/ui/input'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from '@/components/ui/collapsible'
import {
    AlertDialog,
    AlertDialogAction,
    AlertDialogCancel,
    AlertDialogContent,
    AlertDialogDescription,
    AlertDialogFooter,
    AlertDialogHeader,
    AlertDialogTitle,
} from '@/components/ui/alert-dialog'
import { useIsMobile } from '@/hooks/use-mobile'
import { isValidUUID, formatUUID } from '@/utils/validators'

interface AccountModalProps {
    account: AccountResponse | null
    onClose: () => void
}

export function AccountModal({ account, onClose }: AccountModalProps) {
    const { t } = useTranslation()
    const [formData, setFormData] = useState({
        cookie_value: '',
        organization_uuid: '',
        capabilities: [] as string[],
        preferred_auth: 'auto' as 'auto' | 'oauth' | 'web',
    })
    const [accountType, setAccountType] = useState<'none' | 'Free' | 'Pro' | 'Max'>('none')
    const [loading, setLoading] = useState(false)
    const [showAdvanced, setShowAdvanced] = useState(false)
    const [showCookieAlert, setShowCookieAlert] = useState(false)
    const [uuidError, setUuidError] = useState('')
    const isMobile = useIsMobile()

    useEffect(() => {
        if (account) {
            setFormData({
                cookie_value: '',
                organization_uuid: account.organization_uuid,
                capabilities: account.capabilities || [],
                preferred_auth: account.preferred_auth || 'auto',
            })

            const caps = account.capabilities || []
            if (caps.length === 0) {
                setAccountType('none')
            } else if (caps.includes('claude_max')) {
                setAccountType('Max')
            } else if (caps.includes('claude_pro')) {
                setAccountType('Pro')
            } else {
                setAccountType('Free')
            }
        }
    }, [account])

    const validateAndProcessCookie = (cookieValue: string): { isValid: boolean; processedValue: string } => {
        let processedValue = cookieValue.trim()

        if (processedValue.startsWith('sk-ant-sid01-')) {
            processedValue = `sessionKey=${processedValue}`
        }

        const isValid = processedValue.startsWith('sessionKey=sk-ant-sid01-')

        return { isValid, processedValue }
    }

    const handleSubmitForm = async (e: React.FormEvent) => {
        e.preventDefault()

        if (formData.cookie_value) {
            const { isValid, processedValue } = validateAndProcessCookie(formData.cookie_value)

            formData.cookie_value = processedValue
            setFormData({ ...formData, cookie_value: processedValue })

            if (!isValid) {
                setShowCookieAlert(true)
                return
            }
        }

        await handleSubmitAccount()
    }

    const handleSubmitAccount = async () => {
        setLoading(true)

        let capabilities: string[] | undefined
        switch (accountType) {
            case 'Free':
                capabilities = ['chat']
                break
            case 'Pro':
                capabilities = ['chat', 'claude_pro']
                break
            case 'Max':
                capabilities = ['chat', 'claude_max']
                break
            case 'none':
                capabilities = undefined
                break
        }

        try {
            if (account) {
                // Update account
                const updateData: AccountUpdate = {}

                if (formData.cookie_value && formData.cookie_value !== account.cookie_value) {
                    updateData.cookie_value = formData.cookie_value
                }

                if (capabilities) {
                    updateData.capabilities = capabilities
                }

                // Update preferred_auth if changed
                if (formData.preferred_auth !== account.preferred_auth) {
                    updateData.preferred_auth = formData.preferred_auth
                }

                await accountsApi.update(account.organization_uuid, updateData)
            } else {
                // Create new account
                const createData: AccountCreate = {}

                if (formData.cookie_value) {
                    createData.cookie_value = formData.cookie_value
                }

                if (formData.organization_uuid) {
                    createData.organization_uuid = formatUUID(formData.organization_uuid)
                }

                if (capabilities) {
                    createData.capabilities = capabilities
                }

                await accountsApi.create(createData)
            }

            onClose()
        } finally {
            setLoading(false)
        }
    }

    const handleCookieAlertConfirm = async () => {
        setShowCookieAlert(false)
        await handleSubmitAccount()
    }

    const cookieAlertDialog = (
        <AlertDialog open={showCookieAlert} onOpenChange={setShowCookieAlert}>
            <AlertDialogContent>
                <AlertDialogHeader>
                    <AlertDialogTitle>{t('accountModal.cookieWarningTitle')}</AlertDialogTitle>
                    <AlertDialogDescription>
                        {t('accountModal.cookieWarningDesc')}
                        <br />
                        <br />
                        {t('accountModal.cookieWarningNote')}
                    </AlertDialogDescription>
                </AlertDialogHeader>
                <AlertDialogFooter>
                    <AlertDialogCancel>{t('common.cancel')}</AlertDialogCancel>
                    <AlertDialogAction onClick={handleCookieAlertConfirm}>{t('accountModal.submitAnyway')}</AlertDialogAction>
                </AlertDialogFooter>
            </AlertDialogContent>
        </AlertDialog>
    )

    const formContent = (
        <>
            <div className='grid gap-4 py-4'>
                <div className='space-y-2'>
                    <Label htmlFor='cookie_value'>
                        Cookie <span className='text-destructive'>*</span>
                    </Label>
                    <Textarea
                        id='cookie_value'
                        placeholder={t('accountModal.cookiePlaceholder')}
                        value={formData.cookie_value}
                        onChange={e => setFormData({ ...formData, cookie_value: e.target.value })}
                        className='min-h-[100px] font-mono text-sm break-all'
                        required
                    />
                </div>

                <Collapsible open={showAdvanced} onOpenChange={setShowAdvanced}>
                    <CollapsibleTrigger asChild>
                        <Button variant='outline' type='button' className='w-full justify-between'>
                            <span>{t('accountModal.advancedOptions')}</span>
                            {showAdvanced ? <ChevronUp className='h-4 w-4' /> : <ChevronDown className='h-4 w-4' />}
                        </Button>
                    </CollapsibleTrigger>
                    <CollapsibleContent className='space-y-4 mt-4'>
                        {!account && (
                            <div className='space-y-2'>
                                <Label htmlFor='organization_uuid'>Organization UUID</Label>
                                <Input
                                    id='organization_uuid'
                                    placeholder={t('accountModal.orgUuidPlaceholder')}
                                    value={formData.organization_uuid}
                                    onChange={e => {
                                        const value = e.target.value
                                        setFormData({ ...formData, organization_uuid: value })
                                        const formatted = formatUUID(value)
                                        if (formatted && !isValidUUID(formatted)) {
                                            setUuidError(t('accountModal.invalidUuid'))
                                        } else {
                                            setUuidError('')
                                        }
                                    }}
                                    className={uuidError && formData.organization_uuid ? 'border-destructive' : ''}
                                />
                                {uuidError && formData.organization_uuid && (
                                    <div className='flex items-center gap-1 text-sm text-destructive'>
                                        <AlertCircle className='h-3 w-3' />
                                        <span>{uuidError}</span>
                                    </div>
                                )}
                            </div>
                        )}

                        <div className='space-y-2'>
                            <Label htmlFor='accountType'>{t('accountModal.accountType')}</Label>
                            <Select value={accountType} onValueChange={value => setAccountType(value as any)}>
                                <SelectTrigger className='w-full' id='accountType'>
                                    <SelectValue placeholder={t('accountModal.selectAccountType')} />
                                </SelectTrigger>
                                <SelectContent>
                                    <SelectItem value='none'>{t('accountModal.notSelected')}</SelectItem>
                                    <SelectItem value='Free'>Free</SelectItem>
                                    <SelectItem value='Pro'>Pro</SelectItem>
                                    <SelectItem value='Max'>Max</SelectItem>
                                </SelectContent>
                            </Select>
                        </div>

                        {account && account.auth_type === 'both' && (
                            <div className='space-y-2'>
                                <Label htmlFor='preferredAuth'>{t('accountModal.preferredAuth')}</Label>
                                <Select
                                    value={formData.preferred_auth}
                                    onValueChange={value => setFormData({ ...formData, preferred_auth: value as any })}
                                >
                                    <SelectTrigger className='w-full' id='preferredAuth'>
                                        <SelectValue placeholder={t('accountModal.selectPreferredAuth')} />
                                    </SelectTrigger>
                                    <SelectContent>
                                        <SelectItem value='auto'>{t('accountModal.authAuto')}</SelectItem>
                                        <SelectItem value='oauth'>{t('accountModal.authOAuthOnly')}</SelectItem>
                                        <SelectItem value='web'>{t('accountModal.authWebOnly')}</SelectItem>
                                    </SelectContent>
                                </Select>
                                <p className='text-xs text-muted-foreground'>
                                    {t('accountModal.preferredAuthDesc')}
                                </p>
                            </div>
                        )}
                    </CollapsibleContent>
                </Collapsible>
            </div>
        </>
    )

    const footerContent = (
        <>
            <Button type='button' variant='outline' onClick={onClose}>
                {t('common.cancel')}
            </Button>
            <Button
                type='submit'
                disabled={
                    loading ||
                    !formData.cookie_value.trim() ||
                    (!!formData.organization_uuid && !isValidUUID(formatUUID(formData.organization_uuid)))
                }
            >
                {loading && <Loader2 className='mr-2 h-4 w-4 animate-spin' />}
                {loading ? t('common.saving') : t('common.save')}
            </Button>
        </>
    )

    if (isMobile === undefined) {
        return null
    }

    if (!isMobile) {
        return (
            <>
                <Dialog open={true} onOpenChange={onClose}>
                    <DialogContent className='sm:max-w-[600px]'>
                        <form onSubmit={handleSubmitForm}>
                            <DialogHeader>
                                <DialogTitle>{account ? t('accountModal.titleEdit') : t('accountModal.titleAdd')}</DialogTitle>
                                <DialogDescription>
                                    {account ? t('accountModal.descEdit') : t('accountModal.descAdd')}
                                </DialogDescription>
                            </DialogHeader>
                            {formContent}
                            <DialogFooter>{footerContent}</DialogFooter>
                        </form>
                    </DialogContent>
                </Dialog>
                {cookieAlertDialog}
            </>
        )
    }

    return (
        <>
            <Drawer open={true} onOpenChange={onClose}>
                <DrawerContent>
                    <form onSubmit={handleSubmitForm} className='max-h-[90vh] overflow-auto'>
                        <DrawerHeader>
                            <DrawerTitle>{account ? t('accountModal.titleEdit') : t('accountModal.titleAdd')}</DrawerTitle>
                            <DrawerDescription>
                                {account ? t('accountModal.descEdit') : t('accountModal.descAdd')}
                            </DrawerDescription>
                        </DrawerHeader>
                        <div className='px-4'>{formContent}</div>
                        <DrawerFooter className='flex-row justify-end space-x-2'>{footerContent}</DrawerFooter>
                    </form>
                </DrawerContent>
            </Drawer>
            {cookieAlertDialog}
        </>
    )
}
</file>

<file path=".dockerignore">
# Git
.git/
.gitignore
.gitattributes

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST
.pytest_cache/
.coverage
.coverage.*
.cache
htmlcov/
.tox/
.nox/
*.cover
*.py,cover
.hypothesis/
.mypy_cache/
.dmypy.json
dmypy.json
.pyre/
.pytype/
.ruff_cache/
# uv.lock uv 

# Virtual environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/
.envrc

# Node.js / Frontend
**/node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
.pnpm-store/
lerna-debug.log*
.npm
.eslintcache
.stylelintcache
.node_repl_history
*.tsbuildinfo
.yarn/
.pnp.*

# Frontend build outputs (will be built in Docker)
front/dist/
front/build/
app/static/assets/
app/static/index.html
app/static/vite.svg

# IDEs and editors
.vscode/
.idea/
*.swp
*.swo
*~
.DS_Store
Thumbs.db
*.sublime-project
*.sublime-workspace
.project
.classpath
.c9/
*.launch
.settings/
*.iml
.cursorignore
.cursorindexingignore

# OS files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Desktop.ini

# Documentation
docs/
*.md
!README.md
LICENSE

# Testing
coverage/
.nyc_output/
test/
tests/
*.test.js
*.spec.js
__tests__/

# Logs
*.log
logs/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# Temporary files
*.tmp
*.temp
.tmp/
.temp/
tmp/
temp/

# Local data (contains sensitive information)
data/
/data/
*.json
!package.json
!tsconfig*.json
!components.json
!app/locales/*.json

# CI/CD
.github/
.gitlab-ci.yml
.travis.yml
.circleci/
Jenkinsfile

# Docker files
Dockerfile*
docker-compose*.yml
.dockerignore

# Makefile and scripts
Makefile
scripts/

# Python packaging files
MANIFEST.in
setup.py
setup.cfg

# Miscellaneous
*.bak
*.orig
*.rej
.cache/
</file>

<file path=".env.example">
# Clove - Claude API AI Configuration Example
# Copy this file to .env and modify the values as needed

# =============================================================================
# Server Settings
# =============================================================================

# Server host address (default: 0.0.0.0)
HOST=0.0.0.0

# Server port (default: 5201)
PORT=5201

# =============================================================================
# Application Configuration
# =============================================================================

# Folder path for storing persistent data (accounts, etc.)
#DATA_FOLDER=~/.clove/data

# Folder path for storing translation files
#LOCALES_FOLDER=

# Folder path for storing static files
#STATIC_FOLDER=

# Default language code for translations
#DEFAULT_LANGUAGE=en

# Number of retry attempts for failed requests (default: 3)
#RETRY_ATTEMPTS=3

# Interval between retry attempts in seconds (default: 1)
#RETRY_INTERVAL=1

# =============================================================================
# Proxy Settings
# =============================================================================

# HTTP/HTTPS proxy URL (optional)
# PROXY_URL=http://proxy.example.com:8080

# =============================================================================
# API Keys
# =============================================================================

# Comma-separated list of API keys for authentication
# API_KEYS=your-api-key-1,your-api-key-2

# Comma-separated list of admin API keys for management
# ADMIN_API_KEYS=your-admin-api-key-1,your-admin-api-key-2

# =============================================================================
# Claude URLs
# =============================================================================

# Claude AI web interface URL
#CLAUDE_AI_URL=https://claude.ai

# Claude API base URL
#CLAUDE_API_BASEURL=https://api.anthropic.com

# =============================================================================
# Cookies
# =============================================================================

# Comma-separated list of Claude.ai cookies for web interface access
# COOKIES=sessionKey=your-session-key,sessionKey=your-session-key-2

# =============================================================================
# Content Processing
# =============================================================================

# Custom prompt to prepend to all requests (optional)
# CUSTOM_PROMPT=You are a helpful assistant.

# Use real role names in conversation (default: true)
#USE_REAL_ROLES=true

# Custom name for human role (default: Human)
#CUSTOM_HUMAN_NAME=Human

# Custom name for assistant role (default: Assistant)
#CUSTOM_ASSISTANT_NAME=Assistant

# Padding tokens for content processing (comma-separated)
# PAD_TOKENS=token1,token2

# Padding text length (default: 0)
#PADTXT_LENGTH=0

# Allow downloading images from external URLs (default: false)
#ALLOW_EXTERNAL_IMAGES=false

# =============================================================================
# Request Settings
# =============================================================================

# Request timeout in seconds (default: 60)
#REQUEST_TIMEOUT=60

# Number of retries for failed requests (default: 3)
#REQUEST_RETRIES=3

# Interval between retries in seconds (default: 1)
#REQUEST_RETRY_INTERVAL=1

# =============================================================================
# Feature Flags
# =============================================================================

# Preserve chat history (default: false)
#PRESERVE_CHATS=false

# =============================================================================
# Logging Configuration
# =============================================================================

# Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
#LOG_LEVEL=INFO

# Enable logging to file (default: false)
#LOG_TO_FILE=false

# Log file path (default: logs/app.log)
#LOG_FILE_PATH=logs/app.log

# Log file rotation (e.g., '10 MB', '1 day', '1 week')
#LOG_FILE_ROTATION=10 MB

# Log file retention (e.g., '7 days', '1 month')
#LOG_FILE_RETENTION=7 days

# Log file compression format (default: zip)
#LOG_FILE_COMPRESSION=zip

# =============================================================================
# Session Management
# =============================================================================

# Session idle timeout in seconds (default: 300)
#SESSION_TIMEOUT=300

# Interval for cleaning up expired sessions in seconds (default: 30)
#SESSION_CLEANUP_INTERVAL=30

# Maximum number of concurrent sessions per cookie (default: 3)
#MAX_SESSIONS_PER_COOKIE=3

# =============================================================================
# Account Management
# =============================================================================

# Interval for account management task in seconds (default: 60)
#ACCOUNT_TASK_INTERVAL=60

# =============================================================================
# Tool Call Settings
# =============================================================================

# Timeout for pending tool calls in seconds (default: 300)
#TOOL_CALL_TIMEOUT=300

# Interval for cleaning up expired tool calls in seconds (default: 60)
#TOOL_CALL_CLEANUP_INTERVAL=60

# =============================================================================
# Claude OAuth Settings
# =============================================================================

# OAuth client ID for Claude authentication
#OAUTH_CLIENT_ID=9d1c250a-e61b-44d9-88ed-5944d1962f5e

# OAuth authorization endpoint URL template
#OAUTH_AUTHORIZE_URL=https://claude.ai/v1/oauth/{organization_uuid}/authorize

# OAuth token exchange endpoint URL
#OAUTH_TOKEN_URL=https://console.anthropic.com/v1/oauth/token

# OAuth redirect URI for authorization flow
#OAUTH_REDIRECT_URI=https://console.anthropic.com/oauth/code/callback
</file>

<file path=".github/workflows/docker-publish.yml">
name: Docker Build and Push

on:
  push:
    branches:
      - main
    tags:
      - "v*"
  pull_request:
    branches:
      - main
  workflow_dispatch:

env:
  DOCKER_HUB_USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
  DOCKER_HUB_TOKEN: ${{ secrets.DOCKER_HUB_TOKEN }}
  IMAGE_NAME: mirrorange/clove

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      security-events: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKER_HUB_USERNAME }}
          password: ${{ env.DOCKER_HUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Run security scan
        if: github.event_name != 'pull_request'
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.version }}
          format: "sarif"
          output: "trivy-results.sarif"

      - name: Upload Trivy scan results to GitHub Security tab
        if: github.event_name != 'pull_request'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: "trivy-results.sarif"
</file>

<file path="app/main.py">
from loguru import logger
from contextlib import asynccontextmanager
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from app.api.main import api_router
from app.core.config import settings
from app.core.error_handler import app_exception_handler
from app.core.exceptions import AppError
from app.core.static import register_static_routes
from app.utils.logger import configure_logger
from app.services.account import account_manager
from app.services.session import session_manager
from app.services.tool_call import tool_call_manager
from app.services.cache import cache_service


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan manager."""
    logger.info("Starting Clove...")

    configure_logger()

    # Load accounts
    account_manager.load_accounts()

    for cookie in settings.cookies:
        await account_manager.add_account(cookie_value=cookie)

    # Start tasks
    await account_manager.start_task()
    await session_manager.start_cleanup_task()
    await tool_call_manager.start_cleanup_task()
    await cache_service.start_cleanup_task()

    yield

    logger.info("Shutting down Clove...")

    # Save accounts
    account_manager.save_accounts()

    # Stop tasks
    await account_manager.stop_task()
    await session_manager.cleanup_all()
    await tool_call_manager.cleanup_all()
    await cache_service.cleanup_all()


app = FastAPI(
    title="Clove",
    description="A Claude.ai reverse proxy",
    version="0.1.0",
    lifespan=lifespan,
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers
app.include_router(api_router)

# Static files
register_static_routes(app)

# Exception handlers
app.add_exception_handler(AppError, app_exception_handler)


# Health check
@app.get("/health")
async def health():
    """Health check endpoint."""
    stats = await account_manager.get_status()
    return {"status": "healthy" if stats["valid_accounts"] > 0 else "degraded"}


def main():
    """Main entry point for the application."""
    import uvicorn

    uvicorn.run(
        "app.main:app",
        host=settings.host,
        port=settings.port,
        reload=False,
    )


if __name__ == "__main__":
    main()
</file>

<file path="app/models/claude.py">
from typing import Optional, List, Union, Literal, Dict, Any
from pydantic import BaseModel, ConfigDict, Field, model_validator
from enum import Enum


class Role(str, Enum):
    USER = "user"
    ASSISTANT = "assistant"


class ImageType(str, Enum):
    JPEG = "image/jpeg"
    PNG = "image/png"
    GIF = "image/gif"
    WEBP = "image/webp"


# Image sources
class Base64ImageSource(BaseModel):
    type: Literal["base64"] = "base64"
    media_type: ImageType = Field(..., description="MIME type of the image")
    data: str = Field(..., description="Base64 encoded image data")


class URLImageSource(BaseModel):
    type: Literal["url"] = "url"
    url: str = Field(..., description="URL of the image")


class FileImageSource(BaseModel):
    type: Literal["file"] = "file"
    file_uuid: str = Field(..., description="UUID of the uploaded file")


# Web search result
class WebSearchResult(BaseModel):
    model_config = ConfigDict(extra="allow")
    type: Literal["web_search_result"]
    title: str
    url: str
    encrypted_content: str
    page_age: Optional[str] = None


# Cache control
class CacheControl(BaseModel):
    type: Literal["ephemeral"]


# Content types
class TextContent(BaseModel):
    model_config = ConfigDict(extra="allow")
    type: Literal["text"]
    text: str
    cache_control: Optional[CacheControl] = None


class ImageContent(BaseModel):
    model_config = ConfigDict(extra="allow")
    type: Literal["image"]
    source: Base64ImageSource | URLImageSource | FileImageSource
    cache_control: Optional[CacheControl] = None


class ThinkingContent(BaseModel):
    model_config = ConfigDict(extra="allow")
    type: Literal["thinking"]
    thinking: str


# redacted_thinking API 
class RedactedThinkingContent(BaseModel):
    model_config = ConfigDict(extra="allow")
    type: Literal["redacted_thinking"]
    data: str


class ToolUseContent(BaseModel):
    model_config = ConfigDict(extra="allow")
    type: Literal["tool_use"]
    id: str
    name: str
    input: Dict[str, Any]
    cache_control: Optional[CacheControl] = None


class ToolResultContent(BaseModel):
    model_config = ConfigDict(extra="allow")
    type: Literal["tool_result"]
    tool_use_id: str
    content: str | List[TextContent | ImageContent]
    is_error: Optional[bool] = False
    cache_control: Optional[CacheControl] = None


class ServerToolUseContent(BaseModel):
    model_config = ConfigDict(extra="allow")
    type: Literal["server_tool_use"]
    id: str
    name: str
    input: Dict[str, Any]
    cache_control: Optional[CacheControl] = None


class WebSearchToolResultContent(BaseModel):
    model_config = ConfigDict(extra="allow")
    type: Literal["web_search_tool_result"]
    tool_use_id: str
    content: List[WebSearchResult]
    cache_control: Optional[CacheControl] = None


ContentBlock = Union[
    TextContent,
    ImageContent,
    ThinkingContent,
    RedactedThinkingContent,
    ToolUseContent,
    ToolResultContent,
    ServerToolUseContent,
    WebSearchToolResultContent,
]


class InputMessage(BaseModel):
    model_config = ConfigDict(extra="allow")
    role: Role
    content: Union[str, List[ContentBlock]]


class ThinkingOptions(BaseModel):
    model_config = ConfigDict(extra="allow")
    type: Literal["enabled", "disabled", "adaptive"] = "disabled"
    budget_tokens: Optional[int] = None


class ToolChoice(BaseModel):
    model_config = ConfigDict(extra="allow")
    type: Literal["auto", "any", "tool", "none"] = "auto"
    name: Optional[str] = None
    disable_parallel_tool_use: Optional[bool] = None


class Tool(BaseModel):
    model_config = ConfigDict(extra="allow")
    name: str
    input_schema: Any
    description: Optional[str] = None


class OutputConfig(BaseModel):
    """Output configuration (effort, format, etc). effort and structured outputs are now GA."""

    model_config = ConfigDict(extra="allow")
    effort: Optional[Literal["low", "medium", "high", "max"]] = None


class OutputFormat(BaseModel):
    """Output format for structured outputs (deprecated, use output_config.format instead)."""

    model_config = ConfigDict(extra="allow", populate_by_name=True, serialize_by_alias=True)
    type: Literal["json_schema"]
    schema_: Optional[Dict[str, Any]] = Field(default=None, alias="schema")


class ServerToolUsage(BaseModel):
    model_config = ConfigDict(extra="allow")
    web_search_requests: Optional[int] = None


class Usage(BaseModel):
    model_config = ConfigDict(extra="allow")
    input_tokens: int
    output_tokens: int
    cache_creation_input_tokens: Optional[int] = 0
    cache_read_input_tokens: Optional[int] = 0
    server_tool_use: Optional[ServerToolUsage] = None


class MessagesAPIRequest(BaseModel):
    model_config = ConfigDict(extra="allow")
    model: str = Field(default="claude-opus-4-20250514")
    messages: List[InputMessage]
    max_tokens: int = Field(default=8192, ge=1)
    system: Optional[str | List[TextContent]] = None
    temperature: Optional[float] = Field(default=None, ge=0, le=1)
    top_p: Optional[float] = Field(default=None, ge=0, le=1)
    top_k: Optional[int] = Field(default=None, ge=0)
    stop_sequences: Optional[List[str]] = None
    stream: Optional[bool] = False
    metadata: Optional[Dict[str, Any]] = None
    thinking: Optional[ThinkingOptions] = None
    tool_choice: Optional[ToolChoice] = None
    tools: Optional[List[Tool]] = None
    output_config: Optional[OutputConfig] = None
    output_format: Optional[OutputFormat] = None

    @model_validator(mode="after")
    def validate_thinking_tokens(self) -> "MessagesAPIRequest":
        """Ensure max_tokens > thinking.budget_tokens when thinking is enabled."""
        if (
            self.thinking
            and self.thinking.type == "enabled"
            and self.thinking.budget_tokens is not None
            and self.max_tokens <= self.thinking.budget_tokens
        ):
            self.max_tokens = self.thinking.budget_tokens + 1
        return self


class Message(BaseModel):
    model_config = ConfigDict(extra="allow")
    id: str
    type: Literal["message"]
    role: Literal["assistant"]
    content: List[ContentBlock]
    model: str
    stop_reason: Optional[
        Literal[
            "end_turn",
            "max_tokens",
            "stop_sequence",
            "tool_use",
            "pause_turn",
            "refusal",
        ]
    ] = None
    stop_sequence: Optional[str] = None
    usage: Optional[Usage] = None
</file>

<file path="README_en.md">
# Clove 

<div align="center">

[![License](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)
[![Python](https://img.shields.io/badge/python-3.13+-blue.svg)](https://www.python.org/downloads/)
[![FastAPI](https://img.shields.io/badge/FastAPI-0.115+-green.svg)](https://fastapi.tiangolo.com)

**The all-in-one Claude reverse proxy **

[English](#) | [](./README.md)

</div>

##  What is this?

Clove is a reverse proxy tool that lets you access Claude.ai through a standard API. In simple terms, it allows various AI applications to connect to Claude!

**The biggest highlight**: Clove is the first reverse proxy to support accessing Claude's official API through OAuth authentication (the same one Claude Code uses)! This means you get the full Claude API experience, including advanced features like native system messages and prefilling.

##  Quick Start

Just three steps to get started:

### 1. Install Python

Make sure you have Python 3.13 or higher on your computer

### 2. Install Clove

```bash
pip install "clove-proxy[rnet]"
```

### 3. Launch!

```bash
clove
```

After starting, you'll see a randomly generated temporary admin key in the console. Don't forget to add your own key after logging into the admin panel!

### 4. Configure Your Account

Open your browser and go to: http://localhost:5201

Log in with the admin key from earlier, then you can add your Claude account~

##  Core Features

###  Dual Mode Operation

- **OAuth Mode**: Preferred method, gives you access to all Claude API features
- **Web Proxy Mode**: Automatically switches when OAuth is unavailable, works by emulating the Claude.ai web interface

###  Outstanding Compatibility

Compared to other proxy tools (like Clewd), Clove offers exceptional compatibility:

-  Full support for SillyTavern
-  Works with most applications that use the Claude API
-  Even supports Claude Code itself!

###  Enhanced Features

#### For OAuth Mode

- Complete access to all Claude API features
- Native system message support
- Prefilling support
- Better performance and stability

#### For Claude.ai Web Proxy Mode

Clove handles all the differences between Claude.ai web version and the API:

- Image upload support
- Extended thinking (chain of thought) support

Even through web proxy, Clove enables features that weren't originally supported:

- Function Calling
- Stop Sequences
- Token counting (estimated)
- Non-streaming responses

Clove strives to make the Claude.ai web proxy as API-like as possible for a seamless experience across all applications.

###  Friendly Admin Interface

- Modern web management interface
- No need to edit config files
- All settings can be configured in the admin panel
- Automatic user quota and status management

###  Smart Features

- **Automatic OAuth Authentication**: Completed automatically through cookies, no manual Claude Code login needed
- **Intelligent Switching**: Automatically switches between OAuth and Claude.ai web proxy
- **Quota Management**: Automatically flags when quota is exceeded and restores when reset

##  Limitations

### 1. Android Termux Users Note

Clove depends on `curl_cffi` to request claude.ai, but this dependency doesn't work on Termux.

**Solutions**:

- Use the version without curl_cffi: `pip install clove-proxy`
  -  Access Claude API through OAuth (requires manual authentication in admin panel)
  -  Cannot use web proxy features
  -  Cannot auto-complete OAuth authentication
- Use a reverse proxy/mirror (like fuclaude)
  -  Can use all features
  -  Requires an additional server (but if you have a server for mirroring, why deploy on Termux? lol)

### 2. Tool Calling Limitations

If you're using web proxy mode, avoid connecting applications that perform **many parallel tool calls**.

- Clove needs to maintain connections with Claude.ai while waiting for tool call results
- Too many parallel calls will exhaust connections and cause failures
- OAuth mode is not affected by this limitation

### 3. Prompt Structure Limitations

When Clove uses web proxy, Claude.ai adds extra system prompts and file upload structures to your prompts. When using prompts with strict structural requirements (like RP presets):

- You can predict which method your request will use. With default settings:
  - Free accounts: All requests go through Claude.ai web proxy
  - Pro accounts: Sonnet models use Claude API, Opus models use Claude.ai web proxy
  - Max accounts: All requests use Claude API
  - With multiple accounts, Clove always prioritizes accounts with API access for the requested model
- Choose prompts compatible with your request method

##  Advanced Configuration

### Environment Variables

While most settings can be configured in the admin interface, you can also use environment variables:

```bash
# Port configuration
PORT=5201

# Admin key (auto-generated if not set)
ADMIN_API_KEYS=your-secret-key

# Claude.ai Cookie
COOKIES=sessionKey=your-session-key
```

See `.env.example` for more configuration options.

### API Usage

Once configured, you can use Clove just like the standard Claude API:

```python
import anthropic

client = anthropic.Anthropic(
    base_url="http://localhost:5201",
    api_key="your-api-key"  # Create this in the admin panel
)

response = client.messages.create(
    model="claude-opus-4-20250514",
    messages=[{"role": "user", "content": "Hello, Claude!"}],
    max_tokens=1024,
)
```

##  Contributing

Contributions are welcome! If you have great ideas or found issues:

1. Fork this project
2. Create your feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

##  License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

##  Acknowledgments

- [Anthropic Claude](https://www.anthropic.com/claude) - ~~Adorable little Claude~~ Powerful AI assistant
- [Clewd](https://github.com/teralomaniac/clewd/) - The original Claude.ai reverse proxy
- [ClewdR](https://github.com/Xerxes-2/clewdr) - High-performance Claude.ai reverse proxy
- [FastAPI](https://fastapi.tiangolo.com/) - Modern, fast web framework
- [Tailwind CSS](https://tailwindcss.com/) - CSS framework
- [Shadcn UI](https://ui.shadcn.com/) - Modern UI component library
- [Vite](https://vitejs.dev/) - Modern frontend build tool
- [React](https://reactjs.org/) - JavaScript library

##  Disclaimer

This project is for learning and research purposes only. When using this project, please comply with the terms of service of the relevant services. The author is not responsible for any misuse or violations of service terms.

##  Contact

If you have questions or suggestions, feel free to reach out:

- Submit an [Issue](https://github.com/mirrorange/clove/issues)
- Send a Pull Request
- Email: orange@freesia.ink

##  About Clove

Clove is a plant from the Myrtaceae family's Syzygium genus, commonly used as a spice and in traditional medicine. Clove (, the spice) and lilac flowers (, Syringa) are two different plants! In this project, the name Clove is actually a blend of "Claude" and "love"!

---

<div align="center">
Made with  by 
</div>
</file>

<file path="app/api/routes/accounts.py">
from typing import List, Optional
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel, Field
from uuid import UUID
import time

from app.core.exceptions import OAuthExchangeError
from app.dependencies.auth import AdminAuthDep
from app.services.account import account_manager
from app.core.account import AuthType, AccountStatus, OAuthToken, PreferredAuthMethod
from app.services.oauth import oauth_authenticator


class OAuthTokenCreate(BaseModel):
    access_token: str
    refresh_token: str
    expires_at: float


class AccountCreate(BaseModel):
    cookie_value: Optional[str] = None
    oauth_token: Optional[OAuthTokenCreate] = None
    organization_uuid: Optional[UUID] = None
    capabilities: Optional[List[str]] = None


class AccountUpdate(BaseModel):
    cookie_value: Optional[str] = None
    oauth_token: Optional[OAuthTokenCreate] = None
    capabilities: Optional[List[str]] = None
    status: Optional[AccountStatus] = None
    preferred_auth: Optional[PreferredAuthMethod] = None


class OAuthCodeExchange(BaseModel):
    organization_uuid: UUID
    code: str
    pkce_verifier: str
    capabilities: Optional[List[str]] = None


class AccountResponse(BaseModel):
    organization_uuid: str
    capabilities: Optional[List[str]]
    cookie_value: Optional[str] = Field(None, description="Masked cookie value")
    status: AccountStatus
    auth_type: AuthType
    preferred_auth: PreferredAuthMethod
    is_pro: bool
    is_max: bool
    has_oauth: bool
    last_used: str
    resets_at: Optional[str] = None


router = APIRouter()


@router.get("", response_model=List[AccountResponse])
async def list_accounts(_: AdminAuthDep):
    """List all accounts."""
    accounts = []

    for org_uuid, account in account_manager._accounts.items():
        accounts.append(
            AccountResponse(
                organization_uuid=org_uuid,
                capabilities=account.capabilities,
                cookie_value=account.cookie_value[:20] + "..."
                if account.cookie_value
                else None,
                status=account.status,
                auth_type=account.auth_type,
                preferred_auth=account.preferred_auth,
                is_pro=account.is_pro,
                is_max=account.is_max,
                has_oauth=account.oauth_token is not None,
                last_used=account.last_used.isoformat(),
                resets_at=account.resets_at.isoformat() if account.resets_at else None,
            )
        )

    return accounts


@router.get("/{organization_uuid}", response_model=AccountResponse)
async def get_account(organization_uuid: str, _: AdminAuthDep):
    """Get a specific account by organization UUID."""
    if organization_uuid not in account_manager._accounts:
        raise HTTPException(status_code=404, detail="Account not found")

    account = account_manager._accounts[organization_uuid]

    return AccountResponse(
        organization_uuid=organization_uuid,
        capabilities=account.capabilities,
        cookie_value=account.cookie_value[:20] + "..."
        if account.cookie_value
        else None,
        status=account.status,
        auth_type=account.auth_type,
        preferred_auth=account.preferred_auth,
        is_pro=account.is_pro,
        is_max=account.is_max,
        has_oauth=account.oauth_token is not None,
        last_used=account.last_used.isoformat(),
        resets_at=account.resets_at.isoformat() if account.resets_at else None,
    )


@router.post("", response_model=AccountResponse)
async def create_account(account_data: AccountCreate, _: AdminAuthDep):
    """Create a new account."""
    oauth_token = None
    if account_data.oauth_token:
        oauth_token = OAuthToken(
            access_token=account_data.oauth_token.access_token,
            refresh_token=account_data.oauth_token.refresh_token,
            expires_at=account_data.oauth_token.expires_at,
        )

    account = await account_manager.add_account(
        cookie_value=account_data.cookie_value,
        oauth_token=oauth_token,
        organization_uuid=str(account_data.organization_uuid),
        capabilities=account_data.capabilities,
    )

    return AccountResponse(
        organization_uuid=account.organization_uuid,
        capabilities=account.capabilities,
        cookie_value=account.cookie_value[:20] + "..."
        if account.cookie_value
        else None,
        status=account.status,
        auth_type=account.auth_type,
        preferred_auth=account.preferred_auth,
        is_pro=account.is_pro,
        is_max=account.is_max,
        has_oauth=account.oauth_token is not None,
        last_used=account.last_used.isoformat(),
        resets_at=account.resets_at.isoformat() if account.resets_at else None,
    )


@router.put("/{organization_uuid}", response_model=AccountResponse)
async def update_account(
    organization_uuid: str, account_data: AccountUpdate, _: AdminAuthDep
):
    """Update an existing account."""
    if organization_uuid not in account_manager._accounts:
        raise HTTPException(status_code=404, detail="Account not found")

    account = account_manager._accounts[organization_uuid]

    # Update fields if provided
    if account_data.cookie_value is not None:
        # Remove old cookie mapping if exists
        if (
            account.cookie_value
            and account.cookie_value in account_manager._cookie_to_uuid
        ):
            del account_manager._cookie_to_uuid[account.cookie_value]

        account.cookie_value = account_data.cookie_value
        account_manager._cookie_to_uuid[account_data.cookie_value] = organization_uuid

    if account_data.oauth_token is not None:
        account.oauth_token = OAuthToken(
            access_token=account_data.oauth_token.access_token,
            refresh_token=account_data.oauth_token.refresh_token,
            expires_at=account_data.oauth_token.expires_at,
        )
        # Update auth type based on what's available
        if account.cookie_value and account.oauth_token:
            account.auth_type = AuthType.BOTH
        elif account.oauth_token:
            account.auth_type = AuthType.OAUTH_ONLY
        else:
            account.auth_type = AuthType.COOKIE_ONLY

    if account_data.capabilities is not None:
        account.capabilities = account_data.capabilities

    if account_data.status is not None:
        account.status = account_data.status
        if account.status == AccountStatus.VALID:
            account.resets_at = None

    if account_data.preferred_auth is not None:
        account.preferred_auth = account_data.preferred_auth

    # Save changes
    account_manager.save_accounts()

    return AccountResponse(
        organization_uuid=organization_uuid,
        capabilities=account.capabilities,
        cookie_value=account.cookie_value[:20] + "..."
        if account.cookie_value
        else None,
        status=account.status,
        auth_type=account.auth_type,
        preferred_auth=account.preferred_auth,
        is_pro=account.is_pro,
        is_max=account.is_max,
        has_oauth=account.oauth_token is not None,
        last_used=account.last_used.isoformat(),
        resets_at=account.resets_at.isoformat() if account.resets_at else None,
    )


@router.delete("/{organization_uuid}")
async def delete_account(organization_uuid: str, _: AdminAuthDep):
    """Delete an account."""
    if organization_uuid not in account_manager._accounts:
        raise HTTPException(status_code=404, detail="Account not found")

    await account_manager.remove_account(organization_uuid)

    return {"message": "Account deleted successfully"}


@router.post("/oauth/exchange", response_model=AccountResponse)
async def exchange_oauth_code(exchange_data: OAuthCodeExchange, _: AdminAuthDep):
    """Exchange OAuth authorization code for tokens and create account."""
    # Exchange code for tokens
    token_data = await oauth_authenticator.exchange_token(
        exchange_data.code, exchange_data.pkce_verifier
    )

    if not token_data:
        raise OAuthExchangeError()

    # Create OAuth token object
    oauth_token = OAuthToken(
        access_token=token_data["access_token"],
        refresh_token=token_data["refresh_token"],
        expires_at=time.time() + token_data["expires_in"],
    )

    # Create account with OAuth token
    account = await account_manager.add_account(
        oauth_token=oauth_token,
        organization_uuid=str(exchange_data.organization_uuid),
        capabilities=exchange_data.capabilities,
    )

    return AccountResponse(
        organization_uuid=account.organization_uuid,
        capabilities=account.capabilities,
        cookie_value=None,
        status=account.status,
        auth_type=account.auth_type,
        preferred_auth=account.preferred_auth,
        is_pro=account.is_pro,
        is_max=account.is_max,
        has_oauth=True,
        last_used=account.last_used.isoformat(),
        resets_at=account.resets_at.isoformat() if account.resets_at else None,
    )
</file>

<file path="app/core/account.py">
from typing import List, Optional
from enum import Enum
from datetime import datetime
from dataclasses import dataclass

from app.core.exceptions import (
    ClaudeAuthenticationError,
    ClaudeHttpError,
    ClaudeRateLimitedError,
    OAuthAuthenticationNotAllowedError,
    OrganizationDisabledError,
)


class AccountStatus(str, Enum):
    VALID = "valid"
    INVALID = "invalid"
    RATE_LIMITED = "rate_limited"


class AuthType(str, Enum):
    COOKIE_ONLY = "cookie_only"
    OAUTH_ONLY = "oauth_only"
    BOTH = "both"


class PreferredAuthMethod(str, Enum):
    """User preference for authentication method when account has both Cookie and OAuth."""
    AUTO = "auto"  # Default: prioritize OAuth if available
    OAUTH = "oauth"  # Force OAuth only
    WEB = "web"  # Force Web (Cookie) only


@dataclass
class OAuthToken:
    """Encapsulates OAuth credentials for an account."""

    access_token: str
    refresh_token: str
    expires_at: float  # Unix timestamp

    def to_dict(self) -> dict:
        """Convert to dictionary for JSON serialization."""
        return {
            "access_token": self.access_token,
            "refresh_token": self.refresh_token,
            "expires_at": self.expires_at,
        }

    @classmethod
    def from_dict(cls, data: dict) -> "OAuthToken":
        """Create from dictionary."""
        return cls(
            access_token=data["access_token"],
            refresh_token=data["refresh_token"],
            expires_at=data["expires_at"],
        )


class Account:
    """Represents a Claude.ai account with cookie and/or OAuth authentication."""

    def __init__(
        self,
        organization_uuid: str,
        capabilities: Optional[List[str]] = None,
        cookie_value: Optional[str] = None,
        oauth_token: Optional[OAuthToken] = None,
        auth_type: AuthType = AuthType.COOKIE_ONLY,
        preferred_auth: PreferredAuthMethod = PreferredAuthMethod.AUTO,
    ):
        self.organization_uuid = organization_uuid
        self.capabilities = capabilities
        self.cookie_value = cookie_value
        self.status = AccountStatus.VALID
        self.auth_type = auth_type
        self.preferred_auth = preferred_auth
        self.last_used = datetime.now()
        self.resets_at: Optional[datetime] = None
        self.oauth_token: Optional[OAuthToken] = oauth_token

    def __enter__(self) -> "Account":
        """Enter the context manager."""
        self.last_used = datetime.now()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Exit the context manager and handle CookieRateLimitedError."""
        if exc_type is ClaudeRateLimitedError and isinstance(
            exc_val, ClaudeRateLimitedError
        ):
            self.status = AccountStatus.RATE_LIMITED
            self.resets_at = exc_val.resets_at
            self.save()

        if exc_type is ClaudeAuthenticationError and isinstance(
            exc_val, ClaudeAuthenticationError
        ):
            self.status = AccountStatus.INVALID
            self.save()

        if exc_type is OrganizationDisabledError and isinstance(
            exc_val, OrganizationDisabledError
        ):
            self.status = AccountStatus.INVALID
            self.save()

        if exc_type is OAuthAuthenticationNotAllowedError and isinstance(
            exc_val, OAuthAuthenticationNotAllowedError
        ):
            if self.auth_type == AuthType.BOTH:
                self.auth_type = AuthType.COOKIE_ONLY
            else:
                self.status = AccountStatus.INVALID
            self.save()

        # Handle ClaudeHttpError for auth-related failures (401/403)
        # After re-auth retry fails, degrade or invalidate account
        if exc_type is ClaudeHttpError and isinstance(exc_val, ClaudeHttpError):
            status_code = exc_val.context.get("status_code")
            if status_code in (401, 403):
                if self.auth_type == AuthType.BOTH:
                    self.auth_type = AuthType.COOKIE_ONLY
                    self.oauth_token = None
                else:
                    self.status = AccountStatus.INVALID
                self.save()

        return False

    def save(self) -> None:
        from app.services.account import account_manager

        account_manager.save_accounts()

    def to_dict(self) -> dict:
        """Convert Account to dictionary for JSON serialization."""
        return {
            "organization_uuid": self.organization_uuid,
            "capabilities": self.capabilities,
            "cookie_value": self.cookie_value,
            "status": self.status.value,
            "auth_type": self.auth_type.value,
            "preferred_auth": self.preferred_auth.value,
            "last_used": self.last_used.isoformat(),
            "resets_at": self.resets_at.isoformat() if self.resets_at else None,
            "oauth_token": self.oauth_token.to_dict() if self.oauth_token else None,
        }

    @classmethod
    def from_dict(cls, data: dict) -> "Account":
        """Create Account from dictionary."""
        account = cls(
            organization_uuid=data["organization_uuid"],
            capabilities=data.get("capabilities"),
            cookie_value=data.get("cookie_value"),
            auth_type=AuthType(data["auth_type"]),
            preferred_auth=PreferredAuthMethod(data.get("preferred_auth", "auto")),
        )
        account.status = AccountStatus(data["status"])
        account.last_used = datetime.fromisoformat(data["last_used"])
        account.resets_at = (
            datetime.fromisoformat(data["resets_at"]) if data["resets_at"] else None
        )

        if "oauth_token" in data and data["oauth_token"]:
            account.oauth_token = OAuthToken.from_dict(data["oauth_token"])

        return account

    @property
    def is_pro(self) -> bool:
        """Check if account has pro capabilities."""
        if not self.capabilities:
            return False

        pro_keywords = ["pro", "enterprise", "raven", "max"]
        return any(
            keyword in cap.lower()
            for cap in self.capabilities
            for keyword in pro_keywords
        )

    @property
    def is_max(self) -> bool:
        """Check if account has max capabilities."""
        if not self.capabilities:
            return False

        return any("max" in cap.lower() for cap in self.capabilities)

    def __repr__(self) -> str:
        """String representation of the Account."""
        return f"<Account organization_uuid={self.organization_uuid[:8]}... status={self.status.value} auth_type={self.auth_type.value}>"
</file>

<file path="app/core/exceptions.py">
from datetime import datetime
from typing import Optional, Any, Dict


class AppError(Exception):
    """
    Base class for application-specific exceptions.
    """

    def __init__(
        self,
        error_code: int,
        message_key: str,
        status_code: int,
        context: Optional[Dict[str, Any]] = None,
        retryable: bool = False,
    ):
        self.error_code = error_code
        self.message_key = message_key
        self.status_code = status_code
        self.context = context if context is not None else {}
        self.retryable = retryable
        super().__init__(
            f"Error Code: {error_code}, Message Key: {message_key}, Context: {self.context}"
        )

    def __str__(self):
        return f"{self.__class__.__name__}(error_code={self.error_code}, message_key='{self.message_key}', status_code={self.status_code}, context={self.context})"


class InternalServerError(AppError):
    def __init__(self, context: Optional[Dict[str, Any]] = None):
        super().__init__(
            error_code=500000,
            message_key="global.internalServerError",
            status_code=500,
            context=context,
        )


class NoAPIKeyProvidedError(AppError):
    def __init__(self, context: Optional[Dict[str, Any]] = None):
        super().__init__(
            error_code=401010,
            message_key="global.noAPIKeyProvided",
            status_code=401,
            context=context,
        )


class InvalidAPIKeyError(AppError):
    def __init__(self, context: Optional[Dict[str, Any]] = None):
        super().__init__(
            error_code=401011,
            message_key="global.invalidAPIKey",
            status_code=401,
            context=context,
        )


class NoAccountsAvailableError(AppError):
    def __init__(self, context: Optional[Dict[str, Any]] = None):
        super().__init__(
            error_code=503100,
            message_key="accountManager.noAccountsAvailable",
            status_code=503,
            context=context,
            retryable=True,
        )


class ClaudeRateLimitedError(AppError):
    resets_at: datetime

    def __init__(self, resets_at: datetime, context: Optional[Dict[str, Any]] = None):
        self.resets_at = resets_at
        _context = context.copy() if context else {}
        _context["resets_at"] = resets_at.strftime("%Y-%m-%dT%H:%M:%SZ")
        super().__init__(
            error_code=429120,
            message_key="claudeClient.claudeRateLimited",
            status_code=429,
            context=_context,
            retryable=True,
        )


class CloudflareBlockedError(AppError):
    def __init__(self, context: Optional[Dict[str, Any]] = None):
        super().__init__(
            error_code=503121,
            message_key="claudeClient.cloudflareBlocked",
            status_code=503,
            context=context,
        )


class OrganizationDisabledError(AppError):
    def __init__(self, context: Optional[Dict[str, Any]] = None):
        super().__init__(
            error_code=400122,
            message_key="claudeClient.organizationDisabled",
            status_code=400,
            context=context,
            retryable=True,
        )


class InvalidModelNameError(AppError):
    def __init__(self, model_name: str, context: Optional[Dict[str, Any]] = None):
        _context = context.copy() if context else {}
        _context["model_name"] = model_name
        super().__init__(
            error_code=400123,
            message_key="claudeClient.invalidModelName",
            status_code=400,
            context=_context,
        )


class ClaudeAuthenticationError(AppError):
    def __init__(self, context: Optional[Dict[str, Any]] = None):
        super().__init__(
            error_code=400124,
            message_key="claudeClient.authenticationError",
            status_code=400,
            context=context,
        )


class ClaudeHttpError(AppError):
    def __init__(
        self,
        url,
        status_code: int,
        error_type: str,
        error_message: Any,
        context: Optional[Dict[str, Any]] = None,
    ):
        _context = context.copy() if context else {}
        _context.update({
            "url": url,
            "status_code": status_code,
            "error_type": error_type,
            "error_message": error_message,
        })
        super().__init__(
            error_code=503130,
            message_key="claudeClient.httpError",
            status_code=status_code,
            context=_context,
            retryable=True,
        )


class NoValidMessagesError(AppError):
    def __init__(self, context: Optional[Dict[str, Any]] = None):
        super().__init__(
            error_code=400140,
            message_key="messageProcessor.noValidMessages",
            status_code=400,
            context=context,
        )


class ExternalImageDownloadError(AppError):
    def __init__(self, url: str, context: Optional[Dict[str, Any]] = None):
        _context = context.copy() if context else {}
        _context.update({"url": url})
        super().__init__(
            error_code=503141,
            message_key="messageProcessor.externalImageDownloadError",
            status_code=503,
            context=_context,
        )


class ExternalImageNotAllowedError(AppError):
    def __init__(self, url: str, context: Optional[Dict[str, Any]] = None):
        _context = context.copy() if context else {}
        _context.update({"url": url})
        super().__init__(
            error_code=400142,
            message_key="messageProcessor.externalImageNotAllowed",
            status_code=400,
            context=_context,
        )


class NoResponseError(AppError):
    def __init__(self, context: Optional[Dict[str, Any]] = None):
        super().__init__(
            error_code=503160,
            message_key="pipeline.noResponse",
            status_code=503,
            context=context,
        )


class OAuthExchangeError(AppError):
    def __init__(self, reason: str, context: Optional[Dict[str, Any]] = None):
        _context = context.copy() if context else {}
        _context["reason"] = reason or "Unknown"
        super().__init__(
            error_code=400180,
            message_key="oauthService.oauthExchangeError",
            status_code=400,
            context=_context,
        )


class OrganizationInfoError(AppError):
    def __init__(self, reason: str, context: Optional[Dict[str, Any]] = None):
        _context = context.copy() if context else {}
        _context["reason"] = reason or "Unknown"
        super().__init__(
            error_code=503181,
            message_key="oauthService.organizationInfoError",
            status_code=503,
            context=_context,
        )


class CookieAuthorizationError(AppError):
    def __init__(self, reason: str, context: Optional[Dict[str, Any]] = None):
        _context = context.copy() if context else {}
        _context["reason"] = reason or "Unknown"
        super().__init__(
            error_code=400182,
            message_key="oauthService.cookieAuthorizationError",
            status_code=400,
            context=_context,
        )


class OAuthAuthenticationNotAllowedError(AppError):
    def __init__(self, context: Optional[Dict[str, Any]] = None):
        super().__init__(
            error_code=400183,
            message_key="oauthService.oauthAuthenticationNotAllowed",
            status_code=400,
            context=context,
        )


class ClaudeStreamingError(AppError):
    def __init__(
        self,
        error_type: str,
        error_message: str,
        context: Optional[Dict[str, Any]] = None,
    ):
        _context = context.copy() if context else {}
        _context.update({
            "error_type": error_type,
            "error_message": error_message,
        })
        super().__init__(
            error_code=503500,
            message_key="processors.nonStreamingResponseProcessor.streamingError",
            status_code=503,
            context=_context,
            retryable=True,
        )


class NoMessageError(AppError):
    def __init__(self, context: Optional[Dict[str, Any]] = None):
        super().__init__(
            error_code=503501,
            message_key="processors.nonStreamingResponseProcessor.noMessage",
            status_code=503,
            context=context,
            retryable=True,
        )
</file>

<file path="app/locales/en.json">
{
  "global": {
    "internalServerError": "An internal server error occurred. Please try again later.",
    "noAPIKeyProvided": "No API key provided. Please include an API key in the request.",
    "invalidAPIKey": "Invalid API key. Please check your API key and try again."
  },
  "accountManager": {
    "noAccountsAvailable": "No accounts are currently available. Please try again later."
  },
  "oauthService": {
    "oauthExchangeError": "Failed to exchange authorization code for tokens.",
    "organizationInfoError": "Failed to get organization Info: {reason}",
    "cookieAuthorizationError": "Failed to authorize with cookie: {reason}",
    "oauthAuthenticationNotAllowed": "OAuth authentication is not allowed for this organization. Only Pro and Max accounts support OAuth authentication."
  },
  "claudeClient": {
    "claudeRateLimited": "Claude AI rate limit exceeded. Please try again after {resets_at}.",
    "cloudflareBlocked": "Request blocked by Cloudflare. Please check your IP address.",
    "organizationDisabled": "Your Claude AI account has been disabled.",
    "httpError": "HTTP error occurred when calling Claude AI: {error_type} - {error_message} (Status: {status_code})",
    "invalidModelName": "Invalid model name provided. Please ensure you have access to model {model_name}.",
    "authenticationError": "Authentication error. Please check your Claude Cookie or OAuth credentials, and ensure you have installed the curl dependency and are not in a Termux environment."
  },
  "messageProcessor": {
    "noValidMessages": "No valid messages found in the request.",
    "externalImageDownloadError": "Failed to download external image from: {url}",
    "externalImageNotAllowed": "External images are not allowed: {url}"
  },
  "pipeline": {
    "noResponse": "No response received from the service. Please try again."
  },
  "processors": {
    "nonStreamingResponseProcessor": {
      "streamingError": "Streaming error occurred: {error_type} - {error_message}",
      "noMessage": "No message received in the response."
    }
  }
}
</file>

<file path="app/locales/zh.json">
{
  "global": {
    "internalServerError": "",
    "noAPIKeyProvided": " API  API ",
    "invalidAPIKey": " API  API "
  },
  "accountManager": {
    "noAccountsAvailable": ""
  },
  "oauthService": {
    "oauthExchangeError": "{reason}",
    "organizationInfoError": "{reason}",
    "cookieAuthorizationError": " Cookie {reason}",
    "oauthAuthenticationNotAllowed": " OAuth  Pro  Max  OAuth "
  },
  "claudeClient": {
    "claudeRateLimited": "Claude API  {resets_at} ",
    "cloudflareBlocked": " Cloudflare ",
    "organizationDisabled": " Claude AI ",
    "httpError": " Claude AI  HTTP {error_type} - {error_message}{status_code}",
    "invalidModelName": " {model_name} ",
    "authenticationError": " Claude Cookie  OAuth  curl  Termux "
  },
  "messageProcessor": {
    "noValidMessages": "",
    "externalImageDownloadError": "{url}",
    "externalImageNotAllowed": "{url}"
  },
  "pipeline": {
    "noResponse": ""
  },
  "processors": {
    "nonStreamingResponseProcessor": {
      "streamingError": "{error_type} - {error_message}",
      "noMessage": ""
    }
  }
}
</file>

<file path="Dockerfile.pypi">
# Simplified Dockerfile for Clove - Install from PyPI
FROM python:3.11-slim

WORKDIR /app

# Install clove-proxy from PyPI
RUN pip install --no-cache-dir "clove-proxy[rnet]"

# Create data directory
RUN mkdir -p /data

# Environment variables
ENV DATA_FOLDER=/data
ENV HOST=0.0.0.0
ENV PORT=${PORT:-5201}

# Expose port
EXPOSE ${PORT:-5201}

# Run the application using the installed script
CMD ["clove"]
</file>

<file path="README.md">
# Clove 

<div align="center">

[![License](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)
[![Python](https://img.shields.io/badge/python-3.13+-blue.svg)](https://www.python.org/downloads/)
[![FastAPI](https://img.shields.io/badge/FastAPI-0.115+-green.svg)](https://fastapi.tiangolo.com)

** Claude  **

[English](./README_en.md) | [](#)

</div>

##  

Clove  Claude API  Claude.ai  AI  Claude

****Clove  OAuth  Claude  API  Claude Code  Claude API 

##  



### 1.  Python

 Python 3.13 

### 2.  Clove

```bash
pip install "clove-proxy[rnet]"
```

### 3. 

```bash
clove
```



### 4. 

http://localhost:5201

 Claude 

##  

###  

- **OAuth ** Claude API 
- **** OAuth  Claude.ai 

###  

 ClewdClove 

-   SillyTavern
-   Claude API 
-   Claude Code 

###  

####  OAuth 

-  Claude API 
- 
- 
- 

####  Claude.ai 

Clove  Claude.ai  API 

- 
- 

Clove 

- Function Calling
- Stop Sequences
- Token 
- 

Clove  Claude.ai  API

###  

-  Web 
- 
- 
- 

###  

- ** OAuth ** Cookie  Claude Code
- **** OAuth  Claude.ai 
- ****

##  

### 1. Android Termux 

Clove  `curl_cffi`  claude.ai Termux 

****

-  curl_cffi `pip install clove-proxy`
  -   OAuth  Claude API
  -  
  -   OAuth 
- / fuclaude
  -  
  -   Termux  www

### 2. 

****

- Clove  Claude.ai 
- 
- OAuth 

### 3. 

 Clove Claude.ai  RP 

- 
  -  Free  Claude.ai 
  -  Pro Sonnet  Claude APIOpus  Claude.ai 
  -  Max  Claude API 
  - Clove  API 
- 

##  

### 



```bash
# 
PORT=5201

# 
ADMIN_API_KEYS==your-secret-key

# Claude.ai Cookie
COOKIES=sessionKey=your-session-key
```

 `.env.example` 

### API 

 Claude API  Clove

```python
import anthropic

client = anthropic.Anthropic(
    base_url="http://localhost:5201",
    api_key="your-api-key"  # 
)

response = client.messages.create(
    model="claude-opus-4-20250514",
    messages=[{"role": "user", "content": "Hello, Claude!"}],
    max_tokens=1024,
)
```

##  



1. Fork 
2.  (`git checkout -b feature/AmazingFeature`)
3.  (`git commit -m 'Add some AmazingFeature'`)
4.  (`git push origin feature/AmazingFeature`)
5.  Pull Request

##  

 MIT  -  [LICENSE](LICENSE) 

##  

- [Anthropic Claude](https://www.anthropic.com/claude) - ~~~~  AI 
- [Clewd](https://github.com/teralomaniac/clewd/) -  Claude.ai 
- [ClewdR](https://github.com/Xerxes-2/clewdr) -  Claude.ai 
- [FastAPI](https://fastapi.tiangolo.com/) -  Web 
- [Tailwind CSS](https://tailwindcss.com/) - CSS 
- [Shadcn UI](https://ui.shadcn.com/) -  UI 
- [Vite](https://vitejs.dev/) - 
- [React](https://reactjs.org/) - JavaScript 

##  



##  



-  [Issue](https://github.com/mirrorange/clove/issues)
-  Pull Request
- orange@freesia.ink

##   Clove

CloveSyringa~Clove  Claude  love 

---

<div align="center">
Made with  by 
</div>
</file>

<file path="app/processors/claude_ai/pipeline.py">
from typing import List, Optional
from loguru import logger

from app.services.session import session_manager
from app.processors.pipeline import ProcessingPipeline
from app.processors.base import BaseProcessor
from app.processors.claude_ai import ClaudeAIContext
from app.processors.claude_ai.tavern_test_message_processor import TestMessageProcessor
from app.processors.claude_ai.claude_web_processor import ClaudeWebProcessor
from app.processors.claude_ai.claude_api_processor import ClaudeAPIProcessor
from app.processors.claude_ai.event_parser_processor import EventParsingProcessor
from app.processors.claude_ai.streaming_response_processor import (
    StreamingResponseProcessor,
)
from app.processors.claude_ai.message_collector_processor import (
    MessageCollectorProcessor,
)
from app.processors.claude_ai.non_streaming_response_processor import (
    NonStreamingResponseProcessor,
)
from app.processors.claude_ai.token_counter_processor import TokenCounterProcessor
from app.processors.claude_ai.tool_result_processor import ToolResultProcessor
from app.processors.claude_ai.tool_call_event_processor import ToolCallEventProcessor
from app.processors.claude_ai.stop_sequences_processor import StopSequencesProcessor
from app.processors.claude_ai.model_injector_processor import ModelInjectorProcessor


class ClaudeAIPipeline(ProcessingPipeline):
    def __init__(self, processors: Optional[List[BaseProcessor]] = None):
        """
        Initialize the pipeline with processors.

        Args:
            processors: List of processors to use. If None, default processors are used.
        """
        processors = (
            [
                TestMessageProcessor(),
                ToolResultProcessor(),
                ClaudeAPIProcessor(),
                ClaudeWebProcessor(),
                EventParsingProcessor(),
                ModelInjectorProcessor(),
                StopSequencesProcessor(),
                ToolCallEventProcessor(),
                MessageCollectorProcessor(),
                TokenCounterProcessor(),
                StreamingResponseProcessor(),
                NonStreamingResponseProcessor(),
            ]
            if processors is None
            else processors
        )

        super().__init__(processors)

    async def process(
        self,
        context: ClaudeAIContext,
    ) -> ClaudeAIContext:
        """
        Process a Claude API request through the pipeline.

        Args:
            context: The processing context

        Returns:
            Updated context.

        Raises:
            Exception: If any processor fails or no response is generated
        """
        try:
            return await super().process(context)
        except Exception as e:
            if context.claude_session:
                await session_manager.remove_session(context.claude_session.session_id)
            logger.error(f"Pipeline processing failed: {e}")
            raise e
</file>

<file path="Dockerfile">
# Multi-stage Dockerfile for Clove (uv version)

# =============================================================================
# Stage 1: Build frontend
# =============================================================================
FROM node:20-alpine AS frontend-builder

# Install pnpm
RUN corepack enable && corepack prepare pnpm@latest --activate

WORKDIR /app/front

# Copy frontend package files
COPY front/package.json front/pnpm-lock.yaml ./

# Install dependencies
RUN pnpm install --frozen-lockfile

# Copy frontend source
COPY front/ ./

# Build frontend
RUN pnpm run build

# =============================================================================
# Stage 2: Build Python application with uv
# =============================================================================
FROM ghcr.io/astral-sh/uv:python3.11-bookworm-slim AS app

# uv optimization environment variables
ENV UV_COMPILE_BYTECODE=1 \
    UV_LINK_MODE=copy \
    UV_PYTHON_DOWNLOADS=0

WORKDIR /app

# Step 1: Copy dependency files only (leverage Docker layer caching)
COPY pyproject.toml uv.lock ./

# Install dependencies (without installing the project itself)
# --locked: Use lockfile for consistency
# --no-install-project: Only install dependencies, not the project
# --no-dev: Skip dev dependencies
# --extra rnet --extra curl: Install optional dependency groups
RUN --mount=type=cache,target=/root/.cache/uv \
    uv sync --locked --no-install-project --no-dev --extra rnet --extra curl

# Step 2: Copy application code and README.md (required by pyproject.toml)
COPY app/ ./app/
COPY README.md ./

# Step 3: Copy frontend build artifacts (required by pyproject.toml force-include)
COPY --from=frontend-builder /app/front/dist ./app/static

# Step 4: Install the project itself
RUN --mount=type=cache,target=/root/.cache/uv \
    uv sync --locked --no-dev --extra rnet --extra curl

# Create data directory
RUN mkdir -p /data

# Activate virtual environment (add .venv/bin to PATH)
ENV PATH="/app/.venv/bin:$PATH"

# Environment variables
ENV DATA_FOLDER=/data \
    HOST=0.0.0.0 \
    PORT=5201

# Expose port
EXPOSE 5201

# Reset ENTRYPOINT (uv image default is uv)
ENTRYPOINT []

# Run the application
CMD ["python", "-m", "app.main"]
</file>

<file path="app/core/config.py">
import os
import json
from pathlib import Path
from typing import Optional, List, Dict, Any
from pydantic_settings import BaseSettings, SettingsConfigDict
from pydantic import Field, HttpUrl, field_validator
from dotenv import load_dotenv

class Settings(BaseSettings):
    """Application settings with environment variable and JSON config support."""

    model_config = SettingsConfigDict(
        env_file=".env",
        env_ignore_empty=True,
        extra="ignore",
    )

    @classmethod
    def settings_customise_sources(
        cls,
        settings_cls,
        init_settings,
        env_settings,
        dotenv_settings,
        file_secret_settings,
    ):
        """Customize settings sources to add JSON config support.

        Priority order (highest to lowest):
        1. JSON config file
        2. Environment variables
        3. .env file
        4. Default values
        """
        return (
            init_settings,
            cls._json_config_settings,
            env_settings,
            dotenv_settings,
            file_secret_settings,
        )

    @classmethod
    def _json_config_settings(cls) -> Dict[str, Any]:
        """Load settings from JSON config file in data_folder."""

        # Check if NO_FILESYSTEM_MODE is enabled
        if os.environ.get("NO_FILESYSTEM_MODE", "").lower() in ("true", "1", "yes"):
            return {}

        # Load .env file to ensure environment variables are available
        load_dotenv()

        # First get data_folder from env or default
        data_folder = os.environ.get(
            "DATA_FOLDER", str(Path.home() / ".clove" / "data")
        )

        config_path = os.path.join(data_folder, "config.json")

        if os.path.exists(config_path):
            try:
                with open(config_path, "r", encoding="utf-8") as f:
                    config_data = json.load(f)
                    return config_data
            except (json.JSONDecodeError, IOError):
                # If there's an error reading the JSON, just return empty dict
                return {}
        return {}

    # Server settings
    host: str = Field(default="0.0.0.0", env="HOST")
    port: int = Field(default=5201, env="PORT")

    # Application configuration
    data_folder: Path = Field(
        default=Path.home() / ".clove" / "data",
        env="DATA_FOLDER",
        description="Folder path for storing persistent data (accounts, etc.)",
    )
    locales_folder: Path = Field(
        default=Path(__file__).parent.parent / "locales",
        env="LOCALES_FOLDER",
        description="Folder path for storing translation files",
    )
    static_folder: Path = Field(
        default=Path(__file__).parent.parent / "static",
        env="STATIC_FOLDER",
        description="Folder path for storing static files",
    )
    default_language: str = Field(
        default="en",
        env="DEFAULT_LANGUAGE",
        description="Default language code for translations",
    )
    retry_attempts: int = Field(
        default=3,
        env="RETRY_ATTEMPTS",
        description="Number of retry attempts for failed requests",
    )
    retry_interval: int = Field(
        default=1,
        env="RETRY_INTERVAL",
        description="Interval between retry attempts in seconds",
    )
    no_filesystem_mode: bool = Field(
        default=False,
        env="NO_FILESYSTEM_MODE",
        description="When True, disables all filesystem operations (accounts/settings stored in memory only)",
    )

    # Proxy settings
    proxy_url: Optional[str] = Field(default=None, env="PROXY_URL")

    # API Keys
    api_keys: List[str] | str = Field(
        default_factory=list,
        env="API_KEYS",
        description="Comma-separated list of API keys",
    )
    admin_api_keys: List[str] | str = Field(
        default_factory=list,
        env="ADMIN_API_KEYS",
        description="Comma-separated list of admin API keys",
    )

    # Claude URLs
    claude_ai_url: HttpUrl = Field(default="https://claude.ai", env="CLAUDE_AI_URL")
    claude_api_baseurl: HttpUrl = Field(
        default="https://api.anthropic.com", env="CLAUDE_API_BASEURL"
    )

    # Cookies
    cookies: List[str] | str = Field(
        default_factory=list,
        env="COOKIES",
        description="Comma-separated list of Claude.ai cookies",
    )

    # Content processing
    custom_prompt: Optional[str] = Field(default=None, env="CUSTOM_PROMPT")
    use_real_roles: bool = Field(default=True, env="USE_REAL_ROLES")
    human_name: str = Field(default="Human", env="CUSTOM_HUMAN_NAME")
    assistant_name: str = Field(default="Assistant", env="CUSTOM_ASSISTANT_NAME")
    pad_tokens: List[str] | str = Field(default_factory=list, env="PAD_TOKENS")
    padtxt_length: int = Field(default=0, env="PADTXT_LENGTH")
    allow_external_images: bool = Field(
        default=False,
        env="ALLOW_EXTERNAL_IMAGES",
        description="Allow downloading images from external URLs",
    )

    # Request settings
    request_timeout: int = Field(default=60, env="REQUEST_TIMEOUT")
    request_retries: int = Field(default=3, env="REQUEST_RETRIES")
    request_retry_interval: int = Field(default=1, env="REQUEST_RETRY_INTERVAL")

    # Feature flags
    preserve_chats: bool = Field(default=False, env="PRESERVE_CHATS")

    # Logging
    log_level: str = Field(default="INFO", env="LOG_LEVEL")
    log_to_file: bool = Field(
        default=False, env="LOG_TO_FILE", description="Enable logging to file"
    )
    log_file_path: str = Field(
        default="logs/app.log", env="LOG_FILE_PATH", description="Log file path"
    )
    log_file_rotation: str = Field(
        default="10 MB",
        env="LOG_FILE_ROTATION",
        description="Log file rotation (e.g., '10 MB', '1 day', '1 week')",
    )
    log_file_retention: str = Field(
        default="7 days",
        env="LOG_FILE_RETENTION",
        description="Log file retention (e.g., '7 days', '1 month')",
    )
    log_file_compression: str = Field(
        default="zip",
        env="LOG_FILE_COMPRESSION",
        description="Log file compression format",
    )

    # Session management settings
    session_timeout: int = Field(
        default=300,
        env="SESSION_TIMEOUT",
        description="Session idle timeout in seconds",
    )
    session_cleanup_interval: int = Field(
        default=30,
        env="SESSION_CLEANUP_INTERVAL",
        description="Interval for cleaning up expired sessions in seconds",
    )
    max_sessions_per_cookie: int = Field(
        default=3,
        env="MAX_SESSIONS_PER_COOKIE",
        description="Maximum number of concurrent sessions per cookie",
    )

    # Account management settings
    account_task_interval: int = Field(
        default=60,
        env="ACCOUNT_TASK_INTERVAL",
        description="Interval for account management task in seconds",
    )

    # Tool call settings
    tool_call_timeout: int = Field(
        default=300,
        env="TOOL_CALL_TIMEOUT",
        description="Timeout for pending tool calls in seconds",
    )
    tool_call_cleanup_interval: int = Field(
        default=60,
        env="TOOL_CALL_CLEANUP_INTERVAL",
        description="Interval for cleaning up expired tool calls in seconds",
    )

    # Cache settings
    cache_timeout: int = Field(
        default=300,
        env="CACHE_TIMEOUT",
        description="Timeout for cache checkpoints in seconds (default: 5 minutes)",
    )
    cache_cleanup_interval: int = Field(
        default=60,
        env="CACHE_CLEANUP_INTERVAL",
        description="Interval for cleaning up expired cache checkpoints in seconds",
    )

    # Claude OAuth settings
    oauth_client_id: str = Field(
        default="9d1c250a-e61b-44d9-88ed-5944d1962f5e",
        env="OAUTH_CLIENT_ID",
        description="OAuth client ID for Claude authentication",
    )
    oauth_authorize_url: str = Field(
        default="https://claude.ai/v1/oauth/{organization_uuid}/authorize",
        env="OAUTH_AUTHORIZE_URL",
        description="OAuth authorization endpoint URL template",
    )
    oauth_token_url: str = Field(
        default="https://console.anthropic.com/v1/oauth/token",
        env="OAUTH_TOKEN_URL",
        description="OAuth token exchange endpoint URL",
    )
    oauth_redirect_uri: str = Field(
        default="https://console.anthropic.com/oauth/code/callback",
        env="OAUTH_REDIRECT_URI",
        description="OAuth redirect URI for authorization flow",
    )

    # Claude API Specific
    max_models: List[str] | str = Field(
        default=["claude-opus-4-20250514"],
        env="MAX_MODELS",
        description="Comma-separated list of models that require max plan accounts",
    )

    @field_validator(
        "api_keys", "admin_api_keys", "cookies", "max_models", "pad_tokens"
    )
    def parse_comma_separated(cls, v: str | List[str]) -> List[str]:
        """Parse comma-separated string."""
        if isinstance(v, str):
            return [key.strip() for key in v.split(",") if key.strip()]
        return v


settings = Settings()
</file>

<file path="app/core/external/claude_client.py">
import json
from loguru import logger
from datetime import datetime, timezone
from typing import Optional, Dict, Any
from urllib.parse import urljoin
from uuid import uuid4

from app.core.http_client import (
    create_session,
    Response,
    AsyncSession,
)

from app.core.config import settings
from app.core.exceptions import (
    ClaudeAuthenticationError,
    ClaudeRateLimitedError,
    CloudflareBlockedError,
    OrganizationDisabledError,
    ClaudeHttpError,
)
from app.models.internal import UploadResponse
from app.core.account import Account


class ClaudeWebClient:
    """Client for interacting with Claude.ai."""

    def __init__(self, account: Account):
        self.account = account
        self.session: Optional[AsyncSession] = None
        self.endpoint = settings.claude_ai_url.encoded_string().rstrip("/")

    async def initialize(self):
        """Initialize the client session."""
        self.session = create_session(
            timeout=settings.request_timeout,
            impersonate="chrome",
            proxy=settings.proxy_url,
            follow_redirects=False,
        )

    async def cleanup(self):
        """Clean up resources."""
        if self.session:
            await self.session.close()

    def _build_headers(
        self, cookie: str, conv_uuid: Optional[str] = None
    ) -> Dict[str, str]:
        """Build request headers."""
        headers = {
            "Accept": "text/event-stream",
            "Accept-Language": "en-US,en;q=0.9",
            "Cache-Control": "no-cache",
            "Cookie": cookie,
            "Origin": self.endpoint,
            "Referer": f"{self.endpoint}/new",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
        }

        if conv_uuid:
            headers["Referer"] = f"{self.endpoint}/chat/{conv_uuid}"

        return headers

    async def _request(
        self,
        method: str,
        url: str,
        conv_uuid: Optional[str] = None,
        stream=None,
        **kwargs,
    ) -> Response:
        """Make HTTP request with error handling."""
        if not self.session:
            await self.initialize()

        with self.account as account:
            cookie_value = account.cookie_value
            headers = self._build_headers(cookie_value, conv_uuid)
            kwargs["headers"] = {**headers, **kwargs.get("headers", {})}
            response: Response = await self.session.request(
                method=method, url=url, stream=stream, **kwargs
            )

            if response.status_code < 300:
                return response

            if response.status_code == 302:
                raise CloudflareBlockedError()

            try:
                error_data = await response.json()
                error_body = error_data.get("error", {})
                error_message = error_body.get("message", "Unknown error")
                error_type = error_body.get("type", "unknown")
            except Exception:
                error_message = f"HTTP {response.status_code} error with empty response"
                error_type = "empty_response"

            if (
                response.status_code == 400
                and error_message == "This organization has been disabled."
            ):
                raise OrganizationDisabledError()

            if response.status_code == 403 and error_message == "Invalid authorization":
                raise ClaudeAuthenticationError()

            if response.status_code == 429:
                try:
                    error_message_data = json.loads(error_message)
                    resets_at = error_message_data.get("resetsAt")
                    if resets_at and isinstance(resets_at, int):
                        reset_time = datetime.fromtimestamp(resets_at, tz=timezone.utc)
                        logger.error(f"Rate limit exceeded, resets at: {reset_time}")
                        raise ClaudeRateLimitedError(resets_at=reset_time)
                except json.JSONDecodeError:
                    pass

            raise ClaudeHttpError(
                url=url,
                status_code=response.status_code,
                error_type=error_type,
                error_message=error_message,
            )

    async def create_conversation(self) -> str:
        """Create a new conversation."""
        url = urljoin(
            self.endpoint,
            f"/api/organizations/{self.account.organization_uuid}/chat_conversations",
        )

        uuid = uuid4()

        payload = {
            "name": "Hello World!",
            "uuid": str(uuid),
        }
        response = await self._request("POST", url, json=payload)

        data = await response.json()
        conv_uuid = data.get("uuid")
        paprika_mode = data.get("settings", {}).get("paprika_mode")
        logger.info(f"Created conversation: {conv_uuid}")

        return conv_uuid, paprika_mode

    async def set_paprika_mode(self, conv_uuid: str, mode: Optional[str]) -> None:
        """Set the conversation mode."""
        url = urljoin(
            self.endpoint,
            f"/api/organizations/{self.account.organization_uuid}/chat_conversations/{conv_uuid}",
        )
        payload = {"settings": {"paprika_mode": mode}}
        await self._request("PUT", url, json=payload)
        logger.debug(f"Set conversation {conv_uuid} mode: {mode}")

    async def upload_file(
        self, file_data: bytes, filename: str, content_type: str
    ) -> str:
        """Upload a file and return file UUID."""
        url = urljoin(self.endpoint, f"/api/{self.account.organization_uuid}/upload")
        files = {"file": (filename, file_data, content_type)}

        response = await self._request("POST", url, files=files)

        data = UploadResponse.model_validate(await response.json())
        return data.file_uuid

    async def send_message(self, payload: Dict[str, Any], conv_uuid: str) -> Response:
        """Send a message and return the response."""
        url = urljoin(
            self.endpoint,
            f"/api/organizations/{self.account.organization_uuid}/chat_conversations/{conv_uuid}/completion",
        )

        headers = {
            "Accept": "text/event-stream",
        }

        response = await self._request(
            "POST", url, conv_uuid=conv_uuid, json=payload, headers=headers, stream=True
        )

        return response

    async def send_tool_result(self, payload: Dict[str, Any], conv_uuid: str):
        """Send tool result to Claude.ai."""
        url = urljoin(
            self.endpoint,
            f"/api/organizations/{self.account.organization_uuid}/chat_conversations/{conv_uuid}/tool_result",
        )

        await self._request("POST", url, conv_uuid=conv_uuid, json=payload)

    async def delete_conversation(self, conv_uuid: str) -> None:
        """Delete a conversation."""
        if not conv_uuid:
            return

        url = urljoin(
            self.endpoint,
            f"/api/organizations/{self.account.organization_uuid}/chat_conversations/{conv_uuid}",
        )
        try:
            await self._request("DELETE", url, conv_uuid=conv_uuid)
            logger.info(f"Deleted conversation: {conv_uuid}")
        except Exception as e:
            logger.warning(f"Failed to delete conversation: {e}")
</file>

<file path="app/services/account.py">
import asyncio
from datetime import datetime, UTC
from typing import List, Optional, Dict, Set

from collections import defaultdict
from loguru import logger
import threading
import json
import uuid

from app.core.config import settings
from app.core.exceptions import NoAccountsAvailableError
from app.core.account import Account, AccountStatus, AuthType, OAuthToken, PreferredAuthMethod
from app.services.oauth import oauth_authenticator


class AccountManager:
    """
    Singleton manager for Claude.ai accounts with load balancing and rate limit recovery.
    Supports both cookie and OAuth authentication.
    """

    _instance: Optional["AccountManager"] = None
    _lock = threading.Lock()

    def __new__(cls):
        """Implement singleton pattern."""
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self):
        """Initialize the AccountManager."""
        self._accounts: Dict[str, Account] = {}  # organization_uuid -> Account
        self._cookie_to_uuid: Dict[str, str] = {}  # cookie_value -> organization_uuid
        self._session_accounts: Dict[str, str] = {}  # session_id -> organization_uuid
        self._account_sessions: Dict[str, Set[str]] = defaultdict(
            set
        )  # organization_uuid -> set of session_ids
        self._account_task: Optional[asyncio.Task] = None
        self._max_sessions_per_account = settings.max_sessions_per_cookie
        self._account_task_interval = settings.account_task_interval

        logger.info("AccountManager initialized")

    async def add_account(
        self,
        cookie_value: Optional[str] = None,
        oauth_token: Optional[OAuthToken] = None,
        organization_uuid: Optional[str] = None,
        capabilities: Optional[List[str]] = None,
    ) -> Account:
        """Add a new account to the manager.

        Args:
            cookie_value: The cookie value (optional)
            oauth_token: The OAuth token (optional)
            organization_uuid: The organization UUID (optional, will be fetched or generated if not provided)
            capabilities: The account capabilities (optional)

        Raises:
            ValueError: If neither cookie_value nor oauth_token is provided
        """
        if not cookie_value and not oauth_token:
            raise ValueError("Either cookie_value or oauth_token must be provided")

        if cookie_value and cookie_value in self._cookie_to_uuid:
            return self._accounts[self._cookie_to_uuid[cookie_value]]

        if cookie_value and (not organization_uuid or not capabilities):
            (
                fetched_uuid,
                capabilities,
            ) = await oauth_authenticator.get_organization_info(cookie_value)
            if fetched_uuid:
                organization_uuid = fetched_uuid

        if organization_uuid and organization_uuid in self._accounts:
            existing_account = self._accounts[organization_uuid]

            if cookie_value and existing_account.cookie_value != cookie_value:
                if existing_account.cookie_value:
                    del self._cookie_to_uuid[existing_account.cookie_value]
                existing_account.cookie_value = cookie_value
                self._cookie_to_uuid[cookie_value] = organization_uuid
            return existing_account

        if not organization_uuid:
            organization_uuid = str(uuid.uuid4())
            logger.info(f"Generated new organization UUID: {organization_uuid}")

        # Create new account
        if cookie_value and oauth_token:
            auth_type = AuthType.BOTH
        elif cookie_value:
            auth_type = AuthType.COOKIE_ONLY
        else:
            auth_type = AuthType.OAUTH_ONLY

        account = Account(
            organization_uuid=organization_uuid,
            capabilities=capabilities,
            cookie_value=cookie_value,
            oauth_token=oauth_token,
            auth_type=auth_type,
        )
        self._accounts[organization_uuid] = account
        self.save_accounts()

        if cookie_value:
            self._cookie_to_uuid[cookie_value] = organization_uuid

        logger.info(
            f"Added new account: {organization_uuid[:8]}... "
            f"(auth_type: {auth_type.value}, "
            f"cookie: {cookie_value[:20] + '...' if cookie_value else 'None'}, "
            f"oauth: {'Yes' if oauth_token else 'No'})"
        )

        if auth_type == AuthType.COOKIE_ONLY:
            asyncio.create_task(self._attempt_oauth_authentication(account))

        return account

    async def remove_account(self, organization_uuid: str) -> None:
        """Remove an account from the manager."""
        if organization_uuid in self._accounts:
            account = self._accounts[organization_uuid]
            sessions_to_remove = list(
                self._account_sessions.get(organization_uuid, set())
            )

            for session_id in sessions_to_remove:
                if session_id in self._session_accounts:
                    del self._session_accounts[session_id]

            if account.cookie_value and account.cookie_value in self._cookie_to_uuid:
                del self._cookie_to_uuid[account.cookie_value]

            del self._accounts[organization_uuid]

            if organization_uuid in self._account_sessions:
                del self._account_sessions[organization_uuid]

            logger.info(f"Removed account: {organization_uuid[:8]}...")
            self.save_accounts()

    async def get_account_for_session(
        self,
        session_id: str,
        is_pro: Optional[bool] = None,
        is_max: Optional[bool] = None,
    ) -> Account:
        """
        Get an available account for the session with load balancing.

        Args:
            session_id: Unique identifier for the session
            is_pro: Filter by pro capability. None means any.
            is_max: Filter by max capability. None means any.

        Returns:
            Account instance if available
        """
        # Convert single auth_type to list for uniform handling
        if session_id in self._session_accounts:
            organization_uuid = self._session_accounts[session_id]
            if organization_uuid in self._accounts:
                account = self._accounts[organization_uuid]
                if account.status == AccountStatus.VALID:
                    return account
                else:
                    del self._session_accounts[session_id]
                    self._account_sessions[organization_uuid].discard(session_id)

        best_account = None
        min_sessions = float("inf")
        earliest_last_used = None

        for organization_uuid, account in self._accounts.items():
            if account.status != AccountStatus.VALID:
                continue

            # Filter by auth type if specified
            if account.auth_type not in [AuthType.BOTH, AuthType.COOKIE_ONLY]:
                continue

            # Skip if user prefers OAuth only
            if account.preferred_auth == PreferredAuthMethod.OAUTH:
                continue

            # Filter by capabilities if specified
            if is_pro is not None and account.is_pro != is_pro:
                continue
            if is_max is not None and account.is_max != is_max:
                continue

            session_count = len(self._account_sessions[organization_uuid])
            if session_count >= self._max_sessions_per_account:
                continue

            # Select account with least sessions
            # If multiple accounts have the same least sessions, select the one with earliest last_used
            if session_count < min_sessions or (
                session_count == min_sessions
                and (
                    earliest_last_used is not None
                    and account.last_used < earliest_last_used
                )
            ):
                min_sessions = session_count
                earliest_last_used = account.last_used
                best_account = account

        if best_account:
            self._session_accounts[session_id] = best_account.organization_uuid
            self._account_sessions[best_account.organization_uuid].add(session_id)

            logger.debug(
                f"Assigned account to session {session_id}, "
                f"account now has {len(self._account_sessions[best_account.organization_uuid])} sessions"
            )

            return best_account

        raise NoAccountsAvailableError()

    async def get_account_for_oauth(
        self,
        is_pro: Optional[bool] = None,
        is_max: Optional[bool] = None,
    ) -> Account:
        """
        Get an available account for OAuth authentication.

        Args:
            is_pro: Filter by pro capability. None means any.
            is_max: Filter by max capability. None means any.

        Returns:
            Account instance if available
        """
        earliest_account = None
        earliest_last_used = None

        for account in self._accounts.values():
            if account.status != AccountStatus.VALID:
                continue

            if account.auth_type not in [AuthType.OAUTH_ONLY, AuthType.BOTH]:
                continue

            # Skip if user prefers Web (Cookie) only
            if account.preferred_auth == PreferredAuthMethod.WEB:
                continue

            # Filter by capabilities if specified
            if is_pro is not None and account.is_pro != is_pro:
                continue
            if is_max is not None and account.is_max != is_max:
                continue

            if earliest_last_used is None or account.last_used < earliest_last_used:
                earliest_last_used = account.last_used
                earliest_account = account

        if earliest_account:
            logger.debug(
                f"Selected OAuth account: {earliest_account.organization_uuid[:8]}... "
                f"(last used: {earliest_account.last_used.isoformat()})"
            )
            return earliest_account

        raise NoAccountsAvailableError()

    async def get_account_by_id(self, account_id: str) -> Optional[Account]:
        """
        Get an account by its organization UUID.

        Args:
            account_id: The organization UUID of the account

        Returns:
            Account instance if found and valid, None otherwise
        """
        account = self._accounts.get(account_id)
        
        if account and account.status == AccountStatus.VALID:
            logger.debug(f"Retrieved account by ID: {account_id[:8]}...")
            return account
        
        if account:
            logger.debug(
                f"Account {account_id[:8]}... found but not valid: status={account.status}"
            )
        else:
            logger.debug(f"Account {account_id[:8]}... not found")
        
        return None

    async def release_session(self, session_id: str) -> None:
        """Release a session's account assignment."""
        if session_id in self._session_accounts:
            organization_uuid = self._session_accounts[session_id]
            del self._session_accounts[session_id]

            if organization_uuid in self._account_sessions:
                self._account_sessions[organization_uuid].discard(session_id)

            logger.debug(f"Released account for session {session_id}")

    async def start_task(self) -> None:
        """Start the background task for AccountManager."""
        if self._account_task is None or self._account_task.done():
            self._account_task = asyncio.create_task(self._task_loop())

    async def stop_task(self) -> None:
        """Stop the background task for AccountManager."""
        if self._account_task and not self._account_task.done():
            self._account_task.cancel()
            try:
                await self._account_task
            except asyncio.CancelledError:
                pass

    async def _task_loop(self) -> None:
        """Background loop for AccountManager."""
        while True:
            try:
                await self._check_and_recover_accounts()
                await self._check_and_refresh_accounts()
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Error in task loop: {e}")
            finally:
                await asyncio.sleep(self._account_task_interval)

    async def _check_and_recover_accounts(self) -> None:
        """Check and recover rate-limited accounts."""
        current_time = datetime.now(UTC)

        for account in self._accounts.values():
            # Check rate-limited accounts
            if (
                account.status == AccountStatus.RATE_LIMITED
                and account.resets_at
                and current_time >= account.resets_at
            ):
                account.status = AccountStatus.VALID
                account.resets_at = None
                logger.info(
                    f"Recovered rate-limited account: {account.organization_uuid[:8]}..."
                )

    async def _check_and_refresh_accounts(self) -> None:
        """Check and refresh expired/expiring tokens."""
        current_timestamp = datetime.now(UTC).timestamp()

        for account in self._accounts.values():
            if (
                account.auth_type in [AuthType.OAUTH_ONLY, AuthType.BOTH]
                and account.oauth_token
                and account.oauth_token.refresh_token
                and account.oauth_token.expires_at
            ):
                if account.oauth_token.expires_at - current_timestamp < 300:
                    asyncio.create_task(self._refresh_account_token(account))

    async def _refresh_account_token(self, account: Account) -> None:
        """Refresh OAuth token for an account."""
        logger.info(
            f"Refreshing OAuth token for account: {account.organization_uuid[:8]}..."
        )

        success = await oauth_authenticator.refresh_account_token(account)
        if success:
            logger.info(
                f"Successfully refreshed OAuth token for account: {account.organization_uuid[:8]}..."
            )
        else:
            logger.warning(
                f"Failed to refresh OAuth token for account: {account.organization_uuid[:8]}..."
            )
            if account.auth_type == AuthType.BOTH:
                account.auth_type = AuthType.COOKIE_ONLY
                account.oauth_token = None
            else:
                account.status = AccountStatus.INVALID
                logger.error(
                    f"Account {account.organization_uuid[:8]} is now invalid due to OAuth refresh failure"
                )
            self.save_accounts()

    async def _attempt_oauth_authentication(self, account: Account) -> None:
        """Attempt OAuth authentication for an account."""

        logger.info(
            f"Attempting OAuth authentication for account: {account.organization_uuid[:8]}..."
        )

        success = await oauth_authenticator.authenticate_account(account)
        if not success:
            logger.warning(
                f"OAuth authentication failed for account: {account.organization_uuid[:8]}..., keeping as CookieOnly"
            )
        else:
            logger.info(
                f"OAuth authentication successful for account: {account.organization_uuid[:8]}..."
            )

    async def get_status(self) -> Dict:
        """Get the current status of all accounts."""
        status = {
            "total_accounts": len(self._accounts),
            "valid_accounts": sum(
                1 for a in self._accounts.values() if a.status == AccountStatus.VALID
            ),
            "rate_limited_accounts": sum(
                1
                for a in self._accounts.values()
                if a.status == AccountStatus.RATE_LIMITED
            ),
            "invalid_accounts": sum(
                1 for a in self._accounts.values() if a.status == AccountStatus.INVALID
            ),
            "active_sessions": len(self._session_accounts),
            "accounts": [],
        }

        for organization_uuid, account in self._accounts.items():
            account_info = {
                "organization_uuid": organization_uuid[:8] + "...",
                "cookie": account.cookie_value[:20] + "..."
                if account.cookie_value
                else "None",
                "status": account.status.value,
                "auth_type": account.auth_type.value,
                "sessions": len(self._account_sessions[organization_uuid]),
                "last_used": account.last_used.isoformat(),
                "resets_at": account.resets_at.isoformat()
                if account.resets_at
                else None,
                "has_oauth": account.oauth_token is not None,
            }
            status["accounts"].append(account_info)

        return status

    def save_accounts(self) -> None:
        """Save all accounts to JSON file.

        Args:
            data_folder: Optional data folder path. If not provided, uses settings.data_folder
        """
        if settings.no_filesystem_mode:
            logger.debug("No-filesystem mode enabled, skipping account save to disk")
            return

        settings.data_folder.mkdir(parents=True, exist_ok=True)

        accounts_file = settings.data_folder / "accounts.json"

        accounts_data = {
            organization_uuid: account.to_dict()
            for organization_uuid, account in self._accounts.items()
        }

        with open(accounts_file, "w", encoding="utf-8") as f:
            json.dump(accounts_data, f, indent=2)

        logger.info(f"Saved {len(accounts_data)} accounts to {accounts_file}")

    def load_accounts(self) -> None:
        """Load accounts from JSON file.

        Args:
            data_folder: Optional data folder path. If not provided, uses settings.data_folder
        """
        if settings.no_filesystem_mode:
            logger.debug("No-filesystem mode enabled, skipping account load from disk")
            return

        accounts_file = settings.data_folder / "accounts.json"

        if not accounts_file.exists():
            logger.info(f"No accounts file found at {accounts_file}")
            return

        try:
            with open(accounts_file, "r", encoding="utf-8") as f:
                accounts_data = json.load(f)

            for organization_uuid, account_data in accounts_data.items():
                account = Account.from_dict(account_data)
                self._accounts[organization_uuid] = account

                # Rebuild cookie mapping
                if account.cookie_value:
                    self._cookie_to_uuid[account.cookie_value] = organization_uuid

            logger.info(f"Loaded {len(accounts_data)} accounts from {accounts_file}")

        except Exception as e:
            logger.error(f"Failed to load accounts from {accounts_file}: {e}")

    def __repr__(self) -> str:
        """String representation of the AccountManager."""
        return f"<AccountManager accounts={len(self._accounts)} sessions={len(self._session_accounts)}>"


account_manager = AccountManager()
</file>

<file path="app/core/http_client.py">
"""HTTP client abstraction layer that supports both curl_cffi and httpx."""

from abc import ABC, abstractmethod
from typing import Optional, Dict, Any, Tuple, AsyncIterator
from tenacity import (
    retry,
    retry_if_exception_type,
    stop_after_attempt,
    wait_fixed,
)
from loguru import logger
import json

from app.core.config import settings
from app.utils.retry import log_before_sleep

try:
    import rnet
    from rnet import Client as RnetClient, Method as RnetMethod
    from rnet.exceptions import RequestError as RnetRequestError

    RNET_AVAILABLE = True
except ImportError:
    RNET_AVAILABLE = False

try:
    from curl_cffi.requests import (
        AsyncSession as CurlAsyncSession,
        Response as CurlResponse,
    )
    from curl_cffi.requests.exceptions import RequestException as CurlRequestException
    import curl_cffi

    CURL_CFFI_AVAILABLE = True
except ImportError:
    CURL_CFFI_AVAILABLE = False

# Always try to import httpx as fallback
try:
    import httpx

    HTTPX_AVAILABLE = True
except ImportError:
    HTTPX_AVAILABLE = False

if not RNET_AVAILABLE and not CURL_CFFI_AVAILABLE and not HTTPX_AVAILABLE:
    raise ImportError(
        "Neither rnet, curl_cffi nor httpx is installed. Please install at least one of them."
    )


class Response(ABC):
    """Abstract response class."""

    @property
    @abstractmethod
    def status_code(self) -> int:
        """Get response status code."""
        pass

    @abstractmethod
    async def json(self) -> Any:
        """Parse response as JSON."""
        pass

    @property
    @abstractmethod
    def headers(self) -> Dict[str, str]:
        """Get response headers."""
        pass

    @abstractmethod
    def aiter_bytes(self, chunk_size: Optional[int] = None) -> AsyncIterator[bytes]:
        """Iterate over response bytes."""
        pass


class CurlResponseWrapper(Response):
    """curl_cffi response wrapper."""

    def __init__(self, response: "CurlResponse", stream: bool = False):
        self._response = response
        self._stream = stream

    @property
    def status_code(self) -> int:
        return self._response.status_code

    async def json(self) -> Any:
        if self._stream:
            content = ""
            async for chunk in self._response.aiter_content():
                content += chunk.decode("utf-8")
            return json.loads(content)
        else:
            return self._response.json()

    @property
    def headers(self) -> Dict[str, str]:
        return self._response.headers

    async def aiter_bytes(
        self, chunk_size: Optional[int] = None
    ) -> AsyncIterator[bytes]:
        async for chunk in self._response.aiter_content(chunk_size):
            yield chunk
        await self._response.aclose()


class HttpxResponse(Response):
    """httpx response wrapper."""

    def __init__(self, response: httpx.Response):
        self._response = response

    @property
    def status_code(self) -> int:
        return self._response.status_code

    async def json(self) -> Any:
        await self._response.aread()
        return self._response.json()

    @property
    def headers(self) -> Dict[str, str]:
        return self._response.headers

    async def aiter_bytes(
        self, chunk_size: Optional[int] = None
    ) -> AsyncIterator[bytes]:
        async for chunk in self._response.aiter_bytes(chunk_size):
            yield chunk
        await self._response.aclose()


if RNET_AVAILABLE:

    class RnetResponse(Response):
        """rnet response wrapper."""

        def __init__(self, response: "rnet.Response"):
            self._response = response

        @property
        def status_code(self) -> int:
            return self._response.status.as_int()

        async def json(self) -> Any:
            return await self._response.json()

        @property
        def headers(self) -> Dict[str, str]:
            headers_dict = {}
            for key, value in self._response.headers:
                key_str = key.decode("utf-8") if isinstance(key, bytes) else key
                value_str = value.decode("utf-8") if isinstance(value, bytes) else value
                headers_dict[key_str] = value_str
            return headers_dict

        async def aiter_bytes(
            self, chunk_size: Optional[int] = None
        ) -> AsyncIterator[bytes]:
            async with self._response.stream() as streamer:
                async for chunk in streamer:
                    yield chunk
            await self._response.close()


class AsyncSession(ABC):
    """Abstract async session class."""

    @abstractmethod
    async def request(
        self,
        method: str,
        url: str,
        headers: Optional[Dict[str, str]] = None,
        json: Optional[Any] = None,
        data: Optional[Any] = None,
        stream: bool = False,
        **kwargs,
    ) -> Response:
        """Make an HTTP request."""
        pass

    @abstractmethod
    async def close(self):
        """Close the session."""
        pass

    async def __aenter__(self):
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.close()


if CURL_CFFI_AVAILABLE:

    class CurlAsyncSessionWrapper(AsyncSession):
        """curl_cffi async session wrapper."""

        def __init__(
            self,
            timeout: int = settings.request_timeout,
            impersonate: str = "chrome",
            proxy: Optional[str] = settings.proxy_url,
            follow_redirects: bool = True,
        ):
            self._session = CurlAsyncSession(
                timeout=timeout,
                impersonate=impersonate,
                proxy=proxy,
                allow_redirects=follow_redirects,
            )

        def process_files(self, files: dict) -> curl_cffi.CurlMime:
            # Create multipart form
            multipart = curl_cffi.CurlMime()

            # Handle different file formats
            if isinstance(files, dict):
                for field_name, file_info in files.items():
                    if isinstance(file_info, tuple):
                        # Format: {"field": (filename, data, content_type)}
                        if len(file_info) >= 3:
                            filename, file_data, content_type = file_info[:3]
                        elif len(file_info) == 2:
                            filename, file_data = file_info
                            content_type = "application/octet-stream"
                        else:
                            raise ValueError(
                                f"Invalid file tuple format for field {field_name}"
                            )

                        multipart.addpart(
                            name=field_name,
                            content_type=content_type,
                            filename=filename,
                            data=file_data,
                        )
                    else:
                        # Simple format: {"field": data}
                        multipart.addpart(
                            name=field_name,
                            data=file_info,
                        )

            return multipart

        @retry(
            stop=stop_after_attempt(settings.request_retries),
            wait=wait_fixed(settings.request_retry_interval),
            retry=retry_if_exception_type(CurlRequestException),
            before_sleep=log_before_sleep,
            reraise=True,
        )
        async def request(
            self,
            method: str,
            url: str,
            headers: Optional[Dict[str, str]] = None,
            json: Optional[Any] = None,
            data: Optional[Any] = None,
            stream: bool = False,
            **kwargs,
        ) -> Response:
            logger.debug(f"Making {method} request to {url}")

            # Handle file uploads - convert files parameter to multipart
            files = kwargs.pop("files", None)

            multipart = None

            if files:
                multipart = self.process_files(files)
                kwargs["multipart"] = multipart

            try:
                response = await self._session.request(
                    method=method,
                    url=url,
                    headers=headers,
                    json=json,
                    data=data,
                    stream=stream,
                    **kwargs,
                )
                return CurlResponseWrapper(response, stream=stream)
            finally:
                if multipart:
                    multipart.close()

        async def close(self):
            await self._session.close()


if RNET_AVAILABLE:

    class RnetAsyncSession(AsyncSession):
        """rnet async session wrapper."""

        def __init__(
            self,
            timeout: int = settings.request_timeout,
            impersonate: str = "chrome",
            proxy: Optional[str] = settings.proxy_url,
            follow_redirects: bool = True,
        ):
            # Map impersonate string to rnet Emulation enum
            emulation_map = {
                "chrome": rnet.Emulation.Chrome142,
                "firefox": rnet.Emulation.Firefox136,
                "safari": rnet.Emulation.Safari18,
                "edge": rnet.Emulation.Edge134,
            }

            # Use Chrome as default if not found in map
            rnet_emulation = emulation_map.get(
                impersonate.lower(), rnet.Emulation.Chrome142
            )

            # Create proxy list if proxy is provided
            proxies = None
            if proxy:
                proxies = [rnet.Proxy.all(proxy)]

            self._client = RnetClient(
                emulation=rnet_emulation,
                timeout=timeout,
                proxies=proxies,
                allow_redirects=follow_redirects,
            )

        @retry(
            stop=stop_after_attempt(settings.request_retries),
            wait=wait_fixed(settings.request_retry_interval),
            retry=retry_if_exception_type(RnetRequestError),
            before_sleep=log_before_sleep,
            reraise=True,
        )
        async def request(
            self,
            method: str,
            url: str,
            headers: Optional[Dict[str, str]] = None,
            json: Optional[Any] = None,
            data: Optional[Any] = None,
            stream: bool = False,
            **kwargs,
        ) -> Response:
            logger.debug(f"Making {method} request to {url}")

            # Map method string to rnet Method enum
            method_map = {
                "GET": RnetMethod.GET,
                "POST": RnetMethod.POST,
                "PUT": RnetMethod.PUT,
                "DELETE": RnetMethod.DELETE,
                "PATCH": RnetMethod.PATCH,
                "HEAD": RnetMethod.HEAD,
                "OPTIONS": RnetMethod.OPTIONS,
                "TRACE": RnetMethod.TRACE,
            }

            rnet_method = method_map.get(method.upper(), RnetMethod.GET)

            # Handle file uploads - convert files parameter to multipart
            files = kwargs.pop("files", None)
            multipart = None

            if files:
                # Convert files dict to rnet Multipart
                parts = []
                for field_name, file_info in files.items():
                    if isinstance(file_info, tuple):
                        # Format: {"field": (filename, data, content_type)}
                        if len(file_info) >= 3:
                            filename, file_data, content_type = file_info[:3]
                        elif len(file_info) == 2:
                            filename, file_data = file_info
                            content_type = "application/octet-stream"
                        else:
                            raise ValueError(
                                f"Invalid file tuple format for field {field_name}"
                            )

                        parts.append(
                            rnet.Part(
                                name=field_name,
                                value=file_data,
                                filename=filename,
                                mime=content_type,
                            )
                        )
                    else:
                        # Simple format: {"field": data}
                        parts.append(rnet.Part(name=field_name, value=file_info))

                multipart = rnet.Multipart(*parts)
                kwargs["multipart"] = multipart

            request_kwargs = {}
            if headers:
                request_kwargs["headers"] = headers
            if json is not None:
                request_kwargs["json"] = json
            elif data is not None:
                # rnet uses 'form' for form data, 'body' for raw data
                if isinstance(data, dict) or isinstance(data, list):
                    request_kwargs["form"] = (
                        [(k, v) for k, v in data.items()]
                        if isinstance(data, dict)
                        else data
                    )
                else:
                    request_kwargs["body"] = data

            request_kwargs.update(kwargs)

            response = await self._client.request(
                method=rnet_method,
                url=url,
                **request_kwargs,
            )

            return RnetResponse(response)

        async def close(self):
            # rnet Client doesn't have an explicit close method
            # The connection pooling is handled internally
            pass


if HTTPX_AVAILABLE:

    class HttpxAsyncSession(AsyncSession):
        """httpx async session wrapper."""

        def __init__(
            self,
            timeout: int = settings.request_timeout,
            impersonate: str = "chrome",
            proxy: Optional[str] = settings.proxy_url,
            follow_redirects: bool = True,
        ):
            self._client = httpx.AsyncClient(
                timeout=timeout,
                proxy=proxy,
                follow_redirects=follow_redirects,
            )

        async def stream(
            self,
            method: str,
            url: str,
            headers: Optional[Dict[str, str]] = None,
            json: Optional[Any] = None,
            data: Optional[Any] = None,
            **kwargs,
        ) -> Response:
            """
            Alternative to `httpx.request()` that streams the response body
            instead of loading it into memory at once.

            **Parameters**: See `httpx.request`.

            See also: [Streaming Responses][0]

            [0]: /quickstart#streaming-responses
            """
            request = self._client.build_request(
                method=method,
                url=url,
                data=data,
                json=json,
                headers=headers,
                **kwargs,
            )
            response = await self._client.send(
                request=request,
                stream=True,
            )

            return response

        @retry(
            stop=stop_after_attempt(settings.request_retries),
            wait=wait_fixed(settings.request_retry_interval),
            retry=retry_if_exception_type(httpx.RequestError),
            before_sleep=log_before_sleep,
            reraise=True,
        )
        async def request(
            self,
            method: str,
            url: str,
            headers: Optional[Dict[str, str]] = None,
            json: Optional[Any] = None,
            data: Optional[Any] = None,
            stream: bool = False,
            **kwargs,
        ) -> Response:
            logger.debug(f"Making {method} request to {url}")
            if stream:
                response = await self.stream(
                    method=method,
                    url=url,
                    headers=headers,
                    json=json,
                    data=data,
                    **kwargs,
                )
            else:
                response = await self._client.request(
                    method=method,
                    url=url,
                    headers=headers,
                    json=json,
                    data=data,
                    **kwargs,
                )

            return HttpxResponse(response)

        async def close(self):
            await self._client.aclose()


def create_session(
    timeout: int = settings.request_timeout,
    impersonate: str = "chrome",
    proxy: Optional[str] = settings.proxy_url,
    follow_redirects: bool = True,
) -> AsyncSession:
    """Create an async session using the available HTTP client.

    Prefers rnet if available, then curl_cffi, falls back to httpx.
    """
    if RNET_AVAILABLE:
        logger.debug("Using rnet as HTTP client")
        return RnetAsyncSession(
            timeout=timeout,
            impersonate=impersonate,
            proxy=proxy,
            follow_redirects=follow_redirects,
        )
    elif CURL_CFFI_AVAILABLE:
        logger.debug("Using curl_cffi as HTTP client")
        return CurlAsyncSessionWrapper(
            timeout=timeout,
            impersonate=impersonate,
            proxy=proxy,
            follow_redirects=follow_redirects,
        )
    else:
        logger.debug("Using httpx as HTTP client (rnet and curl_cffi not available)")
        return HttpxAsyncSession(
            timeout=timeout,
            impersonate=impersonate,
            proxy=proxy,
            follow_redirects=follow_redirects,
        )


async def download_image(url: str, timeout: int = 30) -> Tuple[bytes, str]:
    """Download an image from a URL and return content and content type.

    Uses the unified session interface that works with both curl_cffi and httpx.
    """
    async with create_session(timeout=timeout) as session:
        response = await session.request("GET", url)
        content_type = response.headers.get("content-type", "image/jpeg")

        # Read the response content
        content = b""
        async for chunk in response.aiter_bytes():
            content += chunk

        return content, content_type


# Export the appropriate exception class
if RNET_AVAILABLE:
    RequestException = RnetRequestError
elif CURL_CFFI_AVAILABLE:
    RequestException = CurlRequestException
else:
    RequestException = httpx.RequestError
</file>

<file path="app/services/oauth.py">
import base64
import hashlib
import secrets
import time
from typing import Dict, List, Optional, Tuple
from urllib.parse import urlparse, parse_qs

from app.core.http_client import Response, create_session
from loguru import logger

from app.core.config import settings
from app.core.account import Account, AuthType, OAuthToken
from app.core.exceptions import (
    AppError,
    ClaudeAuthenticationError,
    ClaudeHttpError,
    CloudflareBlockedError,
    CookieAuthorizationError,
    OAuthExchangeError,
    OrganizationInfoError,
)


class OAuthAuthenticator:
    """OAuth authenticator for Claude accounts using cookies."""

    def _generate_pkce(self) -> Tuple[str, str]:
        """Generate PKCE verifier and challenge."""
        verifier = (
            base64.urlsafe_b64encode(secrets.token_bytes(32))
            .decode("utf-8")
            .rstrip("=")
        )
        challenge = (
            base64.urlsafe_b64encode(hashlib.sha256(verifier.encode("utf-8")).digest())
            .decode("utf-8")
            .rstrip("=")
        )
        return verifier, challenge

    def _build_headers(self, cookie: str) -> Dict[str, str]:
        """Build request headers."""
        claude_endpoint = settings.claude_ai_url.encoded_string().rstrip("/")

        return {
            "Accept": "application/json",
            "Accept-Language": "en-US,en;q=0.9",
            "Cache-Control": "no-cache",
            "Cookie": cookie,
            "Origin": claude_endpoint,
            "Referer": f"{claude_endpoint}/new",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
        }

    async def _request(self, method: str, url: str, **kwargs) -> Response:
        session = create_session(
            timeout=settings.request_timeout,
            impersonate="chrome",
            proxy=settings.proxy_url,
            follow_redirects=False,
        )
        async with session:
            response: Response = await session.request(method=method, url=url, **kwargs)

        if response.status_code == 302:
            raise CloudflareBlockedError()

        if response.status_code == 403:
            raise ClaudeAuthenticationError()

        if response.status_code >= 300:
            raise ClaudeHttpError(
                url=url,
                status_code=response.status_code,
                error_type="Unknown",
                error_message="Error occurred during request to Claude.ai",
            )

        return response

    async def get_organization_info(self, cookie: str) -> Tuple[str, List[str]]:
        """Get organization UUID and capabilities."""
        url = f"{settings.claude_ai_url.encoded_string().rstrip('/')}/api/organizations"
        headers = self._build_headers(cookie)

        try:
            response = await self._request("GET", url, headers=headers)

            org_data = await response.json()
            if org_data and isinstance(org_data, list):
                organization_uuid = None
                max_capabilities = []

                for org in org_data:
                    if "uuid" in org and "capabilities" in org:
                        capabilities = org.get("capabilities", [])

                        if "chat" not in capabilities:
                            continue

                        if len(capabilities) > len(max_capabilities):
                            organization_uuid = org.get("uuid")
                            max_capabilities = capabilities

                if organization_uuid:
                    logger.info(
                        f"Found organization UUID: {organization_uuid}, capabilities: {max_capabilities}"
                    )
                    return organization_uuid, max_capabilities

                raise OrganizationInfoError(
                    reason="No valid organization found with chat capabilities"
                )

            else:
                logger.error("No organization data found in response")
                raise OrganizationInfoError(reason="No organization data found")

        except AppError as e:
            raise e

        except Exception as e:
            logger.error(f"Error getting organization UUID: {e}")
            raise OrganizationInfoError(reason=str(e))

    async def authorize_with_cookie(
        self, cookie: str, organization_uuid: str
    ) -> Tuple[str, str]:
        """
        Use Cookie to automatically get authorization code.
        Returns: (authorization code, verifier)
        """
        verifier, challenge = self._generate_pkce()
        state = (
            base64.urlsafe_b64encode(secrets.token_bytes(32))
            .decode("utf-8")
            .rstrip("=")
        )

        authorize_url = settings.oauth_authorize_url.format(
            organization_uuid=organization_uuid
        )

        payload = {
            "response_type": "code",
            "client_id": settings.oauth_client_id,
            "organization_uuid": organization_uuid,
            "redirect_uri": settings.oauth_redirect_uri,
            "scope": "user:profile user:inference",
            "state": state,
            "code_challenge": challenge,
            "code_challenge_method": "S256",
        }

        headers = self._build_headers(cookie)
        headers["Content-Type"] = "application/json"

        logger.debug(f"Requesting authorization from: {authorize_url}")

        response = await self._request(
            "POST", authorize_url, json=payload, headers=headers
        )

        auth_response = await response.json()
        redirect_uri = auth_response.get("redirect_uri")

        if not redirect_uri:
            logger.error("No redirect_uri in authorization response")
            raise CookieAuthorizationError(reason="No redirect URI found in response")

        logger.info(f"Got redirect URI: {redirect_uri}")

        parsed_url = urlparse(redirect_uri)
        query_params = parse_qs(parsed_url.query)

        if "code" not in query_params:
            logger.error("No authorization code in redirect_uri")
            raise CookieAuthorizationError(
                reason="No authorization code found in response"
            )

        auth_code = query_params["code"][0]
        response_state = query_params.get("state", [None])[0]

        logger.info(f"Extracted authorization code: {auth_code[:20]}...")

        if response_state:
            full_code = f"{auth_code}#{response_state}"
        else:
            full_code = auth_code

        return full_code, verifier

    async def exchange_token(self, code: str, verifier: str) -> Dict:
        """Exchange authorization code for access token."""
        parts = code.split("#")
        auth_code = parts[0]
        state = parts[1] if len(parts) > 1 else None

        data = {
            "code": auth_code,
            "grant_type": "authorization_code",
            "client_id": settings.oauth_client_id,
            "redirect_uri": settings.oauth_redirect_uri,
            "code_verifier": verifier,
        }

        if state:
            data["state"] = state

        try:
            response = await self._request(
                "POST",
                settings.oauth_token_url,
                json=data,
                headers={"Content-Type": "application/json"},
            )

            token_data = await response.json()

            if (
                "access_token" not in token_data
                or "refresh_token" not in token_data
                or "expires_in" not in token_data
            ):
                logger.error("Invalid token response received")
                raise OAuthExchangeError(reason="Invalid token response")

            return token_data

        except AppError as e:
            raise e

        except Exception as e:
            logger.error(f"Error exchanging token: {e}")
            raise OAuthExchangeError(reason=str(e))

    async def refresh_access_token(self, refresh_token: str) -> Optional[Dict]:
        """Refresh access token."""
        data = {
            "grant_type": "refresh_token",
            "refresh_token": refresh_token,
            "client_id": settings.oauth_client_id,
        }

        try:
            response = await self._request(
                "POST",
                settings.oauth_token_url,
                json=data,
                headers={"Content-Type": "application/json"},
            )

            if response.status_code != 200:
                logger.error(f"Token refresh failed: {response.status_code}")
                return None

            token_data = await response.json()
            return token_data

        except Exception as e:
            logger.error(f"Error refreshing token: {e}")
            return None

    async def authenticate_account(self, account: Account) -> bool:
        """
        Authenticate an account using OAuth.
        Returns True if successful, False otherwise.
        """
        if not account.cookie_value:
            logger.error("Account has no cookie value")
            return False

        try:
            # Get organization UUID
            org_uuid, _ = await self.get_organization_info(account.cookie_value)

            # Get authorization code
            auth_result = await self.authorize_with_cookie(
                account.cookie_value, org_uuid
            )

            auth_code, verifier = auth_result

            # Exchange for tokens
            token_data = await self.exchange_token(auth_code, verifier)

            # Update account with OAuth tokens
            account.oauth_token = OAuthToken(
                access_token=token_data["access_token"],
                refresh_token=token_data["refresh_token"],
                expires_at=time.time() + token_data["expires_in"],
            )
            account.auth_type = AuthType.BOTH
            account.save()

            logger.info(
                f"Successfully authenticated account with OAuth: {account.organization_uuid[:8]}..."
            )
            return True

        except Exception as e:
            logger.error(f"OAuth authentication failed: {e}")
            return False

    async def refresh_account_token(self, account: Account) -> bool:
        """
        Refresh OAuth token for an account.
        Returns True if successful, False otherwise.
        """
        if not account.oauth_token or not account.oauth_token.refresh_token:
            logger.error("Account has no refresh token")
            return False

        token_data = await self.refresh_access_token(account.oauth_token.refresh_token)
        if not token_data:
            return False

        account.oauth_token = OAuthToken(
            access_token=token_data["access_token"],
            refresh_token=token_data["refresh_token"],
            expires_at=time.time() + token_data["expires_in"],
        )
        account.save()

        logger.info(
            f"Successfully refreshed OAuth token for account: {account.organization_uuid[:8]}..."
        )
        return True


oauth_authenticator = OAuthAuthenticator()
</file>

<file path="app/processors/claude_ai/claude_api_processor.py">
from app.core.http_client import (
    Response,
    AsyncSession,
    create_session,
)
from datetime import datetime, timedelta, UTC
from typing import Dict, Optional
from loguru import logger
from fastapi.responses import StreamingResponse

from app.models.claude import MessagesAPIRequest, TextContent
from app.processors.base import BaseProcessor
from app.processors.claude_ai import ClaudeAIContext
from app.services.account import account_manager
from app.services.cache import cache_service
from app.services.oauth import oauth_authenticator
from app.core.account import Account
from app.core.exceptions import (
    ClaudeHttpError,
    ClaudeRateLimitedError,
    InvalidModelNameError,
    NoAccountsAvailableError,
    OAuthAuthenticationNotAllowedError,
)
from app.core.config import settings


class ClaudeAPIProcessor(BaseProcessor):
    """Processor that calls Claude Messages API directly using OAuth authentication."""

    def __init__(self):
        self.messages_api_url = (
            settings.claude_api_baseurl.encoded_string().rstrip("/") + "/v1/messages"
        )

    async def _request_messages_api(
        self, session: AsyncSession, request_json: str, headers: Dict[str, str]
    ) -> Response:
        """Make HTTP request with retry mechanism for curl_cffi exceptions."""
        response: Response = await session.request(
            "POST",
            self.messages_api_url,
            data=request_json,
            headers=headers,
            stream=True,
        )
        return response

    async def process(self, context: ClaudeAIContext) -> ClaudeAIContext:
        """
        Process Claude API request using OAuth authentication.

        Requires:
            - messages_api_request in context

        Produces:
            - response in context (StreamingResponse)
        """
        if context.response:
            logger.debug("Skipping ClaudeAPIProcessor due to existing response")
            return context

        if not context.messages_api_request:
            logger.warning(
                "Skipping ClaudeAPIProcessor due to missing messages_api_request"
            )
            return context

        self._insert_system_message(context)

        try:
            # First try to get account from cache service
            cached_account_id, checkpoints = cache_service.process_messages(
                context.messages_api_request.model,
                context.messages_api_request.messages,
                context.messages_api_request.system,
            )

            account = None
            if cached_account_id:
                account = await account_manager.get_account_by_id(cached_account_id)
                if account:
                    logger.info(f"Using cached account: {cached_account_id[:8]}...")

            # If no cached account or account not available, get a new one
            if not account:
                account = await account_manager.get_account_for_oauth(
                    is_max=True
                    if (context.messages_api_request.model in settings.max_models)
                    else None
                )

            with account:
                request_json = context.messages_api_request.model_dump_json(
                    exclude_none=True
                )

                # Try the request, with one retry on 401 authentication error
                response, session = await self._execute_api_request_with_retry(
                    account, request_json, context
                )

                resets_at = response.headers.get("anthropic-ratelimit-unified-reset")
                if resets_at:
                    try:
                        resets_at = int(resets_at)
                        account.resets_at = datetime.fromtimestamp(resets_at, tz=UTC)
                    except ValueError:
                        logger.error(
                            f"Invalid resets_at format from Claude API: {resets_at}"
                        )
                        account.resets_at = None

                async def stream_response():
                    async for chunk in response.aiter_bytes():
                        yield chunk

                    await session.close()

                filtered_headers = {}
                for key, value in response.headers.items():
                    if key.lower() in ["content-encoding", "content-length"]:
                        logger.debug(f"Filtering out header: {key}: {value}")
                        continue
                    filtered_headers[key] = value

                context.response = StreamingResponse(
                    stream_response(),
                    status_code=response.status_code,
                    headers=filtered_headers,
                )

                # Stop pipeline on success
                context.metadata["stop_pipeline"] = True
                logger.info("Successfully processed request via Claude API")

                # Store checkpoints in cache service after successful request
                if checkpoints and account:
                    cache_service.add_checkpoints(
                        checkpoints, account.organization_uuid
                    )

        except (NoAccountsAvailableError, InvalidModelNameError):
            logger.debug("No accounts available for Claude API, continuing pipeline")

        return context

    async def _execute_api_request_with_retry(
        self,
        account: Account,
        request_json: str,
        context: ClaudeAIContext,
    ) -> tuple[Response, AsyncSession]:
        """
        Execute API request with retry on 401 authentication error.
        
        If a 401 error occurs with "Invalid authentication credentials",
        try to re-authenticate using the cookie and retry once.
        """
        retried = False

        while True:
            headers = self._prepare_headers(
                account.oauth_token.access_token,
                context.messages_api_request,
                context.original_request,
            )

            session = create_session(
                proxy=settings.proxy_url,
                timeout=settings.request_timeout,
                impersonate="chrome",
                follow_redirects=False,
            )

            response = await self._request_messages_api(session, request_json, headers)

            # Handle rate limiting
            if response.status_code == 429:
                await session.close()
                next_hour = datetime.now(UTC).replace(
                    minute=0, second=0, microsecond=0
                ) + timedelta(hours=1)
                resets_at = response.headers.get("anthropic-ratelimit-unified-reset")
                if resets_at:
                    try:
                        resets_at_dt = datetime.fromtimestamp(int(resets_at), tz=UTC)
                    except ValueError:
                        resets_at_dt = next_hour
                else:
                    resets_at_dt = next_hour
                raise ClaudeRateLimitedError(resets_at=resets_at_dt)

            if response.status_code >= 400:
                error_data = await response.json()
                await session.close()

                if (
                    response.status_code == 400
                    and error_data.get("error", {}).get("message")
                    == "system: Invalid model name"
                ):
                    raise InvalidModelNameError(context.messages_api_request.model)

                if (
                    response.status_code == 401
                    and error_data.get("error", {}).get("message")
                    == "OAuth authentication is currently not allowed for this organization."
                ):
                    raise OAuthAuthenticationNotAllowedError()

                # Handle 401 authentication_error or 403 permission_error (token revoked)
                # - try re-auth with cookie
                is_auth_error = (
                    response.status_code == 401
                    and error_data.get("error", {}).get("type") == "authentication_error"
                )
                is_token_revoked = (
                    response.status_code == 403
                    and error_data.get("error", {}).get("type") == "permission_error"
                )

                if (
                    (is_auth_error or is_token_revoked)
                    and not retried
                    and account.cookie_value
                ):
                    logger.warning(
                        f"{response.status_code} {'token revoked' if is_token_revoked else 'authentication'} error "
                        f"for account {account.organization_uuid[:8]}..., "
                        "attempting re-authentication with cookie"
                    )

                    success = await self._try_reauthenticate_account(account)
                    if success:
                        logger.info(
                            f"Re-authentication successful for account {account.organization_uuid[:8]}..., retrying request"
                        )
                        retried = True
                        continue
                    else:
                        logger.error(
                            f"Re-authentication failed for account {account.organization_uuid[:8]}..."
                        )

                logger.error(
                    f"Claude API error: {response.status_code} - {error_data}"
                )
                raise ClaudeHttpError(
                    url=self.messages_api_url,
                    status_code=response.status_code,
                    error_type=error_data.get("error", {}).get("type", "unknown"),
                    error_message=error_data.get("error", {}).get(
                        "message", "Unknown error"
                    ),
                )

            # Success
            return response, session

    async def _try_reauthenticate_account(self, account: Account) -> bool:
        """
        Try to re-authenticate an account using its cookie.
        Returns True if successful, False otherwise.
        """
        try:
            success = await oauth_authenticator.authenticate_account(account)
            return success
        except Exception as e:
            logger.error(f"Re-authentication error: {e}")
            return False

    def _insert_system_message(self, context: ClaudeAIContext) -> None:
        """Insert system message into the request."""

        request = context.messages_api_request

        # Handle system field
        system_message_text = (
            "You are Claude Code, Anthropic's official CLI for Claude."
        )
        system_message = TextContent(type="text", text=system_message_text)

        if isinstance(request.system, str) and request.system:
            request.system = [
                system_message,
                TextContent(type="text", text=request.system),
            ]
        elif isinstance(request.system, list) and request.system:
            if request.system[0].text == system_message_text:
                logger.debug("System message already exists, skipping injection.")
            else:
                request.system = [system_message] + request.system
        else:
            request.system = [system_message]

    def _prepare_headers(
        self,
        access_token: str,
        request: MessagesAPIRequest,
        original_request=None,
    ) -> Dict[str, str]:
        """Prepare headers for Claude API request.

        Beta headers: oauth  OAuth 
        effort  structured-outputs  GA beta header
         anthropic-beta header 
        """
        # oauth beta  OAuth 
        beta_features = ["oauth-2025-04-20"]

        #  anthropic-beta header beta 
        if original_request:
            client_beta = original_request.headers.get("anthropic-beta", "")
            if client_beta:
                for beta in client_beta.split(","):
                    beta = beta.strip()
                    if beta and beta not in beta_features:
                        beta_features.append(beta)

        return {
            "Authorization": f"Bearer {access_token}",
            "anthropic-beta": ",".join(beta_features),
            "anthropic-version": "2023-06-01",
            "Content-Type": "application/json",
        }
</file>

<file path="pyproject.toml">
[project]
name = "clove-proxy"
version = "0.3.1"
description = "A Claude.ai reverse proxy"
readme = "README.md"
requires-python = ">=3.11"
license = {text = "MIT"}
authors = [
    {name = "mirrorange", email = "orange@freesia.ink"},
]
keywords = ["claude", "ai", "proxy", "fastapi"]
classifiers = [
    "Development Status :: 4 - Beta",
    "Intended Audience :: Education",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: 3.13",
    "Topic :: Software Development :: Libraries :: Python Modules",
]
dependencies = [
    "fastapi>=0.115.14",
    "httpx>=0.28.1",
    "json5>=0.12.0",
    "loguru>=0.7.3",
    "pydantic>=2.11.7",
    "pydantic-settings>=2.10.1",
    "tenacity>=9.1.2",
    "tiktoken>=0.9.0",
    "uvicorn>=0.35.0",
]

[project.urls]
"Homepage" = "https://github.com/mirrorange/clove"
"Bug Tracker" = "https://github.com/mirrorange/clove/issues"
"Documentation" = "https://github.com/mirrorange/clove#readme"

[project.scripts]
clove = "app.main:main"

[project.optional-dependencies]
curl = [
    "curl-cffi>=0.11.4",
]
rnet = [
    "rnet>=3.0.0rc14",
]
dev = [
    "build>=1.0.0",
    "ruff>=0.12.2",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build]
include = [
    "app/**/*",
    "README.md",
    "LICENSE",
]
exclude = [
    "app/**/__pycache__",
    "app/**/*.pyc",
    "app/**/*.pyo",
    "app/**/test_*.py",
    "app/**/*_test.py",
]

[tool.hatch.build.targets.wheel]
packages = ["app"]

[tool.hatch.build.targets.wheel.force-include]
"app/static" = "app/static"
"app/locales" = "app/locales"
</file>

</files>
